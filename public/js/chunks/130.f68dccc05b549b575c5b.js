(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[130],{

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js ***!
  \*************************************************************************/
/*! exports provided: XYChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XYChart", function() { return XYChart; });
/* harmony import */ var _XYChartDefaultTheme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XYChartDefaultTheme */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _core_render_SerialChart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/render/SerialChart */ "./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_render_Button__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/render/Button */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Order__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../core/util/Order */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js");
/* harmony import */ var _core_util_Object__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");















/**
 * Creates an XY chart.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/} for more info
 * @important
 */
class XYChart extends _core_render_SerialChart__WEBPACK_IMPORTED_MODULE_3__["SerialChart"] {
    constructor() {
        super(...arguments);
        /**
         * A list of horizontal axes.
         */
        Object.defineProperty(this, "xAxes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_4__["ListAutoDispose"]()
        });
        /**
         * A list of vertical axes.
         */
        Object.defineProperty(this, "yAxes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_4__["ListAutoDispose"]()
        });
        /**
         * A [[Container]] located on top of the chart, used to store top horizontal
         * axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "topAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.chartContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], layout: this._root.verticalLayout }))
        });
        /**
         * A [[Container]] located in the middle the chart, used to store vertical axes
         * and plot area container.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "yAxesAndPlotContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.chartContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], layout: this._root.horizontalLayout }))
        });
        /**
         * A [[Container]] located on bottom of the chart, used to store bottom
         * horizontal axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "bottomAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.chartContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], layout: this._root.verticalLayout }))
        });
        /**
         * A [[Container]] located on left of the chart, used to store left-hand
         * vertical axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "leftAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.yAxesAndPlotContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], layout: this._root.horizontalLayout }))
        });
        /**
         * A [[Container]] located in the middle of the chart, used to store plotContainer and topPlotContainer
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "plotsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.yAxesAndPlotContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], maskContent: false }))
        });
        /**
         * A [[Container]] located in the middle of the chart, used to store actual
         * plots (series).
         *
         * NOTE: `plotContainer` will automatically have its `background` preset. If
         * you need to modify background or outline for chart's plot area, you can
         * use `plotContainer.get("background")` for that.*
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "plotContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.plotsContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"] }))
        });
        /**
         * A [[Container]] used for any elements that need to be displayed over
         * regular `plotContainer`.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "topPlotContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.plotsContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"] }))
        });
        /**
         * A [[Container]] axis grid elements are stored in.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "gridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.plotContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], isMeasured: false }))
        });
        /**
         * A [[Container]] axis background grid elements are stored in.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "topGridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], isMeasured: false })
        });
        /**
         * A [[Container]] located on right of the chart, used to store right-hand
         * vertical axes.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "rightAxesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.yAxesAndPlotContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], layout: this._root.horizontalLayout }))
        });
        /**
         * A [[Container]] axis headers are stored in.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info
         * @default Container.new()
         */
        Object.defineProperty(this, "axisHeadersContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.plotContainer.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, {}))
        });
        /**
         * A button that is shown when chart is not fully zoomed out.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/zoom-and-pan/#Zoom_out_button} for more info
         * @default Button.new()
         */
        Object.defineProperty(this, "zoomOutButton", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.topPlotContainer.children.push(_core_render_Button__WEBPACK_IMPORTED_MODULE_7__["Button"].new(this._root, {
                themeTags: ["zoom"],
                icon: _core_render_Graphics__WEBPACK_IMPORTED_MODULE_8__["Graphics"].new(this._root, {
                    themeTags: ["button", "icon"]
                })
            }))
        });
        Object.defineProperty(this, "_movePoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { x: 0, y: 0 }
        });
        Object.defineProperty(this, "_wheelDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_otherCharts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_movePoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_downStartX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downEndX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downStartY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downEndY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        this._defaultThemes.push(_XYChartDefaultTheme__WEBPACK_IMPORTED_MODULE_0__["XYChartDefaultTheme"].new(this._root));
        super._afterNew();
        this._disposers.push(this.xAxes);
        this._disposers.push(this.yAxes);
        const root = this._root;
        let verticalLayout = this._root.verticalLayout;
        const zoomOutButton = this.zoomOutButton;
        zoomOutButton.events.on("click", () => {
            this.zoomOut();
        });
        zoomOutButton.set("opacity", 0);
        zoomOutButton.states.lookup("default").set("opacity", 1);
        this.chartContainer.set("layout", verticalLayout);
        const plotContainer = this.plotContainer;
        plotContainer.children.push(this.seriesContainer);
        this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer));
        this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer));
        plotContainer.children.push(this.topGridContainer);
        plotContainer.children.push(this.bulletsContainer);
        // Setting trasnparent background so that full body of the plot container
        // is interactive
        plotContainer.set("interactive", true);
        plotContainer.set("interactiveChildren", false);
        plotContainer.set("background", _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_2__["Rectangle"].new(root, {
            themeTags: ["xy", "background"],
            fill: _core_util_Color__WEBPACK_IMPORTED_MODULE_6__["Color"].fromHex(0x000000),
            fillOpacity: 0
        }));
        this._disposers.push(plotContainer.events.on("pointerdown", (event) => {
            this._handlePlotDown(event.originalEvent);
        }));
        this._disposers.push(plotContainer.events.on("globalpointerup", (event) => {
            this._handlePlotUp(event.originalEvent);
        }));
        this._disposers.push(plotContainer.events.on("globalpointermove", (event) => {
            this._handlePlotMove(event.originalEvent);
        }));
        this._maskGrid();
        this._setUpTouch();
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("pinchZoomX") || this.isDirty("pinchZoomY") || this.get("panX") || this.get("panY")) {
            this._setUpTouch();
        }
    }
    _setUpTouch() {
        if (!this.plotContainer._display.cancelTouch) {
            this.plotContainer._display.cancelTouch = (this.get("pinchZoomX") || this.get("pinchZoomY") || this.get("panX") || this.get("panY")) ? true : false;
        }
    }
    _maskGrid() {
        this.gridContainer.set("maskContent", true);
        this.topGridContainer.set("maskContent", true);
    }
    _removeSeries(series) {
        const xAxis = series.get("xAxis");
        if (xAxis) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["remove"](xAxis.series, series);
            xAxis.markDirtyExtremes();
        }
        const yAxis = series.get("yAxis");
        if (yAxis) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["remove"](yAxis.series, series);
            yAxis.markDirtyExtremes();
        }
        const cursor = this.get("cursor");
        if (cursor) {
            const snapToSeries = cursor.get("snapToSeries");
            if (snapToSeries) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["remove"](snapToSeries, series);
            }
        }
        super._removeSeries(series);
    }
    /**
     * This method is invoked when mouse wheel is used over chart's plot
     * container, and handles zooming/pan.
     *
     * You can invoke this method manually, if you need to mimic chart's wheel
     * behavior over other elements of the chart.
     */
    handleWheel(event) {
        const wheelX = this.get("wheelX");
        const wheelY = this.get("wheelY");
        const plotContainer = this.plotContainer;
        const wheelEvent = event.originalEvent;
        // Ignore wheel event if it is happening on a non-chart element, e.g. if
        // some page element is over the chart.
        if (_core_util_Utils__WEBPACK_IMPORTED_MODULE_13__["isLocalEvent"](wheelEvent, this)) {
            wheelEvent.preventDefault();
        }
        else {
            return;
        }
        const plotPoint = plotContainer.toLocal(this._root.documentPointToRoot({ x: wheelEvent.clientX, y: wheelEvent.clientY }));
        const wheelStep = this.get("wheelStep", 0.2);
        const shiftY = wheelEvent.deltaY / 100;
        const shiftX = wheelEvent.deltaX / 100;
        const wheelZoomPositionX = this.get("wheelZoomPositionX");
        const wheelZoomPositionY = this.get("wheelZoomPositionY");
        if ((wheelX === "zoomX" || wheelX === "zoomXY") && shiftX != 0) {
            this.xAxes.each((axis) => {
                if (axis.get("zoomX")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let position = axis.fixPosition(plotPoint.x / plotContainer.width());
                    if (wheelZoomPositionX != null) {
                        position = wheelZoomPositionX;
                    }
                    let newStart = start - wheelStep * (end - start) * shiftX * position;
                    let newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);
                    if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                }
            });
        }
        if ((wheelY === "zoomX" || wheelY === "zoomXY") && shiftY != 0) {
            this.xAxes.each((axis) => {
                if (axis.get("zoomX")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let position = axis.fixPosition(plotPoint.x / plotContainer.width());
                    if (wheelZoomPositionX != null) {
                        position = wheelZoomPositionX;
                    }
                    let newStart = start - wheelStep * (end - start) * shiftY * position;
                    let newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);
                    if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                }
            });
        }
        if ((wheelX === "zoomY" || wheelX === "zoomXY") && shiftX != 0) {
            this.yAxes.each((axis) => {
                if (axis.get("zoomY")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let position = axis.fixPosition(plotPoint.y / plotContainer.height());
                    if (wheelZoomPositionY != null) {
                        position = wheelZoomPositionY;
                    }
                    let newStart = start - wheelStep * (end - start) * shiftX * position;
                    let newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);
                    if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                }
            });
        }
        if ((wheelY === "zoomY" || wheelY === "zoomXY") && shiftY != 0) {
            this.yAxes.each((axis) => {
                if (axis.get("zoomY")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let position = axis.fixPosition(plotPoint.y / plotContainer.height());
                    if (wheelZoomPositionY != null) {
                        position = wheelZoomPositionY;
                    }
                    let newStart = start - wheelStep * (end - start) * shiftY * position;
                    let newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);
                    if (1 / (newEnd - newStart) < axis.getPrivate("maxZoomFactor", Infinity) / axis.get("minZoomCount", 1)) {
                        this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                    }
                }
            });
        }
        if ((wheelX === "panX" || wheelX === "panXY") && shiftX != 0) {
            this.xAxes.each((axis) => {
                if (axis.get("panX")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftX;
                    let newStart = start + delta;
                    let newEnd = end + delta;
                    let se = this._fixWheel(newStart, newEnd);
                    newStart = se[0];
                    newEnd = se[1];
                    this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                }
            });
        }
        if ((wheelY === "panX" || wheelY === "panXY") && shiftY != 0) {
            this.xAxes.each((axis) => {
                if (axis.get("panX")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftY;
                    let newStart = start + delta;
                    let newEnd = end + delta;
                    let se = this._fixWheel(newStart, newEnd);
                    newStart = se[0];
                    newEnd = se[1];
                    this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                }
            });
        }
        if ((wheelX === "panY" || wheelX === "panXY") && shiftX != 0) {
            this.yAxes.each((axis) => {
                if (axis.get("panY")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftX;
                    let newStart = start + delta;
                    let newEnd = end + delta;
                    let se = this._fixWheel(newStart, newEnd);
                    newStart = se[0];
                    newEnd = se[1];
                    this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                }
            });
        }
        if ((wheelY === "panY" || wheelY === "panXY") && shiftY != 0) {
            this.yAxes.each((axis) => {
                if (axis.get("panY")) {
                    let start = axis.get("start");
                    let end = axis.get("end");
                    let delta = this._getWheelSign(axis) * wheelStep * (end - start) * shiftY;
                    let newStart = start - delta;
                    let newEnd = end - delta;
                    let se = this._fixWheel(newStart, newEnd);
                    newStart = se[0];
                    newEnd = se[1];
                    this._handleWheelAnimation(axis.zoom(newStart, newEnd));
                }
            });
        }
    }
    _handleSetWheel() {
        const wheelX = this.get("wheelX");
        const wheelY = this.get("wheelY");
        const plotContainer = this.plotContainer;
        if (wheelX !== "none" || wheelY !== "none") {
            this._wheelDp = plotContainer.events.on("wheel", (event) => {
                this.handleWheel(event);
            });
            this._disposers.push(this._wheelDp);
        }
        else {
            if (this._wheelDp) {
                this._wheelDp.dispose();
            }
        }
    }
    _getWheelSign(axis) {
        let sign = 1;
        if (axis.get("renderer").get("inversed")) {
            sign = -1;
        }
        return sign;
    }
    _fixWheel(start, end) {
        const diff = end - start;
        if (start < 0) {
            start = 0;
            end = start + diff;
        }
        if (end > 1) {
            end = 1;
            start = end - diff;
        }
        return [start, end];
    }
    _handlePlotDown(event) {
        if (event.button == 2) {
            return;
        }
        const plotContainer = this.plotContainer;
        let local = plotContainer.toLocal(this._root.documentPointToRoot({ x: event.clientX, y: event.clientY }));
        if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
            const touchEvent = event;
            const pointerId = touchEvent.pointerId;
            if (pointerId) {
                if (_core_util_Object__WEBPACK_IMPORTED_MODULE_12__["keys"](plotContainer._downPoints).length > 0) {
                    const xAxis = this.xAxes.getIndex(0);
                    const yAxis = this.yAxes.getIndex(0);
                    if (xAxis) {
                        this._downStartX = xAxis.get("start", 0);
                        this._downEndX = xAxis.get("end", 1);
                    }
                    if (yAxis) {
                        this._downStartY = yAxis.get("start", 0);
                        this._downEndY = yAxis.get("end", 1);
                    }
                }
            }
        }
        if (this.get("panX") || this.get("panY")) {
            if (local.x >= 0 && local.y >= 0 && local.x <= plotContainer.width() && local.y <= this.height()) {
                //this._downPoint = local;
                this._downPoint = { x: event.clientX, y: event.clientY };
                const panX = this.get("panX");
                const panY = this.get("panY");
                if (panX) {
                    this.xAxes.each((axis) => {
                        axis._panStart = axis.get("start");
                        axis._panEnd = axis.get("end");
                    });
                }
                if (panY) {
                    this.yAxes.each((axis) => {
                        axis._panStart = axis.get("start");
                        axis._panEnd = axis.get("end");
                    });
                }
                const eventType = "panstarted";
                if (this.events.isEnabled(eventType)) {
                    this.events.dispatch(eventType, { type: eventType, target: this, originalEvent: event });
                }
            }
        }
    }
    _handleWheelAnimation(animation) {
        if (animation) {
            animation.events.on("stopped", () => {
                this._dispatchWheelAnimation();
            });
        }
        else {
            this._dispatchWheelAnimation();
        }
    }
    _dispatchWheelAnimation() {
        const eventType = "wheelended";
        if (this.events.isEnabled(eventType)) {
            this.events.dispatch(eventType, { type: eventType, target: this });
        }
    }
    _handlePlotUp(event) {
        const downPoint = this._downPoint;
        if (downPoint) {
            if (this.get("panX") || this.get("panY")) {
                let local = this.plotContainer.toLocal(this._root.documentPointToRoot({ x: event.clientX, y: event.clientY }));
                if (local.x == downPoint.x && local.y == downPoint.y) {
                    const eventType = "pancancelled";
                    if (this.events.isEnabled(eventType)) {
                        this.events.dispatch(eventType, { type: eventType, target: this, originalEvent: event });
                    }
                }
                const eventType = "panended";
                if (this.events.isEnabled(eventType)) {
                    this.events.dispatch(eventType, { type: eventType, target: this, originalEvent: event });
                }
            }
        }
        // TODO: handle multitouch
        this._downPoint = undefined;
        this.xAxes.each((xAxis) => {
            xAxis._isPanning = false;
        });
        this.yAxes.each((yAxis) => {
            yAxis._isPanning = false;
        });
    }
    _handlePlotMove(event) {
        const plotContainer = this.plotContainer;
        if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
            const touchEvent = event;
            const pointerId = touchEvent.pointerId;
            if (pointerId) {
                this._movePoints[pointerId] = this._root.documentPointToRoot({ x: event.clientX, y: event.clientY });
                if (_core_util_Object__WEBPACK_IMPORTED_MODULE_12__["keys"](plotContainer._downPoints).length > 1) {
                    this._handlePinch();
                    return;
                }
            }
        }
        let downPoint = this._downPoint;
        if (downPoint) {
            downPoint = plotContainer.toLocal(this._root.documentPointToRoot(downPoint));
            let local = plotContainer.toLocal(this._root.documentPointToRoot({ x: event.clientX, y: event.clientY }));
            const panX = this.get("panX");
            const panY = this.get("panY");
            if (panX) {
                let scrollbarX = this.get("scrollbarX");
                if (scrollbarX) {
                    scrollbarX.events.disableType("rangechanged");
                }
                this.xAxes.each((axis) => {
                    if (axis.get("panX")) {
                        axis._isPanning = true;
                        //const maxDeviation = axis.get("maxDeviation", 0);
                        let panStart = axis._panStart;
                        let panEnd = axis._panEnd;
                        let difference = (panEnd - panStart);
                        let deltaX = difference * (downPoint.x - local.x) / plotContainer.width();
                        if (axis.get("renderer").get("inversed")) {
                            deltaX *= -1;
                        }
                        let start = panStart + deltaX;
                        let end = panEnd + deltaX;
                        if (end - start < 1 + axis.get("maxDeviation", 1) * 2) {
                            axis.set("start", start);
                            axis.set("end", end);
                        }
                    }
                });
                if (scrollbarX) {
                    scrollbarX.events.enableType("rangechanged");
                }
            }
            if (panY) {
                let scrollbarY = this.get("scrollbarY");
                if (scrollbarY) {
                    scrollbarY.events.disableType("rangechanged");
                }
                this.yAxes.each((axis) => {
                    if (axis.get("panY")) {
                        axis._isPanning = true;
                        //const maxDeviation = axis.get("maxDeviation", 0);
                        let panStart = axis._panStart;
                        let panEnd = axis._panEnd;
                        let difference = (panEnd - panStart);
                        let deltaY = difference * (downPoint.y - local.y) / plotContainer.height();
                        if (axis.get("renderer").get("inversed")) {
                            deltaY *= -1;
                        }
                        let start = panStart - deltaY;
                        let end = panEnd - deltaY;
                        if (end - start < 1 + axis.get("maxDeviation", 1) * 2) {
                            axis.set("start", start);
                            axis.set("end", end);
                        }
                    }
                });
                if (scrollbarY) {
                    scrollbarY.events.enableType("rangechanged");
                }
            }
        }
    }
    _handlePinch() {
        const plotContainer = this.plotContainer;
        let i = 0;
        let downPoints = [];
        let movePoints = [];
        _core_util_Object__WEBPACK_IMPORTED_MODULE_12__["each"](plotContainer._downPoints, (k, point) => {
            downPoints[i] = point;
            let movePoint = this._movePoints[k];
            if (movePoint) {
                movePoints[i] = movePoint;
            }
            i++;
        });
        if (downPoints.length > 1 && movePoints.length > 1) {
            const w = plotContainer.width();
            const h = plotContainer.height();
            let downPoint0 = downPoints[0];
            let downPoint1 = downPoints[1];
            let movePoint0 = movePoints[0];
            let movePoint1 = movePoints[1];
            if (downPoint0 && downPoint1 && movePoint0 && movePoint1) {
                movePoint0 = plotContainer.toLocal(movePoint0);
                movePoint1 = plotContainer.toLocal(movePoint1);
                downPoint0 = plotContainer.toLocal(downPoint0);
                downPoint1 = plotContainer.toLocal(downPoint1);
                if (this.get("pinchZoomX")) {
                    const downStartX = this._downStartX;
                    const downEndX = this._downEndX;
                    if (downStartX != null && downEndX != null) {
                        if (downPoint0.x > downPoint1.x) {
                            [downPoint0, downPoint1] = [downPoint1, downPoint0];
                            [movePoint0, movePoint1] = [movePoint1, movePoint0];
                        }
                        let downPos0 = downStartX + (downPoint0.x / w) * (downEndX - downStartX);
                        let downPos1 = downStartX + (downPoint1.x / w) * (downEndX - downStartX);
                        let movePos0 = downStartX + (movePoint0.x / w) * (downEndX - downStartX);
                        let movePos1 = downStartX + (movePoint1.x / w) * (downEndX - downStartX);
                        let initialDistance = Math.max(0.001, downPos1 - downPos0);
                        let currentDistance = Math.max(0.001, movePos1 - movePos0);
                        let d = initialDistance / currentDistance;
                        let s = downStartX * d + downPos0 - movePos0 * d;
                        let e = downEndX * d + downPos1 - movePos1 * d;
                        this.xAxes.each((xAxis) => {
                            let sa = xAxis.fixPosition(s);
                            let ea = xAxis.fixPosition(e);
                            xAxis.zoom(sa, ea, 0);
                        });
                    }
                }
                if (this.get("pinchZoomY")) {
                    const downStartY = this._downStartY;
                    const downEndY = this._downEndY;
                    if (downStartY != null && downEndY != null) {
                        if (downPoint0.y < downPoint1.y) {
                            [downPoint0, downPoint1] = [downPoint1, downPoint0];
                            [movePoint0, movePoint1] = [movePoint1, movePoint0];
                        }
                        let downPos0 = downStartY + (1 - downPoint0.y / h) * (downEndY - downStartY);
                        let downPos1 = downStartY + (1 - downPoint1.y / h) * (downEndY - downStartY);
                        let movePos0 = downStartY + (1 - movePoint0.y / h) * (downEndY - downStartY);
                        let movePos1 = downStartY + (1 - movePoint1.y / h) * (downEndY - downStartY);
                        let initialDistance = Math.max(0.001, downPos1 - downPos0);
                        let currentDistance = Math.max(0.001, movePos1 - movePos0);
                        let d = initialDistance / currentDistance;
                        let s = downStartY * d + downPos0 - movePos0 * d;
                        let e = downEndY * d + downPos1 - movePos1 * d;
                        this.yAxes.each((yAxis) => {
                            let sa = yAxis.fixPosition(s);
                            let ea = yAxis.fixPosition(e);
                            yAxis.zoom(sa, ea, 0);
                        });
                    }
                }
            }
        }
    }
    _handleCursorPosition() {
        const cursor = this.get("cursor");
        if (cursor) {
            const cursorPoint = cursor.getPrivate("point");
            let snapToSeries = cursor.get("snapToSeries");
            if (cursor._downPoint) {
                snapToSeries = undefined;
            }
            if (snapToSeries && cursorPoint) {
                const snapToSeriesBy = cursor.get("snapToSeriesBy");
                const dataItems = [];
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](snapToSeries, (series) => {
                    if (!series.isHidden() && !series.isHiding()) {
                        if (snapToSeriesBy != "x!" && snapToSeriesBy != "y!") {
                            const startIndex = series.startIndex();
                            const endIndex = series.endIndex();
                            for (let i = startIndex; i < endIndex; i++) {
                                const dataItem = series.dataItems[i];
                                if (dataItem && !dataItem.isHidden()) {
                                    dataItems.push(dataItem);
                                }
                            }
                        }
                        else {
                            const tooltipDataItem = series.get("tooltipDataItem");
                            if (tooltipDataItem) {
                                dataItems.push(tooltipDataItem);
                            }
                        }
                    }
                });
                let minDistance = Infinity;
                let closestItem;
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](dataItems, (dataItem) => {
                    const point = dataItem.get("point");
                    if (point) {
                        let distance = 0;
                        if (snapToSeriesBy == "x" || snapToSeriesBy == "x!") {
                            distance = Math.abs(cursorPoint.x - point.x);
                        }
                        else if (snapToSeriesBy == "y" || snapToSeriesBy == "y!") {
                            distance = Math.abs(cursorPoint.y - point.y);
                        }
                        else {
                            distance = Math.hypot(cursorPoint.x - point.x, cursorPoint.y - point.y);
                        }
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestItem = dataItem;
                        }
                    }
                });
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](snapToSeries, (series) => {
                    const tooltip = series.get("tooltip");
                    if (tooltip) {
                        tooltip._setDataItem(undefined);
                    }
                });
                if (closestItem) {
                    let series = closestItem.component;
                    series.showDataItemTooltip(closestItem);
                    const point = closestItem.get("point");
                    if (point) {
                        // removing x and y to solve #72225
                        cursor.handleMove(series.toGlobal({ x: point.x - series.x(), y: point.y - series.y() }), true);
                    }
                }
            }
        }
    }
    _updateCursor() {
        let cursor = this.get("cursor");
        if (cursor) {
            cursor.handleMove();
        }
    }
    _addCursor(cursor) {
        this.plotContainer.children.push(cursor);
    }
    _prepareChildren() {
        super._prepareChildren();
        this.series.each((series) => {
            this._colorize(series);
        });
        if (this.isDirty("wheelX") || this.isDirty("wheelY")) {
            this._handleSetWheel();
        }
        if (this.isDirty("cursor")) {
            const previous = this._prevSettings.cursor;
            const cursor = this.get("cursor");
            if (cursor !== previous) {
                this._disposeProperty("cursor");
                if (previous) {
                    previous.dispose();
                }
                if (cursor) {
                    cursor._setChart(this);
                    this._addCursor(cursor);
                    this._pushPropertyDisposer("cursor", cursor.events.on("selectended", () => {
                        this._handleCursorSelectEnd();
                    }));
                }
                //this.setRaw("cursor", cursor) // to reset previous value
                this._prevSettings.cursor = cursor;
            }
        }
        if (this.isDirty("scrollbarX")) {
            const previous = this._prevSettings.scrollbarX;
            const scrollbarX = this.get("scrollbarX");
            if (scrollbarX !== previous) {
                this._disposeProperty("scrollbarX");
                if (previous) {
                    previous.dispose();
                }
                if (scrollbarX) {
                    if (!scrollbarX.parent) {
                        this.topAxesContainer.children.push(scrollbarX);
                    }
                    this._pushPropertyDisposer("scrollbarX", scrollbarX.events.on("rangechanged", (e) => {
                        this._handleScrollbar(this.xAxes, e.start, e.end, e.grip);
                    }));
                    // Used to populate `ariaLabel` with meaningful values
                    scrollbarX.setPrivate("positionTextFunction", (position) => {
                        const axis = this.xAxes.getIndex(0);
                        return axis ? axis.getTooltipText(position) || "" : "";
                    });
                }
                this._prevSettings.scrollbarX = scrollbarX;
            }
        }
        if (this.isDirty("scrollbarY")) {
            const previous = this._prevSettings.scrollbarY;
            const scrollbarY = this.get("scrollbarY");
            if (scrollbarY !== previous) {
                this._disposeProperty("scrollbarY");
                if (previous) {
                    previous.dispose();
                }
                if (scrollbarY) {
                    if (!scrollbarY.parent) {
                        this.rightAxesContainer.children.push(scrollbarY);
                    }
                    this._pushPropertyDisposer("scrollbarY", scrollbarY.events.on("rangechanged", (e) => {
                        this._handleScrollbar(this.yAxes, e.start, e.end, e.grip);
                    }));
                    // Used to populate `ariaLabel` with meaningful values
                    scrollbarY.setPrivate("positionTextFunction", (position) => {
                        const axis = this.yAxes.getIndex(0);
                        return axis ? axis.getTooltipText(position) || "" : "";
                    });
                }
                this._prevSettings.scrollbarY = scrollbarY;
            }
        }
        this._handleZoomOut();
    }
    _processSeries(series) {
        super._processSeries(series);
        this._colorize(series);
    }
    _colorize(series) {
        const colorSet = this.get("colors");
        if (colorSet) {
            if (series.get("fill") == null) {
                const color = colorSet.next();
                series._setSoft("stroke", color);
                series._setSoft("fill", color);
            }
        }
    }
    _handleCursorSelectEnd() {
        const cursor = this.get("cursor");
        const behavior = cursor.get("behavior");
        const downPositionX = cursor.getPrivate("downPositionX", 0);
        const downPositionY = cursor.getPrivate("downPositionY", 0);
        const positionX = cursor.getPrivate("positionX", 0.5);
        const positionY = cursor.getPrivate("positionY", 0.5);
        this.xAxes.each((axis) => {
            if (behavior === "zoomX" || behavior === "zoomXY") {
                let position0 = axis.toAxisPosition(downPositionX);
                let position1 = axis.toAxisPosition(positionX);
                axis.zoom(position0, position1);
            }
            axis.setPrivate("updateScrollbar", true);
        });
        this.yAxes.each((axis) => {
            if (behavior === "zoomY" || behavior === "zoomXY") {
                let position0 = axis.toAxisPosition(downPositionY);
                let position1 = axis.toAxisPosition(positionY);
                axis.zoom(position0, position1);
            }
            axis.setPrivate("updateScrollbar", true);
        });
    }
    _handleScrollbar(axes, start, end, priority) {
        axes.each((axis) => {
            let axisStart = axis.fixPosition(start);
            let axisEnd = axis.fixPosition(end);
            let zoomAnimation = axis.zoom(axisStart, axisEnd, undefined, priority);
            const updateScrollbar = "updateScrollbar";
            axis.setPrivateRaw(updateScrollbar, false);
            if (zoomAnimation) {
                zoomAnimation.events.on("stopped", () => {
                    axis.setPrivateRaw(updateScrollbar, true);
                });
            }
            else {
                axis.setPrivateRaw(updateScrollbar, true);
            }
        });
    }
    _processAxis(axes, container) {
        return axes.events.onAll((change) => {
            if (change.type === "clear") {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](change.oldValues, (axis) => {
                    this._removeAxis(axis);
                });
            }
            else if (change.type === "push") {
                container.children.push(change.newValue);
                change.newValue.processChart(this);
            }
            else if (change.type === "setIndex") {
                container.children.setIndex(change.index, change.newValue);
                change.newValue.processChart(this);
            }
            else if (change.type === "insertIndex") {
                container.children.insertIndex(change.index, change.newValue);
                change.newValue.processChart(this);
            }
            else if (change.type === "removeIndex") {
                this._removeAxis(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                container.children.moveValue(change.value, change.newIndex);
                change.value.processChart(this);
            }
            else {
                throw new Error("Unknown IListEvent type");
            }
        });
    }
    _removeAxis(axis) {
        if (!axis.isDisposed()) {
            const axisParent = axis.parent;
            if (axisParent) {
                axisParent.children.removeValue(axis);
            }
            const gridContainer = axis.gridContainer;
            const gridParent = gridContainer.parent;
            if (gridParent) {
                gridParent.children.removeValue(gridContainer);
            }
            const topGridContainer = axis.topGridContainer;
            const topGridParent = topGridContainer.parent;
            if (topGridParent) {
                topGridParent.children.removeValue(topGridContainer);
            }
        }
    }
    _updateChartLayout() {
        const left = this.leftAxesContainer.width();
        const right = this.rightAxesContainer.width();
        const bottomAxesContainer = this.bottomAxesContainer;
        bottomAxesContainer.set("paddingLeft", left);
        bottomAxesContainer.set("paddingRight", right);
        const topAxesContainer = this.topAxesContainer;
        topAxesContainer.set("paddingLeft", left);
        topAxesContainer.set("paddingRight", right);
    }
    /**
     * @ignore
     */
    processAxis(_axis) { }
    ;
    _handleAxisSelection(axis, force) {
        let start = axis.fixPosition(axis.get("start", 0));
        let end = axis.fixPosition(axis.get("end", 1));
        if (start > end) {
            [start, end] = [end, start];
        }
        if (this.xAxes.indexOf(axis) != -1) {
            if (force || axis.getPrivate("updateScrollbar")) {
                let scrollbarX = this.get("scrollbarX");
                if (scrollbarX && (!scrollbarX.getPrivate("isBusy") || force)) {
                    scrollbarX.setRaw("start", start);
                    scrollbarX.setRaw("end", end);
                    scrollbarX.updateGrips();
                }
            }
        }
        else if (this.yAxes.indexOf(axis) != -1) {
            if (force || axis.getPrivate("updateScrollbar")) {
                let scrollbarY = this.get("scrollbarY");
                if (scrollbarY && (!scrollbarY.getPrivate("isBusy") || force)) {
                    scrollbarY.setRaw("start", start);
                    scrollbarY.setRaw("end", end);
                    scrollbarY.updateGrips();
                }
            }
        }
        this._handleZoomOut();
    }
    _handleZoomOut() {
        let zoomOutButton = this.zoomOutButton;
        if (zoomOutButton && zoomOutButton.parent) {
            let visible = false;
            this.xAxes.each((axis) => {
                if (axis.get("start") != 0 || axis.get("end") != 1) {
                    visible = true;
                }
            });
            this.yAxes.each((axis) => {
                if (axis.get("start") != 0 || axis.get("end") != 1) {
                    visible = true;
                }
            });
            if (visible) {
                if (zoomOutButton.isHidden()) {
                    zoomOutButton.show();
                }
            }
            else {
                zoomOutButton.hide();
            }
        }
    }
    /**
     * Checks if point is within plot area.
     *
     * @param   point  Reference point
     * @return         Is within plot area?
     */
    inPlot(point) {
        const plotContainer = this.plotContainer;
        const otherCharts = this.getPrivate("otherCharts", this._otherCharts);
        const global = plotContainer.toGlobal(point);
        if (point.x >= -0.5 && point.y >= -0.5 && point.x <= plotContainer.width() + 0.5 && point.y <= plotContainer.height() + 0.5) {
            return true;
        }
        if (otherCharts) {
            for (let i = otherCharts.length - 1; i >= 0; i--) {
                const chart = otherCharts[i];
                if (chart != this) {
                    const chartPlotContainer = chart.plotContainer;
                    const documentPoint = this._root.rootPointToDocument(global);
                    const chartRoot = chart._root.documentPointToRoot(documentPoint);
                    const local = chartPlotContainer.toLocal(chartRoot);
                    if (local.x >= -0.1 && local.y >= -0.1 && local.x <= chartPlotContainer.width() + 0.1 && local.y <= chartPlotContainer.height() + 0.1) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * @ignore
     */
    arrangeTooltips() {
        const plotContainer = this.plotContainer;
        const w = plotContainer.width();
        const h = plotContainer.height();
        const hh = this.height();
        let plotT = plotContainer._display.toGlobal({ x: 0, y: 0 });
        let plotB = plotContainer._display.toGlobal({ x: w, y: h });
        const tooltips = [];
        let sum = 0;
        let minDistance = Infinity;
        let movePoint = this._movePoint;
        let maxTooltipDistance = this.get("maxTooltipDistance");
        let maxTooltipDistanceBy = this.get("maxTooltipDistanceBy", "xy");
        let closest;
        let closestPoint;
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_10__["isNumber"](maxTooltipDistance)) {
            this.series.each((series) => {
                if (!series.isHidden()) {
                    const tooltip = series.get("tooltip");
                    if (tooltip) {
                        let point = tooltip.get("pointTo");
                        if (point) {
                            let distance = Math.hypot(movePoint.x - point.x, movePoint.y - point.y);
                            if (maxTooltipDistanceBy == "x") {
                                distance = Math.abs(movePoint.x - point.x);
                            }
                            else if (maxTooltipDistanceBy == "y") {
                                distance = Math.abs(movePoint.y - point.y);
                            }
                            if (distance < minDistance) {
                                minDistance = distance;
                                closest = series;
                                closestPoint = point;
                            }
                        }
                    }
                }
            });
        }
        const tooltipSeries = [];
        this.series.each((series) => {
            const tooltip = series.get("tooltip");
            if (tooltip) {
                let hidden = false;
                let point = tooltip.get("pointTo");
                if (point) {
                    if (maxTooltipDistance >= 0) {
                        let point = tooltip.get("pointTo");
                        if (point) {
                            if (series != closest) {
                                let distance = Math.hypot(closestPoint.x - point.x, closestPoint.y - point.y);
                                if (maxTooltipDistanceBy == "x") {
                                    distance = Math.abs(closestPoint.x - point.x);
                                }
                                else if (maxTooltipDistanceBy == "y") {
                                    distance = Math.abs(closestPoint.y - point.y);
                                }
                                if (distance > maxTooltipDistance) {
                                    hidden = true;
                                }
                            }
                        }
                    }
                    else if (maxTooltipDistance == -1) {
                        if (series != closest) {
                            hidden = true;
                        }
                    }
                    if (!this.inPlot(this._tooltipToLocal(point)) || !tooltip.dataItem) {
                        hidden = true;
                    }
                    else {
                        if (!hidden) {
                            sum += point.y;
                        }
                    }
                    if (hidden || series.isHidden() || series.isHiding()) {
                        tooltip.hide(0);
                    }
                    else {
                        tooltip.show();
                        tooltips.push(tooltip);
                        tooltipSeries.push(series);
                    }
                }
            }
        });
        this.setPrivate("tooltipSeries", tooltipSeries);
        if (this.get("arrangeTooltips")) {
            const tooltipContainer = this._root.tooltipContainer;
            const count = tooltips.length;
            const average = sum / count;
            if (average > h / 2 + plotT.y) {
                tooltips.sort((a, b) => _core_util_Order__WEBPACK_IMPORTED_MODULE_11__["compareNumber"](b.get("pointTo").y, a.get("pointTo").y));
                let prevY = plotB.y;
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](tooltips, (tooltip) => {
                    let height = tooltip.height();
                    let centerY = tooltip.get("centerY");
                    if (centerY instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["Percent"]) {
                        height *= centerY.value;
                    }
                    height += tooltip.get("marginBottom", 0);
                    tooltip.set("bounds", { left: plotT.x, top: plotT.y, right: plotB.x, bottom: prevY });
                    tooltip.setPrivate("customData", { left: plotT.x, top: plotT.y, right: plotB.x, bottom: prevY });
                    prevY = Math.min(prevY - height, tooltip._fy - height);
                    if (tooltip.parent == tooltipContainer) {
                        tooltipContainer.children.moveValue(tooltip, 0);
                    }
                });
                if (prevY < 0) {
                    tooltips.reverse();
                    let prevBottom = prevY;
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](tooltips, (tooltip) => {
                        let bounds = tooltip.get("bounds");
                        if (bounds) {
                            let top = bounds.top - prevY;
                            let bottom = bounds.bottom - prevY;
                            if (top < prevBottom) {
                                top = prevBottom;
                                bottom = top + tooltip.height();
                            }
                            tooltip.set("bounds", { left: bounds.left, top: top, right: bounds.right, bottom: bottom });
                            prevBottom = bounds.bottom - prevY + tooltip.get("marginBottom", 0);
                        }
                    });
                }
            }
            else {
                tooltips.reverse();
                tooltips.sort((a, b) => _core_util_Order__WEBPACK_IMPORTED_MODULE_11__["compareNumber"](a.get("pointTo").y, b.get("pointTo").y));
                let prevY = 0;
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](tooltips, (tooltip) => {
                    let height = tooltip.height();
                    let centerY = tooltip.get("centerY");
                    if (centerY instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["Percent"]) {
                        height *= centerY.value;
                    }
                    height += tooltip.get("marginBottom", 0);
                    tooltip.set("bounds", { left: plotT.x, top: prevY, right: plotB.x, bottom: Math.max(plotT.y + hh, prevY + height) });
                    if (tooltip.parent == tooltipContainer) {
                        tooltipContainer.children.moveValue(tooltip, 0);
                    }
                    prevY = Math.max(prevY + height, tooltip._fy + height);
                });
                if (prevY > hh) {
                    tooltips.reverse();
                    let prevBottom = hh;
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](tooltips, (tooltip) => {
                        let bounds = tooltip.get("bounds");
                        if (bounds) {
                            let top = bounds.top - (hh - prevY);
                            let bottom = bounds.bottom - (hh - prevY);
                            if (bottom > prevBottom) {
                                bottom = prevBottom;
                                top = bottom - tooltip.height();
                            }
                            tooltip.set("bounds", { left: bounds.left, top: top, right: bounds.right, bottom: bottom });
                            prevBottom = bottom - tooltip.height() - tooltip.get("marginBottom", 0);
                        }
                    });
                }
            }
        }
    }
    _tooltipToLocal(point) {
        return this.plotContainer.toLocal(point);
    }
    /**
     * Fully zooms out the chart.
     */
    zoomOut() {
        this.xAxes.each((axis) => {
            axis.setPrivate("updateScrollbar", true);
            axis.zoom(0, 1);
        });
        this.yAxes.each((axis) => {
            axis.setPrivate("updateScrollbar", true);
            axis.zoom(0, 1);
        });
    }
}
Object.defineProperty(XYChart, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "XYChart"
});
Object.defineProperty(XYChart, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_SerialChart__WEBPACK_IMPORTED_MODULE_3__["SerialChart"].classNames.concat([XYChart.className])
});
//# sourceMappingURL=XYChart.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js ***!
  \*************************************************************************************/
/*! exports provided: XYChartDefaultTheme */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XYChartDefaultTheme", function() { return XYChartDefaultTheme; });
/* harmony import */ var _core_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/Theme */ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_ColorSet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/ColorSet */ "./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js");
/* harmony import */ var _themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../themes/DefaultTheme */ "./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js");
/* harmony import */ var _core_util_Time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Time */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _core_util_Object__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");









/**
 * @ignore
 */
class XYChartDefaultTheme extends _core_Theme__WEBPACK_IMPORTED_MODULE_0__["Theme"] {
    setupDefaultRules() {
        super.setupDefaultRules();
        const ic = this._root.interfaceColors;
        const language = this._root.language;
        const r = this.rule.bind(this);
        /**
         * ========================================================================
         * charts/xy
         * ========================================================================
         */
        r("XYChart").setAll({
            colors: _core_util_ColorSet__WEBPACK_IMPORTED_MODULE_2__["ColorSet"].new(this._root, {}),
            paddingLeft: 20,
            paddingRight: 20,
            paddingTop: 16,
            paddingBottom: 16,
            panX: false,
            panY: false,
            wheelStep: 0.25,
            arrangeTooltips: true,
            pinchZoomX: false,
            pinchZoomY: false
        });
        r("XYSeries").setAll({
            legendLabelText: "{name}"
        });
        /**
         * ------------------------------------------------------------------------
         * charts/xy: XYChartScrollbar
         * ------------------------------------------------------------------------
         */
        r("XYChart", ["scrollbar", "chart"]).setAll({
            paddingBottom: 0,
            paddingLeft: 0,
            paddingTop: 0,
            paddingRight: 0,
            colors: _core_util_ColorSet__WEBPACK_IMPORTED_MODULE_2__["ColorSet"].new(this._root, {
                saturation: 0
            })
        });
        {
            const rule = r("Graphics", ["scrollbar", "overlay"]);
            rule.setAll({
                fillOpacity: 0.5
            });
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "fill", ic, "background");
        }
        // Class: RoundedRectangle
        r("RoundedRectangle", ["xy", "scrollbar", "thumb"]).setAll({
            cornerRadiusTR: 0,
            cornerRadiusTL: 0,
            cornerRadiusBR: 0,
            cornerRadiusBL: 0,
            fillOpacity: 0,
            focusable: true
        });
        r("RoundedRectangle", ["xy", "scrollbar", "thumb"]).states.create("hover", { fillOpacity: 0.4 });
        r("RoundedRectangle", ["xy", "scrollbar", "chart", "background"]).setAll({
            cornerRadiusTL: 0,
            cornerRadiusBL: 0,
            cornerRadiusTR: 0,
            cornerRadiusBR: 0
        });
        r("RoundedRectangle", ["xy", "scrollbar", "chart", "background", "resize", "button"]).setAll({
            cornerRadiusBL: 40,
            cornerRadiusBR: 40,
            cornerRadiusTL: 40,
            cornerRadiusTR: 40
        });
        r("AxisRendererX", ["xy", "chart", "scrollbar"]).setAll({
            strokeOpacity: 0,
            inside: true
        });
        r("AxisRendererY", ["xy", "chart", "scrollbar"]).setAll({
            strokeOpacity: 0,
            inside: true,
            minGridDistance: 5
        });
        r("AxisLabel", ["xy", "scrollbar", "x"]).setAll({
            opacity: 0.5,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            minPosition: 0.01,
            maxPosition: 0.99,
            fontSize: "0.8em"
        });
        r("AxisLabel", ["category"]).setAll({
            text: "{category}",
            populateText: true
        });
        r("AxisLabel", ["x"]).setAll({
            centerY: 0
        });
        r("AxisLabel", ["x", "inside"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]
        });
        r("AxisLabel", ["x", "inside", "opposite"]).setAll({
            centerY: 0
        });
        r("AxisLabel", ["x", "opposite"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]
        });
        r("AxisLabel", ["y"]).setAll({
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]
        });
        r("AxisLabel", ["y", "inside"]).setAll({
            centerX: 0
        });
        r("AxisLabel", ["y", "inside", "opposite"]).setAll({
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]
        });
        r("AxisLabel", ["y", "opposite"]).setAll({
            centerX: 0
        });
        r("AxisLabel", ["xy", "scrollbar", "y"]).setAll({
            visible: false
        });
        // Class: Grid
        r("Grid", ["xy", "scrollbar", "y"]).setAll({
            visible: false
        });
        // Class: Grid
        r("Grid", ["xy", "scrollbar", "x"]).setAll({
            opacity: 0.5
        });
        /**
         * ------------------------------------------------------------------------
         * charts/xy: Cursor
         * ------------------------------------------------------------------------
         */
        r("XYCursor").setAll({
            behavior: "none",
            layer: 30,
            exportable: false,
            snapToSeriesBy: "xy",
            moveThreshold: 1
        });
        {
            const rule = r("Grid", ["cursor", "x"]);
            rule.setAll({
                strokeOpacity: 0.8,
                strokeDasharray: [2, 2],
                ariaLabel: language.translate("Use left and right arrows to move selection")
            });
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "alternativeBackground");
        }
        {
            const rule = r("Grid", ["cursor", "y"]);
            rule.setAll({
                strokeOpacity: 0.8,
                strokeDasharray: [2, 2],
                ariaLabel: language.translate("Use up and down arrows to move selection")
            });
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "alternativeBackground");
        }
        {
            const rule = r("Graphics", ["cursor", "selection"]);
            rule.setAll({
                fillOpacity: 0.15,
            });
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "fill", ic, "alternativeBackground");
        }
        /**
         * ------------------------------------------------------------------------
         * charts/xy: Axes
         * ------------------------------------------------------------------------
         */
        r("Axis").setAll({
            start: 0,
            end: 1,
            minZoomCount: 1,
            maxZoomCount: Infinity,
            maxZoomFactor: 1000,
            maxDeviation: 0.1,
            snapTooltip: true,
            tooltipLocation: 0.5,
            panX: true,
            panY: true,
            zoomX: true,
            zoomY: true,
            fixAxisSize: true
        });
        r("AxisLabel").setAll({
            location: 0.5,
            multiLocation: 0,
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            paddingTop: 3,
            paddingBottom: 3,
            paddingLeft: 5,
            paddingRight: 5
        });
        // The following is deprecated following text measuring updates in 5.0.5
        // r("AxisLabel", ["y"]).setAll({
        // 	textAlign: "right"
        // });
        // r("AxisLabel", ["y", "opposite"]).setAll({
        // 	textAlign: "left"
        // });
        r("Container", ["axis", "header"]).setAll({
            layer: 30
        });
        r("Rectangle", ["axis", "header", "background"]).setAll({
            crisp: true
        });
        {
            const rule = r("AxisRenderer");
            rule.setAll({
                crisp: true,
                strokeOpacity: 0
            });
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "grid");
        }
        r("AxisRendererX").setAll({
            minGridDistance: 120,
            opposite: false,
            inversed: false,
            cellStartLocation: 0,
            cellEndLocation: 1,
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]
        });
        r("AxisRendererY").setAll({
            minGridDistance: 40,
            opposite: false,
            inversed: false,
            cellStartLocation: 0,
            cellEndLocation: 1,
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]
        });
        {
            const rule = r("Rectangle", ["axis", "thumb"]);
            rule.setAll({
                fillOpacity: 0
            });
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "fill", ic, "alternativeBackground");
            rule.states.create("hover", { fillOpacity: 0.1 });
        }
        r("Rectangle", ["axis", "thumb", "x"]).setAll({
            cursorOverStyle: "ew-resize"
        });
        r("Rectangle", ["axis", "thumb", "y"]).setAll({
            cursorOverStyle: "ns-resize"
        });
        {
            const rule = r("Grid");
            rule.setAll({
                location: 0,
                strokeOpacity: 0.15,
                crisp: true
            });
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "grid");
        }
        r("Grid", ["base"]).setAll({
            strokeOpacity: 0.3
        });
        {
            const rule = r("Graphics", ["axis", "fill"]);
            rule.setAll({
                visible: false,
                isMeasured: false,
                position: "absolute",
                fillOpacity: 0.05,
            });
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "fill", ic, "alternativeBackground");
        }
        r("Graphics", ["axis", "fill", "range"]).setAll({
            isMeasured: true
        });
        // hides all elements of series axis range
        r("Graphics", ["series", "fill", "range"]).setAll({
            visible: false,
            isMeasured: true
        });
        r("Grid", ["series", "range"]).setAll({
            visible: false
        });
        r("AxisTick", ["series", "range"]).setAll({
            visible: false
        });
        r("AxisLabel", ["series", "range"]).setAll({
            visible: false
        });
        {
            const rule = r("AxisTick");
            rule.setAll({
                location: 0.5,
                multiLocation: 0,
                strokeOpacity: 1,
                isMeasured: false,
                position: "absolute",
                visible: false
            });
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "grid");
        }
        r("CategoryAxis").setAll({
            startLocation: 0,
            endLocation: 1,
            fillRule: (dataItem, index) => {
                const axisFill = dataItem.get("axisFill");
                if (axisFill) {
                    if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](index) || index % 2 == 0) {
                        axisFill.setPrivate("visible", true);
                    }
                    else {
                        axisFill.setPrivate("visible", false);
                    }
                }
            }
        });
        const gridIntervals = [
            { timeUnit: "millisecond", count: 1 },
            { timeUnit: "millisecond", count: 5 },
            { timeUnit: "millisecond", count: 10 },
            { timeUnit: "millisecond", count: 50 },
            { timeUnit: "millisecond", count: 100 },
            { timeUnit: "millisecond", count: 500 },
            { timeUnit: "second", count: 1 },
            { timeUnit: "second", count: 5 },
            { timeUnit: "second", count: 10 },
            { timeUnit: "second", count: 30 },
            { timeUnit: "minute", count: 1 },
            { timeUnit: "minute", count: 5 },
            { timeUnit: "minute", count: 10 },
            { timeUnit: "minute", count: 15 },
            { timeUnit: "minute", count: 30 },
            { timeUnit: "hour", count: 1 },
            { timeUnit: "hour", count: 3 },
            { timeUnit: "hour", count: 6 },
            { timeUnit: "hour", count: 12 },
            { timeUnit: "day", count: 1 },
            { timeUnit: "day", count: 2 },
            { timeUnit: "day", count: 3 },
            { timeUnit: "day", count: 4 },
            { timeUnit: "day", count: 5 },
            { timeUnit: "week", count: 1 },
            { timeUnit: "month", count: 1 },
            { timeUnit: "month", count: 2 },
            { timeUnit: "month", count: 3 },
            { timeUnit: "month", count: 6 },
            { timeUnit: "year", count: 1 },
            { timeUnit: "year", count: 2 },
            { timeUnit: "year", count: 5 },
            { timeUnit: "year", count: 10 },
            { timeUnit: "year", count: 50 },
            { timeUnit: "year", count: 100 },
            { timeUnit: "year", count: 200 },
            { timeUnit: "year", count: 500 },
            { timeUnit: "year", count: 1000 },
            { timeUnit: "year", count: 2000 },
            { timeUnit: "year", count: 5000 },
            { timeUnit: "year", count: 10000 },
            { timeUnit: "year", count: 100000 }
        ];
        const dateFormats = {
            "millisecond": language.translate("_date_millisecond"),
            "second": language.translate("_date_second"),
            "minute": language.translate("_date_minute"),
            "hour": language.translate("_date_hour"),
            "day": language.translate("_date_day"),
            "week": language.translate("_date_day"),
            "month": language.translate("_date_month"),
            "year": language.translate("_date_year")
        };
        const periodChangeDateFormats = {
            "millisecond": language.translate("_date_millisecond"),
            "second": language.translate("_date_second"),
            "minute": language.translate("_date_minute"),
            "hour": language.translate("_date_day"),
            "day": language.translate("_date_day"),
            "week": language.translate("_date_day"),
            "month": language.translate("_date_month") + " " + language.translate("_date_year"),
            "year": language.translate("_date_year")
        };
        const tooltipDateFormats = {
            "millisecond": language.translate("_date_millisecond_full"),
            "second": language.translate("_date_second_full"),
            "minute": language.translate("_date_minute_full"),
            "hour": language.translate("_date_hour_full"),
            "day": language.translate("_date_day_full"),
            "week": language.translate("_date_week_full"),
            "month": language.translate("_date_month_full"),
            "year": language.translate("_date_year")
        };
        r("CategoryDateAxis").setAll({
            markUnitChange: true,
            gridIntervals: _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["copy"](gridIntervals),
            dateFormats: _core_util_Object__WEBPACK_IMPORTED_MODULE_7__["copy"](dateFormats),
            periodChangeDateFormats: _core_util_Object__WEBPACK_IMPORTED_MODULE_7__["copy"](periodChangeDateFormats)
        });
        r("DateAxis").setAll({
            maxZoomFactor: null,
            strictMinMax: true,
            startLocation: 0,
            endLocation: 1,
            markUnitChange: true,
            groupData: false,
            groupCount: 500,
            gridIntervals: _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["copy"](gridIntervals),
            dateFormats: _core_util_Object__WEBPACK_IMPORTED_MODULE_7__["copy"](dateFormats),
            periodChangeDateFormats: _core_util_Object__WEBPACK_IMPORTED_MODULE_7__["copy"](periodChangeDateFormats),
            tooltipDateFormats: tooltipDateFormats,
            groupIntervals: [
                { timeUnit: "millisecond", count: 1 },
                { timeUnit: "millisecond", count: 10 },
                { timeUnit: "millisecond", count: 100 },
                { timeUnit: "second", count: 1 },
                { timeUnit: "second", count: 10 },
                { timeUnit: "minute", count: 1 },
                { timeUnit: "minute", count: 10 },
                { timeUnit: "hour", count: 1 },
                { timeUnit: "day", count: 1 },
                { timeUnit: "week", count: 1 },
                { timeUnit: "month", count: 1 },
                { timeUnit: "year", count: 1 }
            ],
            fillRule: (dataItem) => {
                const axisFill = dataItem.get("axisFill");
                if (axisFill) {
                    const axis = dataItem.component;
                    const value = dataItem.get("value");
                    const endValue = dataItem.get("endValue");
                    const intervalDuration = axis.intervalDuration();
                    const baseInterval = axis.getPrivate("baseInterval");
                    const gridInterval = axis.getPrivate("gridInterval", baseInterval);
                    let min = axis.getPrivate("min", 0);
                    min = _core_util_Time__WEBPACK_IMPORTED_MODULE_4__["round"](new Date(min), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();
                    if (value != null && endValue != null) {
                        const val = Math.round(Math.round((value - min) / intervalDuration)) / 2;
                        if (val == Math.round(val)) {
                            axisFill.setPrivate("visible", true);
                        }
                        else {
                            axisFill.setPrivate("visible", false);
                        }
                    }
                }
            }
        });
        r("GaplessDateAxis").setAll({
            fillRule: (dataItem) => {
                const axisFill = dataItem.get("axisFill");
                if (axisFill) {
                    const index = dataItem.get("index");
                    let visible = false;
                    if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](index) || index % 2 == 0) {
                        visible = true;
                    }
                    axisFill.setPrivate("visible", visible);
                }
            }
        });
        r("ValueAxis").setAll({
            baseValue: 0,
            logarithmic: false,
            strictMinMax: false,
            autoZoom: true,
            fillRule: (dataItem) => {
                const axisFill = dataItem.get("axisFill");
                if (axisFill) {
                    const axis = dataItem.component;
                    const value = dataItem.get("value");
                    const step = axis.getPrivate("step");
                    if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](value) && _core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](step)) {
                        if (_core_util_Math__WEBPACK_IMPORTED_MODULE_6__["round"](value / step / 2, 5) == Math.round(value / step / 2)) {
                            axisFill.setPrivate("visible", false);
                        }
                        else {
                            axisFill.setPrivate("visible", true);
                        }
                    }
                }
            }
        });
        r("DurationAxis").setAll({
            baseUnit: "second"
        });
        /**
         * ------------------------------------------------------------------------
         * charts/xy: Series
         * ------------------------------------------------------------------------
         */
        r("XYSeries").setAll({
            maskBullets: true,
            stackToNegative: true,
            locationX: 0.5,
            locationY: 0.5,
            snapTooltip: false,
            openValueXGrouped: "open",
            openValueYGrouped: "open",
            valueXGrouped: "close",
            valueYGrouped: "close",
            seriesTooltipTarget: "series"
        });
        r("BaseColumnSeries").setAll({
            adjustBulletPosition: true
        });
        r("ColumnSeries").setAll({
            clustered: true
        });
        r("RoundedRectangle", ["series", "column"]).setAll({
            position: "absolute",
            isMeasured: false,
            width: Object(_core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["percent"])(70),
            height: Object(_core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["percent"])(70),
            strokeWidth: 1,
            strokeOpacity: 1,
            cornerRadiusBL: 0,
            cornerRadiusTL: 0,
            cornerRadiusBR: 0,
            cornerRadiusTR: 0,
            fillOpacity: 1,
            role: "figure"
        });
        r("LineSeries").setAll({
            connect: true,
            autoGapCount: 1.1,
            stackToNegative: false
        });
        r("Graphics", ["series", "stroke"]).setAll({
            position: "absolute",
            strokeWidth: 1,
            strokeOpacity: 1,
            isMeasured: false
        });
        r("Graphics", ["series", "fill"]).setAll({
            visible: false,
            fillOpacity: 0,
            position: "absolute",
            strokeWidth: 0,
            strokeOpacity: 0,
            isMeasured: false
        });
        r("Graphics", ["line", "series", "legend", "marker", "stroke"]).setAll({
            draw: (display, sprite) => {
                const parent = sprite.parent;
                if (parent) {
                    const h = parent.height();
                    const w = parent.width();
                    display.moveTo(0, h / 2);
                    display.lineTo(w, h / 2);
                }
            }
        });
        {
            const rule = r("Graphics", ["line", "series", "legend", "marker", "stroke"]).states.create("disabled", {});
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "disabled");
        }
        r("Graphics", ["line", "series", "legend", "marker", "fill"]).setAll({
            draw: (display, sprite) => {
                const parent = sprite.parent;
                if (parent) {
                    const h = parent.height();
                    const w = parent.width();
                    display.moveTo(0, 0);
                    display.lineTo(w, 0);
                    display.lineTo(w, h);
                    display.lineTo(0, h);
                    display.lineTo(0, 0);
                }
            }
        });
        {
            const rule = r("Graphics", ["line", "series", "legend", "marker", "fill"]).states.create("disabled", {});
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "disabled");
        }
        r("SmoothedXYLineSeries").setAll({
            tension: 0.5
        });
        r("SmoothedXLineSeries").setAll({
            tension: 0.5
        });
        r("SmoothedYLineSeries").setAll({
            tension: 0.5
        });
        r("Candlestick").setAll({
            position: "absolute",
            isMeasured: false,
            width: Object(_core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["percent"])(50),
            height: Object(_core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["percent"])(50),
            strokeWidth: 1,
            strokeOpacity: 1,
            cornerRadiusBL: 0,
            cornerRadiusTL: 0,
            cornerRadiusBR: 0,
            cornerRadiusTR: 0,
            fillOpacity: 1,
            role: "figure"
        });
        r("OHLC").setAll({
            width: Object(_core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["percent"])(80),
            height: Object(_core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["percent"])(80)
        });
        r("CandlestickSeries").setAll({
            lowValueXGrouped: "low",
            lowValueYGrouped: "low",
            highValueXGrouped: "high",
            highValueYGrouped: "high",
            openValueXGrouped: "open",
            openValueYGrouped: "open",
            valueXGrouped: "close",
            valueYGrouped: "close"
        });
        // These rules can be used for regular columns, too
        {
            const rule = r("Rectangle", ["column", "autocolor"]).states.create("riseFromOpen", {});
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "fill", ic, "positive");
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "positive");
        }
        {
            const rule = r("Rectangle", ["column", "autocolor"]).states.create("dropFromOpen", {});
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "fill", ic, "negative");
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "negative");
        }
        // Hollow
        r("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromOpen", { fillOpacity: 0 });
        r("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromOpen", { fillOpacity: 1 });
        {
            const rule = r("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromPrevious", {});
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "fill", ic, "positive");
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "positive");
        }
        {
            const rule = r("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromPrevious", {});
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "fill", ic, "negative");
            Object(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_3__["setColor"])(rule, "stroke", ic, "negative");
        }
    }
}
//# sourceMappingURL=XYChartDefaultTheme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartScrollbar.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartScrollbar.js ***!
  \**********************************************************************************/
/*! exports provided: XYChartScrollbar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XYChartScrollbar", function() { return XYChartScrollbar; });
/* harmony import */ var _core_render_Scrollbar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/render/Scrollbar */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Scrollbar.js");
/* harmony import */ var _XYChart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XYChart */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");




/**
 * Creates a scrollbar with chart preview in it.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/scrollbars/#Scrollbar_with_chart_preview} for more info
 * @important
 */
class XYChartScrollbar extends _core_render_Scrollbar__WEBPACK_IMPORTED_MODULE_0__["Scrollbar"] {
    constructor() {
        super(...arguments);
        /**
         * An instance of an [[XYChart]] that is used to plot chart preview in
         * scrollbar.
         */
        Object.defineProperty(this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_XYChart__WEBPACK_IMPORTED_MODULE_1__["XYChart"].new(this._root, {
                themeTags: ["chart"],
                interactive: false,
                interactiveChildren: false,
                panX: false,
                panY: false,
                wheelX: "none",
                wheelY: "none"
            }))
        });
        /**
         * A graphics element that is displayed over inactive portion of the
         * scrollbarpreview, to dim it down.
         */
        Object.defineProperty(this, "overlay", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_2__["Graphics"].new(this._root, {
                themeTags: ["overlay"],
                interactive: false
            }))
        });
    }
    _afterNew() {
        this._addOrientationClass();
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__["mergeTags"](this._settings.themeTags, ["scrollbar", "xy", "chart", this._settings.orientation]);
        const children = this.children;
        children.moveValue(this.thumb);
        children.moveValue(this.startGrip);
        children.moveValue(this.endGrip);
        this.thumb.set("opacity", 0);
        this.thumb.states.create("hover", { opacity: 0.2 });
        const plotContainer = this.chart.plotContainer;
        plotContainer.set("interactive", false);
        plotContainer.remove("background");
        plotContainer.children.removeValue(this.chart.zoomOutButton);
        super._afterNew();
    }
    _updateThumb() {
        super._updateThumb();
        this.overlay.set("draw", (display) => {
            const startGrip = this.startGrip;
            const endGrip = this.endGrip;
            let x0 = startGrip.x();
            let y0 = startGrip.y();
            let x1 = endGrip.x();
            let y1 = endGrip.y();
            const h = this.height();
            const w = this.width();
            if (x0 > x1) {
                [x0, x1] = [x1, x0];
            }
            if (y0 > y1) {
                [y0, y1] = [y1, y0];
            }
            if (this.get("orientation") === "horizontal") {
                display.moveTo(0, 0);
                display.lineTo(x0, 0);
                display.lineTo(x0, h);
                display.lineTo(0, h);
                display.lineTo(0, 0);
                display.moveTo(x1, 0);
                display.lineTo(w, 0);
                display.lineTo(w, h);
                display.lineTo(x1, h);
                display.lineTo(x1, 0);
            }
            else {
                display.moveTo(0, 0);
                display.lineTo(0, y0);
                display.lineTo(w, y0);
                display.lineTo(w, 0);
                display.lineTo(0, 0);
                display.moveTo(0, y1);
                display.lineTo(0, h);
                display.lineTo(w, h);
                display.lineTo(w, y1);
                display.lineTo(0, y1);
            }
        });
    }
}
Object.defineProperty(XYChartScrollbar, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "XYChartScrollbar"
});
Object.defineProperty(XYChartScrollbar, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Scrollbar__WEBPACK_IMPORTED_MODULE_0__["Scrollbar"].classNames.concat([XYChartScrollbar.className])
});
//# sourceMappingURL=XYChartScrollbar.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYCursor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYCursor.js ***!
  \**************************************************************************/
/*! exports provided: XYCursor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XYCursor", function() { return XYCursor; });
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _axes_Grid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./axes/Grid */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Object__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");




//import { Animations } from "../core/util/Animation";





/**
 * Creates a chart cursor for an [[XYChart]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/cursor/} for more info
 * @important
 */
class XYCursor extends _core_render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"] {
    constructor() {
        super(...arguments);
        /**
         * A [[Grid]] elment that used for horizontal line of the cursor crosshair.
         *
         * @default Grid.new()
         */
        Object.defineProperty(this, "lineX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_axes_Grid__WEBPACK_IMPORTED_MODULE_3__["Grid"].new(this._root, {
                themeTags: ["x"]
            }))
        });
        /**
         * A [[Grid]] elment that used for horizontal line of the cursor crosshair.
         *
         * @default Grid.new()
         */
        Object.defineProperty(this, "lineY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_axes_Grid__WEBPACK_IMPORTED_MODULE_3__["Grid"].new(this._root, {
                themeTags: ["y"]
            }))
        });
        /**
         * An element that represents current selection.
         *
         * @default Graphics.new()
         */
        Object.defineProperty(this, "selection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_2__["Graphics"].new(this._root, {
                themeTags: ["selection", "cursor"], layer: 30
            }))
        });
        Object.defineProperty(this, "_movePoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_lastPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { x: 0, y: 0 }
        });
        Object.defineProperty(this, "_tooltipX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_tooltipY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A chart cursor is attached to.
         */
        Object.defineProperty(this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_toX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_toY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_5__["mergeTags"](this._settings.themeTags, ["xy", "cursor"]);
        super._afterNew();
        this.setAll({ "width": _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"], isMeasured: true, position: "absolute" });
        this.states.create("hidden", { visible: true, opacity: 0 });
        this._drawLines();
        this.setPrivateRaw("visible", false);
        this._disposers.push(this.setTimeout(() => {
            this.setPrivate("visible", true);
        }, 500));
        this._disposers.push(this.lineX.events.on("positionchanged", () => {
            this._handleXLine();
        }));
        this._disposers.push(this.lineY.events.on("positionchanged", () => {
            this._handleYLine();
        }));
        this._disposers.push(this.lineX.events.on("focus", (ev) => this._handleLineFocus(ev.target)));
        this._disposers.push(this.lineX.events.on("blur", (ev) => this._handleLineBlur(ev.target)));
        this._disposers.push(this.lineY.events.on("focus", (ev) => this._handleLineFocus(ev.target)));
        this._disposers.push(this.lineY.events.on("blur", (ev) => this._handleLineBlur(ev.target)));
        if (_core_util_Utils__WEBPACK_IMPORTED_MODULE_5__["supports"]("keyboardevents")) {
            this._disposers.push(_core_util_Utils__WEBPACK_IMPORTED_MODULE_5__["addEventListener"](document, "keydown", (ev) => {
                this._handleLineMove(ev.keyCode);
            }));
        }
    }
    _setUpTouch() {
        const chart = this.chart;
        if (chart) {
            chart.plotContainer._display.cancelTouch = this.get("behavior") != "none" ? true : false;
        }
    }
    _handleXLine() {
        let x = this.lineX.x();
        let visible = true;
        if (x < 0 || x > this.width()) {
            visible = false;
        }
        this.lineX.setPrivate("visible", visible);
    }
    _handleYLine() {
        let y = this.lineY.y();
        let visible = true;
        if (y < 0 || y > this.height()) {
            visible = false;
        }
        this.lineY.setPrivate("visible", visible);
    }
    _handleLineMove(keyCode) {
        let dir = "";
        let position = 0;
        let increment = 0.1;
        const chart = this.chart;
        if (this._root.focused(this.lineX)) {
            if (chart && chart.xAxes.length) {
                increment = chart.xAxes.getIndex(0).getCellWidthPosition();
            }
            position = this.getPrivate("positionX", 0);
            dir = "positionX";
            if (keyCode == 37) {
                position -= increment;
            }
            else if (keyCode == 39) {
                position += increment;
            }
        }
        else if (this._root.focused(this.lineY)) {
            if (chart && chart.yAxes.length) {
                increment = chart.yAxes.getIndex(0).getCellWidthPosition();
            }
            position = this.getPrivate("positionY", 0);
            dir = "positionY";
            if (keyCode == 38) {
                position -= increment;
            }
            else if (keyCode == 40) {
                position += increment;
            }
        }
        if (position < 0) {
            position = 0;
        }
        else if (position > 1) {
            position = 1;
        }
        if (dir != "") {
            this.set(dir, position);
        }
    }
    _handleLineFocus(_line) {
        this.setAll({
            positionX: this.getPrivate("positionX"),
            positionY: this.getPrivate("positionY"),
            alwaysShow: true
        });
    }
    _handleLineBlur(_line) {
        this.setAll({
            positionX: undefined,
            positionY: undefined,
            alwaysShow: false
        });
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.isDirty("xAxis")) {
            this._tooltipX = false;
            const xAxis = this.get("xAxis");
            if (xAxis) {
                const tooltip = xAxis.get("tooltip");
                if (tooltip) {
                    this._tooltipX = true;
                    this._disposers.push(tooltip.on("pointTo", () => {
                        this._updateXLine(tooltip);
                    }));
                }
            }
        }
        if (this.isDirty("yAxis")) {
            this._tooltipY = false;
            const yAxis = this.get("yAxis");
            if (yAxis) {
                const tooltip = yAxis.get("tooltip");
                if (tooltip) {
                    this._tooltipY = true;
                    this._disposers.push(tooltip.on("pointTo", () => {
                        this._updateYLine(tooltip);
                    }));
                }
            }
        }
    }
    _handleSyncWith() {
        const chart = this.chart;
        if (chart) {
            const syncWith = this.get("syncWith");
            const otherCharts = [];
            if (syncWith) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](syncWith, (cursor) => {
                    const chart = cursor.chart;
                    if (chart) {
                        otherCharts.push(chart);
                    }
                });
            }
            chart._otherCharts = otherCharts;
        }
    }
    _updateChildren() {
        super._updateChildren();
        this._handleSyncWith();
        if (this.isDirty("positionX") || this.isDirty("positionY")) {
            const positionX = this.get("positionX");
            const positionY = this.get("positionY");
            if (positionX == null && positionY == null) {
                this.hide(0);
            }
            else {
                this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0)));
                this.handleMove();
            }
        }
    }
    _updateXLine(tooltip) {
        let x = _core_util_Math__WEBPACK_IMPORTED_MODULE_6__["round"](this._display.toLocal(tooltip.get("pointTo", { x: 0, y: 0 })).x, 2);
        if (this._toX != x) {
            this.lineX.animate({ key: "x", to: x, duration: tooltip.get("animationDuration", 0), easing: tooltip.get("animationEasing") });
            this._toX = x;
        }
    }
    _updateYLine(tooltip) {
        let y = _core_util_Math__WEBPACK_IMPORTED_MODULE_6__["round"](this._display.toLocal(tooltip.get("pointTo", { x: 0, y: 0 })).y, 2);
        if (this._toY != y) {
            this.lineY.animate({ key: "y", to: y, duration: tooltip.get("animationDuration", 0), easing: tooltip.get("animationEasing") });
            this._toY = y;
        }
    }
    _drawLines() {
        this.lineX.set("draw", (display) => {
            display.moveTo(0, 0);
            display.lineTo(0, this.height());
        });
        this.lineY.set("draw", (display) => {
            display.moveTo(0, 0);
            display.lineTo(this.width(), 0);
        });
    }
    _setChart(chart) {
        this.chart = chart;
        this._handleSyncWith();
        const plotContainer = chart.plotContainer;
        this.events.on("boundschanged", () => {
            this._disposers.push(this.setTimeout(() => {
                if (this.get("alwaysShow")) {
                    this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0)));
                    this.handleMove();
                }
            }, 50));
        });
        //this._display.interactive = true;
        if (_core_util_Utils__WEBPACK_IMPORTED_MODULE_5__["supports"]("touchevents")) {
            this._disposers.push(plotContainer.events.on("click", (event) => {
                if (_core_util_Utils__WEBPACK_IMPORTED_MODULE_5__["isTouchEvent"](event.originalEvent)) {
                    this._handleMove(event.originalEvent);
                }
            }));
            this._setUpTouch();
        }
        this._disposers.push(plotContainer.events.on("pointerdown", (event) => {
            this._handleCursorDown(event.originalEvent);
        }));
        this._disposers.push(plotContainer.events.on("globalpointerup", (event) => {
            this._handleCursorUp(event.originalEvent);
            if (!event.native && !this.isHidden()) {
                this._handleMove(event.originalEvent);
            }
        }));
        this._disposers.push(plotContainer.events.on("globalpointermove", (event) => {
            if (!this.get("syncWith")) {
                if (_core_util_Object__WEBPACK_IMPORTED_MODULE_8__["keys"](plotContainer._downPoints).length == 0 && !event.native && this.isHidden()) {
                    // Ignore mouse movement if it originates on outside element and
                    // we're not dragging.
                    return;
                }
            }
            this._handleMove(event.originalEvent);
        }));
        const parent = this.parent;
        if (parent) {
            parent.children.moveValue(this.selection);
        }
    }
    _inPlot(point) {
        const chart = this.chart;
        if (chart) {
            return chart.inPlot(point);
        }
        return false;
    }
    _handleCursorDown(event) {
        if (event.button == 2) {
            return;
        }
        const rootPoint = this._root.documentPointToRoot({ x: event.clientX, y: event.clientY });
        let local = this._display.toLocal(rootPoint);
        const chart = this.chart;
        this.selection.set("draw", () => { });
        if (chart && this._inPlot(local)) {
            this._downPoint = local;
            if (this.get("behavior") != "none") {
                this.selection.show();
                const type = "selectstarted";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this });
                }
            }
            let positionX = this._getPosition(local).x;
            let positionY = this._getPosition(local).y;
            this.setPrivate("downPositionX", positionX);
            this.setPrivate("downPositionY", positionY);
        }
    }
    _handleCursorUp(event) {
        // TODO: handle multitouch
        if (this._downPoint) {
            const behavior = this.get("behavior", "none");
            if (behavior != "none") {
                if (behavior.charAt(0) === "z") {
                    this.selection.hide();
                }
                const rootPoint = this._root.documentPointToRoot({ x: event.clientX, y: event.clientY });
                let local = this._display.toLocal(rootPoint);
                const downPoint = this._downPoint;
                const moveThreshold = this.get("moveThreshold", 1);
                if (local && downPoint) {
                    let dispatch = false;
                    if (behavior === "zoomX" || behavior === "zoomXY" || behavior === "selectX" || behavior === "selectXY") {
                        if (Math.abs(local.x - downPoint.x) > moveThreshold) {
                            dispatch = true;
                        }
                    }
                    if (behavior === "zoomY" || behavior === "zoomXY" || behavior === "selectY" || behavior === "selectXY") {
                        if (Math.abs(local.y - downPoint.y) > moveThreshold) {
                            dispatch = true;
                        }
                    }
                    if (dispatch) {
                        const type = "selectended";
                        if (this.events.isEnabled(type)) {
                            this.events.dispatch(type, { type: type, target: this });
                        }
                    }
                }
            }
        }
        this._downPoint = undefined;
    }
    _handleMove(event) {
        if (this.getPrivate("visible")) {
            const chart = this.chart;
            if (chart && _core_util_Object__WEBPACK_IMPORTED_MODULE_8__["keys"](chart.plotContainer._downPoints).length > 1) {
                this.set("forceHidden", true);
                return;
            }
            else {
                this.set("forceHidden", false);
            }
            // TODO: handle multitouch
            const rootPoint = this._root.documentPointToRoot({ x: event.clientX, y: event.clientY });
            const lastPoint = this._lastPoint;
            if (Math.round(lastPoint.x) === Math.round(rootPoint.x) && Math.round(lastPoint.y) === Math.round(rootPoint.y)) {
                return;
            }
            this._lastPoint = rootPoint;
            this.setPrivate("lastPoint", rootPoint);
            this.handleMove({ x: rootPoint.x, y: rootPoint.y });
        }
    }
    _getPosition(point) {
        return { x: point.x / this.width(), y: point.y / this.height() };
    }
    /**
     * Moves the cursor to X/Y coordinates within chart container (`point`).
     *
     * If `skipEvent` parameter is set to `true`, the move will not invoke
     * the `"cursormoved"` event.
     *
     * @param  point      X/Y to move cursor to
     * @param  skipEvent  Do not fire "cursormoved" event
     */
    handleMove(point, skipEvent) {
        if (!point) {
            point = this._movePoint;
        }
        const alwaysShow = this.get("alwaysShow");
        if (!point) {
            this.hide(0);
            return;
        }
        this._movePoint = point;
        let local = this._display.toLocal(point);
        let chart = this.chart;
        if (chart && this._inPlot(local)) {
            chart._movePoint = point;
            if (this.isHidden()) {
                this.show();
                const behavior = this.get("behavior", "");
                if (behavior.charAt(0) == "z") {
                    this.selection.set("draw", () => { });
                }
            }
            let x = local.x;
            let y = local.y;
            let xyPos = this._getPosition(local);
            this.setPrivate("point", local);
            let snapToSeries = this.get("snapToSeries");
            if (this._downPoint) {
                snapToSeries = undefined;
            }
            let userPositionX = this.get("positionX");
            let positionX = xyPos.x;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__["isNumber"](userPositionX)) {
                positionX = userPositionX;
            }
            let userPositionY = this.get("positionY");
            let positionY = xyPos.y;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__["isNumber"](userPositionY)) {
                positionY = userPositionY;
            }
            this.setPrivate("positionX", positionX);
            this.setPrivate("positionY", positionY);
            const xy = this._getPoint(positionX, positionY);
            x = xy.x;
            y = xy.y;
            chart.xAxes.each((axis) => {
                axis._handleCursorPosition(positionX, snapToSeries);
                if (alwaysShow) {
                    axis.handleCursorShow();
                }
            });
            chart.yAxes.each((axis) => {
                axis._handleCursorPosition(positionY, snapToSeries);
                if (alwaysShow) {
                    axis.handleCursorShow();
                }
            });
            if (!skipEvent) {
                chart._handleCursorPosition();
                const type = "cursormoved";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this });
                }
            }
            this._updateLines(x, y);
            chart.arrangeTooltips();
        }
        else if (!this._downPoint) {
            if (!alwaysShow) {
                this.hide(0);
                const type = "cursorhidden";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this });
                }
            }
        }
        if (this._downPoint && this.get("behavior") != "none") {
            this._updateSelection(local);
        }
    }
    _getPoint(positionX, positionY) {
        return { x: this.width() * positionX, y: this.height() * positionY };
    }
    _updateLines(x, y) {
        if (!this._tooltipX) {
            this.lineX.set("x", x);
        }
        if (!this._tooltipY) {
            this.lineY.set("y", y);
        }
        this._drawLines();
    }
    _updateSelection(point) {
        const selection = this.selection;
        const behavior = this.get("behavior");
        const w = this.width();
        const h = this.height();
        if (point.x < 0) {
            point.x = 0;
        }
        if (point.x > w) {
            point.x = w;
        }
        if (point.y < 0) {
            point.y = 0;
        }
        if (point.y > h) {
            point.y = h;
        }
        selection.set("draw", (display) => {
            const downPoint = this._downPoint;
            if (downPoint) {
                if (behavior === "zoomXY" || behavior === "selectXY") {
                    display.moveTo(downPoint.x, downPoint.y);
                    display.lineTo(downPoint.x, point.y);
                    display.lineTo(point.x, point.y);
                    display.lineTo(point.x, downPoint.y);
                    display.lineTo(downPoint.x, downPoint.y);
                }
                else if (behavior === "zoomX" || behavior === "selectX") {
                    display.moveTo(downPoint.x, 0);
                    display.lineTo(downPoint.x, h);
                    display.lineTo(point.x, h);
                    display.lineTo(point.x, 0);
                    display.lineTo(downPoint.x, 0);
                }
                else if (behavior === "zoomY" || behavior === "selectY") {
                    display.moveTo(0, downPoint.y);
                    display.lineTo(w, downPoint.y);
                    display.lineTo(w, point.y);
                    display.lineTo(0, point.y);
                    display.lineTo(0, downPoint.y);
                }
            }
        });
    }
    _onHide() {
        if (this.isHidden()) {
            let chart = this.chart;
            if (chart) {
                chart.xAxes.each((axis) => {
                    axis.handleCursorHide();
                });
                chart.yAxes.each((axis) => {
                    axis.handleCursorHide();
                });
                chart.series.each((series) => {
                    series.handleCursorHide();
                });
            }
        }
        super._onHide();
    }
    _onShow() {
        if (!this.isHidden()) {
            let chart = this.chart;
            if (chart) {
                chart.xAxes.each((axis) => {
                    axis.handleCursorShow();
                });
                chart.yAxes.each((axis) => {
                    axis.handleCursorShow();
                });
            }
        }
        super._onShow();
    }
    _dispose() {
        super._dispose();
        this.selection.dispose();
    }
}
Object.defineProperty(XYCursor, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "XYCursor"
});
Object.defineProperty(XYCursor, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].classNames.concat([XYCursor.className])
});
//# sourceMappingURL=XYCursor.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js ***!
  \***************************************************************************/
/*! exports provided: Axis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Axis", function() { return Axis; });
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");









/**
 * A base class for all axes.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Adding_axes} for more info
 */
class Axis extends _core_render_Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_series", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_isPanning", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A [[Container]] that holds all the axis label elements.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "labelsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, {}))
        });
        /**
         * A [[Container]] that holds all the axis grid and fill elements.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "gridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"] })
        });
        /**
         * A [[Container]] that holds axis grid elements which goes above the series.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "topGridContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"] })
        });
        /**
         * A [[Container]] that holds all the axis bullet elements.
         *
         * @default new Container
         */
        Object.defineProperty(this, "bulletsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { isMeasured: false, width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"], position: "absolute" }))
        });
        /**
         * A referenece to the the chart the axis belongs to.
         */
        Object.defineProperty(this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rangesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_panStart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_panEnd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_sAnimation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_eAnimation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_skipSync", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A list of axis ranges.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
         * @default new List()
         */
        Object.defineProperty(this, "axisRanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_3__["List"]()
        });
        Object.defineProperty(this, "_seriesAxisRanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * A control label that is invisible but is used to keep width the width of
         * the axis constant.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Ghost_label} for more info
         */
        Object.defineProperty(this, "ghostLabel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cursorPosition", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: -1
        });
        Object.defineProperty(this, "_snapToSeries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_seriesValuesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * A container above the axis that can be used to add additional stuff into
         * it. For example a legend, label, or an icon.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info
         * @default new Container
         */
        Object.defineProperty(this, "axisHeader", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, {
                themeTags: ["axis", "header"],
                position: "absolute",
                background: _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_4__["Rectangle"].new(this._root, {
                    themeTags: ["header", "background"],
                    fill: this._root.interfaceColors.get("background")
                })
            }))
        });
        Object.defineProperty(this, "_bullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    _dispose() {
        // these could be in other parents, so disposing just in case
        this.gridContainer.dispose();
        this.topGridContainer.dispose();
        this.bulletsContainer.dispose();
        this.labelsContainer.dispose();
        this.axisHeader.dispose();
        super._dispose();
    }
    _afterNew() {
        super._afterNew();
        this.setPrivate("updateScrollbar", true);
        this._disposers.push(this.axisRanges.events.onAll((change) => {
            if (change.type === "clear") {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_5__["each"](change.oldValues, (dataItem) => {
                    this.disposeDataItem(dataItem);
                });
            }
            else if (change.type === "push") {
                this._processAxisRange(change.newValue, ["range"]);
            }
            else if (change.type === "setIndex") {
                this._processAxisRange(change.newValue, ["range"]);
            }
            else if (change.type === "insertIndex") {
                this._processAxisRange(change.newValue, ["range"]);
            }
            else if (change.type === "removeIndex") {
                this.disposeDataItem(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                this._processAxisRange(change.value, ["range"]);
            }
            else {
                throw new Error("Unknown IStreamEvent type");
            }
        }));
        const renderer = this.get("renderer");
        if (renderer) {
            renderer.axis = this;
            renderer.processAxis();
        }
        this.children.push(renderer);
        this.ghostLabel = renderer.makeLabel(new _core_render_Component__WEBPACK_IMPORTED_MODULE_0__["DataItem"](this, undefined, {}), []);
        this.ghostLabel.adapters.disable("text");
        this.ghostLabel.setAll({ opacity: 0, tooltipText: undefined, tooltipHTML: undefined, interactive: false });
        this.ghostLabel.events.disable();
    }
    _updateFinals(_start, _end) {
    }
    /**
     * Zooms the axis to relative locations.
     *
     * Both `start` and `end` are relative: 0 means start of the axis, 1 - end.
     *
     * @param   start     Relative start
     * @param   end       Relative end
     * @param   duration  Duration of the zoom animation in milliseconds
     * @return            Zoom animation
     */
    zoom(start, end, duration, priority) {
        this._updateFinals(start, end);
        if (this.get("start") !== start || this.get("end") != end) {
            let sAnimation = this._sAnimation;
            let eAnimation = this._eAnimation;
            let maxDeviation = this.get("maxDeviation", 0.5) * Math.min(1, (end - start));
            if (start < -maxDeviation) {
                start = -maxDeviation;
            }
            if (end > 1 + maxDeviation) {
                end = 1 + maxDeviation;
            }
            if (start > end) {
                [start, end] = [end, start];
            }
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](duration)) {
                duration = this.get("interpolationDuration", 0);
            }
            if (!priority) {
                priority = "end";
            }
            let maxZoomFactor = this.getPrivate("maxZoomFactor", this.get("maxZoomFactor", 100));
            let maxZoomFactorReal = maxZoomFactor;
            if (end === 1 && start !== 0) {
                if (start < this.get("start")) {
                    priority = "start";
                }
                else {
                    priority = "end";
                }
            }
            if (start === 0 && end !== 1) {
                if (end > this.get("end")) {
                    priority = "end";
                }
                else {
                    priority = "start";
                }
            }
            let minZoomCount = this.get("minZoomCount");
            let maxZoomCount = this.get("maxZoomCount");
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](minZoomCount)) {
                maxZoomFactor = maxZoomFactorReal / minZoomCount;
            }
            let minZoomFactor = 1;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](maxZoomCount)) {
                minZoomFactor = maxZoomFactorReal / maxZoomCount;
            }
            // most likely we are dragging left scrollbar grip here, so we tend to modify end
            if (priority === "start") {
                if (maxZoomCount > 0) {
                    // add to the end
                    if (1 / (end - start) < minZoomFactor) {
                        end = start + 1 / minZoomFactor;
                    }
                }
                // add to the end
                if (1 / (end - start) > maxZoomFactor) {
                    end = start + 1 / maxZoomFactor;
                }
                //unless end is > 0
                if (end > 1 && end - start < 1 / maxZoomFactor) {
                    //end = 1;
                    start = end - 1 / maxZoomFactor;
                }
            }
            // most likely we are dragging right, so we modify left
            else {
                if (maxZoomCount > 0) {
                    // add to the end
                    if (1 / (end - start) < minZoomFactor) {
                        start = end - 1 / minZoomFactor;
                    }
                }
                // remove from start
                if (1 / (end - start) > maxZoomFactor) {
                    start = end - 1 / maxZoomFactor;
                }
                if (start < 0 && end - start < 1 / maxZoomFactor) {
                    //start = 0;
                    end = start + 1 / maxZoomFactor;
                }
            }
            if (1 / (end - start) > maxZoomFactor) {
                end = start + 1 / maxZoomFactor;
            }
            if (1 / (end - start) > maxZoomFactor) {
                start = end - 1 / maxZoomFactor;
            }
            if (maxZoomCount != null && minZoomCount != null && (start == this.get("start") && end == this.get("end"))) {
                const chart = this.chart;
                if (chart) {
                    chart._handleAxisSelection(this, true);
                }
            }
            if (((sAnimation && sAnimation.playing && sAnimation.to == start) || this.get("start") == start) && ((eAnimation && eAnimation.playing && eAnimation.to == end) || this.get("end") == end)) {
                return;
            }
            if (duration > 0) {
                let easing = this.get("interpolationEasing");
                let sAnimation, eAnimation;
                if (this.get("start") != start) {
                    sAnimation = this.animate({ key: "start", to: start, duration: duration, easing: easing });
                }
                if (this.get("end") != end) {
                    eAnimation = this.animate({ key: "end", to: end, duration: duration, easing: easing });
                }
                this._sAnimation = sAnimation;
                this._eAnimation = eAnimation;
                if (sAnimation) {
                    return sAnimation;
                }
                else if (eAnimation) {
                    return eAnimation;
                }
            }
            else {
                this.set("start", start);
                this.set("end", end);
                // otherwise bullets and line out of sync, as series is not redrawn
                this._root.events.once("frameended", () => {
                    this._markDirtyKey("start");
                    this._root._markDirty();
                });
            }
        }
        else {
            if (this._sAnimation) {
                this._sAnimation.stop();
            }
            if (this._eAnimation) {
                this._eAnimation.stop();
            }
        }
    }
    /**
     * A list of series using this axis.
     *
     * @return Series
     */
    get series() {
        return this._series;
    }
    _processAxisRange(dataItem, themeTags) {
        dataItem.setRaw("isRange", true);
        this._createAssets(dataItem, themeTags);
        this._rangesDirty = true;
        this._prepareDataItem(dataItem);
        const above = dataItem.get("above");
        const container = this.topGridContainer;
        const grid = dataItem.get("grid");
        if (above && grid) {
            container.children.moveValue(grid);
        }
        const fill = dataItem.get("axisFill");
        if (above && fill) {
            container.children.moveValue(fill);
        }
    }
    _prepareDataItem(_dataItem, _index) { }
    /**
     * @ignore
     */
    markDirtyExtremes() {
    }
    /**
     * @ignore
     */
    markDirtySelectionExtremes() {
    }
    _calculateTotals() {
    }
    _updateAxisRanges() {
        this._bullets = {};
        this.axisRanges.each((axisRange) => {
            this._prepareDataItem(axisRange);
        });
        _core_util_Array__WEBPACK_IMPORTED_MODULE_5__["each"](this._seriesAxisRanges, (axisRange) => {
            this._prepareDataItem(axisRange);
        });
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.get("fixAxisSize")) {
            this.ghostLabel.set("visible", true);
        }
        else {
            this.ghostLabel.set("visible", false);
        }
        if (this.isDirty("start") || this.isDirty("end")) {
            this.chart._updateCursor();
            let start = this.get("start", 0);
            let end = this.get("end", 1);
            let maxDeviation = this.get("maxDeviation", 0.5) * Math.min(1, (end - start));
            if (start < -maxDeviation) {
                let delta = start + maxDeviation;
                start = -maxDeviation;
                this.setRaw("start", start);
                if (this.isDirty("end")) {
                    this.setRaw("end", end - delta);
                }
            }
            if (end > 1 + maxDeviation) {
                let delta = end - 1 - maxDeviation;
                end = 1 + maxDeviation;
                this.setRaw("end", end);
                if (this.isDirty("start")) {
                    this.setRaw("start", start - delta);
                }
            }
        }
        const renderer = this.get("renderer");
        renderer._start = this.get("start");
        renderer._end = this.get("end");
        renderer._inversed = renderer.get("inversed", false);
        renderer._axisLength = renderer.axisLength() / (renderer._end - renderer._start);
        renderer._updateLC();
        if (this.isDirty("tooltip")) {
            const tooltip = this.get("tooltip");
            if (tooltip) {
                const rendererTags = renderer.get("themeTags");
                tooltip.addTag("axis");
                tooltip.addTag(this.className.toLowerCase());
                tooltip._applyThemes();
                if (rendererTags) {
                    tooltip.set("themeTags", _core_util_Utils__WEBPACK_IMPORTED_MODULE_7__["mergeTags"](tooltip.get("themeTags"), rendererTags));
                    tooltip.label._applyThemes();
                }
            }
        }
    }
    _updateTooltipBounds() {
        const tooltip = this.get("tooltip");
        if (tooltip) {
            this.get("renderer").updateTooltipBounds(tooltip);
        }
    }
    _updateBounds() {
        super._updateBounds();
        this._updateTooltipBounds();
    }
    /**
     * @ignore
     */
    processChart(chart) {
        this.chart = chart;
        const renderer = this.get("renderer");
        renderer.chart = chart;
        chart.gridContainer.children.push(this.gridContainer);
        chart.topGridContainer.children.push(this.topGridContainer);
        chart.axisHeadersContainer.children.push(this.axisHeader);
        this.on("start", () => {
            chart._handleAxisSelection(this);
        });
        this.on("end", () => {
            chart._handleAxisSelection(this);
        });
        chart.plotContainer.onPrivate("width", () => {
            this.markDirtySize();
        });
        chart.plotContainer.onPrivate("height", () => {
            this.markDirtySize();
        });
        chart.processAxis(this);
    }
    /**
     * @ignore
     */
    hideDataItem(dataItem) {
        this._toggleDataItem(dataItem, false);
        return super.hideDataItem(dataItem);
    }
    /**
     * @ignore
     */
    showDataItem(dataItem) {
        this._toggleDataItem(dataItem, true);
        return super.showDataItem(dataItem);
    }
    _toggleDataItem(dataItem, visible) {
        const label = dataItem.get("label");
        if (label) {
            label.setPrivate("visible", visible);
        }
        const grid = dataItem.get("grid");
        if (grid) {
            grid.setPrivate("visible", visible);
        }
        const tick = dataItem.get("tick");
        if (tick) {
            tick.setPrivate("visible", visible);
        }
        const axisFill = dataItem.get("axisFill");
        if (axisFill) {
            axisFill.setPrivate("visible", visible);
        }
        const bullet = dataItem.get("bullet");
        if (bullet) {
            const sprite = bullet.get("sprite");
            if (sprite) {
                sprite.setPrivate("visible", visible);
            }
        }
    }
    _createAssets(dataItem, tags) {
        const renderer = this.get("renderer");
        if (!dataItem.get("label")) {
            renderer.makeLabel(dataItem, tags);
        }
        if (!dataItem.get("grid")) {
            renderer.makeGrid(dataItem, tags);
        }
        if (!dataItem.get("tick")) {
            renderer.makeTick(dataItem, tags);
        }
        if (!dataItem.get("axisFill")) {
            renderer.makeAxisFill(dataItem, tags);
        }
        this._processBullet(dataItem);
    }
    _processBullet(dataItem) {
        let bullet = dataItem.get("bullet");
        let axisBullet = this.get("bullet");
        if (!bullet && axisBullet && !dataItem.get("isRange")) {
            bullet = axisBullet(this._root, this, dataItem);
        }
        if (bullet) {
            bullet.axis = this;
            const sprite = bullet.get("sprite");
            if (sprite) {
                sprite._setDataItem(dataItem);
                dataItem.setRaw("bullet", bullet);
                if (!sprite.parent) {
                    this.bulletsContainer.children.push(sprite);
                }
            }
        }
    }
    _afterChanged() {
        super._afterChanged();
        const chart = this.chart;
        if (chart) {
            chart._updateChartLayout();
            chart.axisHeadersContainer.markDirtySize();
        }
        this.get("renderer")._updatePositions();
    }
    /**
     * @ignore
     */
    disposeDataItem(dataItem) {
        super.disposeDataItem(dataItem);
        const renderer = this.get("renderer");
        const label = dataItem.get("label");
        if (label) {
            renderer.labels.removeValue(label);
            label.dispose();
        }
        const tick = dataItem.get("tick");
        if (tick) {
            renderer.ticks.removeValue(tick);
            tick.dispose();
        }
        const grid = dataItem.get("grid");
        if (grid) {
            renderer.grid.removeValue(grid);
            grid.dispose();
        }
        const axisFill = dataItem.get("axisFill");
        if (axisFill) {
            renderer.axisFills.removeValue(axisFill);
            axisFill.dispose();
        }
        const bullet = dataItem.get("bullet");
        if (bullet) {
            bullet.dispose();
        }
    }
    _updateGhost() {
        this.setPrivate("cellWidth", this.getCellWidthPosition() * this.get("renderer").axisLength());
        const ghostLabel = this.ghostLabel;
        if (!ghostLabel.isHidden()) {
            const bounds = ghostLabel.localBounds();
            const gWidth = bounds.right - bounds.left;
            let text = ghostLabel.get("text");
            _core_util_Array__WEBPACK_IMPORTED_MODULE_5__["each"](this.dataItems, (dataItem) => {
                const label = dataItem.get("label");
                if (label && !label.isHidden()) {
                    const bounds = label.localBounds();
                    const w = bounds.right - bounds.left;
                    if (w > gWidth) {
                        text = label.text._getText();
                    }
                }
            });
            ghostLabel.set("text", text);
        }
        let start = this.get("start", 0);
        let end = this.get("end", 1);
        this.get("renderer").updateLabel(ghostLabel, start + (end - start) * 0.5);
    }
    _handleCursorPosition(position, snapToSeries) {
        const renderer = this.get("renderer");
        position = renderer.toAxisPosition(position);
        this._cursorPosition = position;
        this._snapToSeries = snapToSeries;
        this.updateTooltip();
    }
    /**
     * Can be called when axis zoom changes and you need to update tooltip
     * position.
     */
    updateTooltip() {
        const snapToSeries = this._snapToSeries;
        let position = this._cursorPosition;
        const tooltip = this.get("tooltip");
        const renderer = this.get("renderer");
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](position)) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_5__["each"](this.series, (series) => {
                if (series.get("baseAxis") === this) {
                    const dataItem = this.getSeriesItem(series, position, this.get("tooltipLocation"));
                    series.setRaw("tooltipDataItem", dataItem);
                    if (snapToSeries && snapToSeries.indexOf(series) != -1) {
                        series.updateLegendMarker(dataItem);
                        series.updateLegendValue(dataItem);
                    }
                    else {
                        series.showDataItemTooltip(dataItem);
                    }
                }
            });
            if (tooltip) {
                renderer.updateTooltipBounds(tooltip);
                if (this.get("snapTooltip")) {
                    position = this.roundAxisPosition(position, this.get("tooltipLocation", 0.5));
                }
                if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNaN"](position)) {
                    this.setPrivateRaw("tooltipPosition", position);
                    this._updateTooltipText(tooltip, position);
                    renderer.positionTooltip(tooltip, position);
                    if (position < this.get("start") || position > this.get("end")) {
                        tooltip.hide(0);
                    }
                    else {
                        tooltip.show(0);
                    }
                }
                else {
                    tooltip.hide(0);
                }
            }
        }
    }
    _updateTooltipText(tooltip, position) {
        tooltip.label.set("text", this.getTooltipText(position));
    }
    /**
     * @ignore
     */
    roundAxisPosition(position, _location) {
        return position;
    }
    /**
     * @ignore
     */
    handleCursorShow() {
        let tooltip = this.get("tooltip");
        if (tooltip) {
            tooltip.show();
        }
    }
    /**
     * @ignore
     */
    handleCursorHide() {
        let tooltip = this.get("tooltip");
        if (tooltip) {
            tooltip.hide();
        }
    }
    /**
     * @ignore
     */
    processSeriesDataItem(_dataItem, _fields) {
    }
    _clearDirty() {
        super._clearDirty();
        this._sizeDirty = false;
        this._rangesDirty = false;
    }
    /**
     * Converts pixel coordinate to a relative position on axis.
     *
     * @param   coordinate  Coordinate
     * @return              Relative position
     */
    coordinateToPosition(coordinate) {
        const renderer = this.get("renderer");
        return renderer.toAxisPosition(coordinate / renderer.axisLength());
    }
    /**
     * Converts relative position of the plot area to relative position of the
     * axis with zoom taken into account.
     *
     * @param position Position
     * @return Relative position
     */
    toAxisPosition(position) {
        return this.get("renderer").toAxisPosition(position);
    }
    /**
     * Adjusts position with inversed taken into account.
     *
     * @ignore
     */
    fixPosition(position) {
        return this.get("renderer").fixPosition(position);
    }
    /**
     * @ignore
     */
    shouldGap(_dataItem, _nextItem, _autoGapCount, _fieldName) {
        return false;
    }
    /**
     * Creates and returns an axis range object.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
     * @param   axisDataItem  Axis data item
     * @return                Axis range
     */
    createAxisRange(axisDataItem) {
        return this.axisRanges.push(axisDataItem);
    }
    /**
     * @ignore
     */
    _groupSeriesData(_series) { }
    /**
     * Returns relative position between two grid lines of the axis.
     *
     * @return Position
     */
    getCellWidthPosition() {
        return 0.05;
    }
}
Object.defineProperty(Axis, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Axis"
});
Object.defineProperty(Axis, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Component__WEBPACK_IMPORTED_MODULE_0__["Component"].classNames.concat([Axis.className])
});
//# sourceMappingURL=Axis.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisBullet.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisBullet.js ***!
  \*********************************************************************************/
/*! exports provided: AxisBullet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisBullet", function() { return AxisBullet; });
/* harmony import */ var _core_util_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");

/**
 * Draws a bullet on an axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Axis_bullets} for more info
 */
class AxisBullet extends _core_util_Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    constructor() {
        super(...arguments);
        /**
         * Target axis object.
         */
        Object.defineProperty(this, "axis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _beforeChanged() {
        super._beforeChanged();
        const sprite = this.get("sprite");
        if (this.isDirty("sprite")) {
            if (sprite) {
                sprite.setAll({ position: "absolute", role: "figure" });
                this._disposers.push(sprite);
            }
        }
        if (this.isDirty("location")) {
            const dataItem = sprite.dataItem;
            if (this.axis && sprite && dataItem) {
                this.axis._prepareDataItem(dataItem);
            }
        }
    }
}
Object.defineProperty(AxisBullet, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisBullet"
});
Object.defineProperty(AxisBullet, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_util_Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"].classNames.concat([AxisBullet.className])
});
//# sourceMappingURL=AxisBullet.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js ***!
  \********************************************************************************/
/*! exports provided: AxisLabel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisLabel", function() { return AxisLabel; });
/* harmony import */ var _core_render_Label__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");

/**
 * Draws an axis label.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Labels} for more info
 * @important
 */
class AxisLabel extends _core_render_Label__WEBPACK_IMPORTED_MODULE_0__["Label"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_tickPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
}
Object.defineProperty(AxisLabel, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisLabel"
});
Object.defineProperty(AxisLabel, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Label__WEBPACK_IMPORTED_MODULE_0__["Label"].classNames.concat([AxisLabel.className])
});
//# sourceMappingURL=AxisLabel.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabelRadial.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabelRadial.js ***!
  \**************************************************************************************/
/*! exports provided: AxisLabelRadial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisLabelRadial", function() { return AxisLabelRadial; });
/* harmony import */ var _core_render_RadialLabel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/RadialLabel */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RadialLabel.js");

/**
 * Draws a label on a circular axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Labels} for more info
 */
class AxisLabelRadial extends _core_render_RadialLabel__WEBPACK_IMPORTED_MODULE_0__["RadialLabel"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_tickPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
}
Object.defineProperty(AxisLabelRadial, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisLabelRadial"
});
Object.defineProperty(AxisLabelRadial, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_RadialLabel__WEBPACK_IMPORTED_MODULE_0__["RadialLabel"].classNames.concat([AxisLabelRadial.className])
});
//# sourceMappingURL=AxisLabelRadial.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js ***!
  \***********************************************************************************/
/*! exports provided: AxisRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisRenderer", function() { return AxisRenderer; });
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _AxisTick__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AxisTick */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js");
/* harmony import */ var _Grid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Grid */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js");
/* harmony import */ var _AxisLabel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AxisLabel */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");







/**
 * Base class for an axis renderer.
 *
 * Should not be used on its own.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
 */
class AxisRenderer extends _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"] {
    constructor() {
        super(...arguments);
        // save for quick access
        Object.defineProperty(this, "_axisLength", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 100
        });
        Object.defineProperty(this, "_start", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_end", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_inversed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_minSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * Chart the renderer is used in.
         */
        Object.defineProperty(this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_lc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_ls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_thumbDownPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downStart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downEnd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A list of ticks in the axis.
         *
         * `ticks.template` can be used to configure ticks.
         *
         * @default new ListTemplate<AxisTick>
         */
        Object.defineProperty(this, "ticks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_2__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_1__["Template"].new({}), () => _AxisTick__WEBPACK_IMPORTED_MODULE_3__["AxisTick"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.ticks.template.get("themeTags", []), this.get("themeTags", []))
            }, [this.ticks.template]))
        });
        /**
         * A list of grid elements in the axis.
         *
         * `grid.template` can be used to configure grid.
         *
         * @default new ListTemplate<Grid>
         */
        Object.defineProperty(this, "grid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_2__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_1__["Template"].new({}), () => _Grid__WEBPACK_IMPORTED_MODULE_4__["Grid"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.grid.template.get("themeTags", []), this.get("themeTags", []))
            }, [this.grid.template]))
        });
        /**
         * A list of fills in the axis.
         *
         * `axisFills.template` can be used to configure axis fills.
         *
         * @default new ListTemplate<Graphics>
         */
        Object.defineProperty(this, "axisFills", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_2__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_1__["Template"].new({}), () => _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.axisFills.template.get("themeTags", ["axis", "fill"]), this.get("themeTags", []))
            }, [this.axisFills.template]))
        });
        /**
         * A list of labels in the axis.
         *
         * `labels.template` can be used to configure axis labels.
         *
         * @default new ListTemplate<AxisLabel>
         */
        Object.defineProperty(this, "labels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_2__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_1__["Template"].new({}), () => _AxisLabel__WEBPACK_IMPORTED_MODULE_5__["AxisLabel"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.labels.template.get("themeTags", []), this.get("themeTags", []))
            }, [this.labels.template]))
        });
        /**
         * An [[Axis]] renderer is for.
         */
        Object.defineProperty(this, "axis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    /**
     * @ignore
     */
    makeTick(dataItem, themeTags) {
        const tick = this.ticks.make();
        tick._setDataItem(dataItem);
        dataItem.setRaw("tick", tick);
        tick.set("themeTags", _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](tick.get("themeTags"), themeTags));
        this.axis.labelsContainer.children.push(tick);
        this.ticks.push(tick);
        return tick;
    }
    /**
     * @ignore
     */
    makeGrid(dataItem, themeTags) {
        const grid = this.grid.make();
        grid._setDataItem(dataItem);
        dataItem.setRaw("grid", grid);
        grid.set("themeTags", _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](grid.get("themeTags"), themeTags));
        this.axis.gridContainer.children.push(grid);
        this.grid.push(grid);
        return grid;
    }
    /**
     * @ignore
     */
    makeAxisFill(dataItem, themeTags) {
        const axisFill = this.axisFills.make();
        axisFill._setDataItem(dataItem);
        axisFill.set("themeTags", _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](axisFill.get("themeTags"), themeTags));
        this.axis.gridContainer.children.push(axisFill);
        dataItem.setRaw("axisFill", axisFill);
        this.axisFills.push(axisFill);
        return axisFill;
    }
    /**
     * @ignore
     */
    makeLabel(dataItem, themeTags) {
        const label = this.labels.make();
        label.set("themeTags", _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](label.get("themeTags"), themeTags));
        this.axis.labelsContainer.children.moveValue(label, 0);
        label._setDataItem(dataItem);
        dataItem.setRaw("label", label);
        this.labels.push(label);
        return label;
    }
    axisLength() {
        return 0;
    }
    /**
     * @ignore
     */
    gridCount() {
        return this.axisLength() / this.get("minGridDistance", 50);
    }
    _updatePositions() {
    }
    _afterNew() {
        super._afterNew();
        this.set("isMeasured", false);
        const thumb = this.thumb;
        if (thumb) {
            this._disposers.push(thumb.events.on("pointerdown", (event) => {
                this._handleThumbDown(event.originalEvent);
            }));
            this._disposers.push(thumb.events.on("globalpointerup", (event) => {
                this._handleThumbUp(event.originalEvent);
            }));
            this._disposers.push(thumb.events.on("globalpointermove", (event) => {
                this._handleThumbMove(event.originalEvent);
            }));
        }
    }
    _changed() {
        super._changed();
        if (this.isDirty("pan")) {
            const thumb = this.thumb;
            if (thumb) {
                const labelsContainer = this.axis.labelsContainer;
                const pan = this.get("pan");
                if (pan == "zoom") {
                    labelsContainer.children.push(thumb);
                }
                else if (pan == "none") {
                    labelsContainer.children.removeValue(thumb);
                }
            }
        }
    }
    _handleThumbDown(event) {
        this._thumbDownPoint = this.toLocal(this._root.documentPointToRoot({ x: event.clientX, y: event.clientY }));
        const axis = this.axis;
        this._downStart = axis.get("start");
        this._downEnd = axis.get("end");
    }
    _handleThumbUp(_event) {
        this._thumbDownPoint = undefined;
    }
    _handleThumbMove(event) {
        const downPoint = this._thumbDownPoint;
        if (downPoint) {
            const point = this.toLocal(this._root.documentPointToRoot({ x: event.clientX, y: event.clientY }));
            const downStart = this._downStart;
            const downEnd = this._downEnd;
            const extra = this._getPan(point, downPoint) * Math.min(1, (downEnd - downStart)) / 2;
            this.axis.setAll({ start: downStart - extra, end: downEnd + extra });
        }
    }
    _getPan(_point1, _point2) {
        return 0;
    }
    /**
     * Converts relative position (0-1) on axis to a pixel coordinate.
     *
     * @param position  Position (0-1)
     * @return Coordinate (px)
     */
    positionToCoordinate(position) {
        if (this._inversed) {
            return (this._end - position) * this._axisLength;
        }
        else {
            return (position - this._start) * this._axisLength;
        }
    }
    /**
     * @ignore
     */
    updateTooltipBounds(_tooltip) { }
    _updateSize() {
        this.markDirty();
        this._clear = true;
    }
    toAxisPosition(position) {
        const start = this._start || 0;
        const end = this._end || 1;
        position = position * (end - start);
        if (!this.get("inversed")) {
            position = start + position;
        }
        else {
            position = end - position;
        }
        return position;
    }
    /**
     * @ignore
     */
    fixPosition(position) {
        if (this.get("inversed")) {
            return 1 - position;
        }
        return position;
    }
    _updateLC() {
    }
    toggleVisibility(sprite, position, minPosition, maxPosition) {
        let axis = this.axis;
        const start = axis.get("start", 0);
        const end = axis.get("end", 1);
        let updatedStart = start + (end - start) * (minPosition - 0.0001);
        let updatedEnd = start + (end - start) * (maxPosition + 0.0001);
        if (position < updatedStart || position > updatedEnd) {
            sprite.setPrivate("visible", false);
        }
        else {
            sprite.setPrivate("visible", true);
        }
    }
    _positionTooltip(tooltip, point) {
        const chart = this.chart;
        if (chart) {
            if (chart.inPlot(point)) {
                tooltip.set("pointTo", this._display.toGlobal(point));
            }
            else {
                tooltip.hide();
            }
        }
    }
    processAxis() { }
}
Object.defineProperty(AxisRenderer, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisRenderer"
});
Object.defineProperty(AxisRenderer, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"].classNames.concat([AxisRenderer.className])
});
//# sourceMappingURL=AxisRenderer.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js ***!
  \************************************************************************************/
/*! exports provided: AxisRendererX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisRendererX", function() { return AxisRendererX; });
/* harmony import */ var _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxisRenderer */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");





/**
 * Used to render horizontal axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
 * @important
 */
class AxisRendererX extends _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__["AxisRenderer"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_4__["Rectangle"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"], isMeasured: false, themeTags: ["axis", "x", "thumb"] })
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__["mergeTags"](this._settings.themeTags, ["renderer", "x"]);
        super._afterNew();
        this.setPrivateRaw("letter", "X");
        const gridTemplate = this.grid.template;
        gridTemplate.set("height", _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]);
        gridTemplate.set("width", 0);
        gridTemplate.set("draw", (display, graphics) => {
            display.moveTo(0, 0);
            display.lineTo(0, graphics.height());
        });
        this.set("draw", (display, graphics) => {
            display.moveTo(0, 0);
            display.lineTo(graphics.width(), 0);
        });
    }
    _changed() {
        super._changed();
        const axis = this.axis;
        axis.ghostLabel.setPrivate("visible", !this.get("inside"));
        axis.ghostLabel.set("x", -1000);
        const opposite = "opposite";
        const inside = "inside";
        if (this.isDirty(opposite) || this.isDirty(inside)) {
            const chart = this.chart;
            const axisChildren = axis.children;
            if (this.get(inside)) {
                axis.addTag(inside);
            }
            else {
                axis.removeTag(inside);
            }
            if (chart) {
                if (this.get(opposite)) {
                    const children = chart.topAxesContainer.children;
                    if (children.indexOf(axis) == -1) {
                        children.insertIndex(0, axis);
                    }
                    axis.addTag(opposite);
                    axisChildren.moveValue(this);
                }
                else {
                    const children = chart.bottomAxesContainer.children;
                    if (children.indexOf(axis) == -1) {
                        children.moveValue(axis);
                    }
                    axis.removeTag(opposite);
                    axisChildren.moveValue(this, 0);
                }
                axis.ghostLabel._applyThemes();
                this.labels.each((label) => {
                    label._applyThemes();
                });
                this.root._markDirtyRedraw();
            }
            axis.markDirtySize();
        }
        this.thumb.setPrivate("height", axis.labelsContainer.height());
    }
    _getPan(point1, point2) {
        return (point2.x - point1.x) / this.width();
    }
    toAxisPosition(position) {
        const start = this._start || 0;
        const end = this._end || 1;
        position -= this._ls;
        position = position * (end - start) / this._lc;
        if (!this.get("inversed")) {
            position = start + position;
        }
        else {
            position = end - position;
        }
        return position;
    }
    _updateLC() {
        const axis = this.axis;
        const parent = axis.parent;
        if (parent) {
            const w = parent.innerWidth();
            this._lc = this.axisLength() / w;
            this._ls = (axis.x() - parent.get("paddingLeft", 0)) / w;
        }
    }
    _updatePositions() {
        const axis = this.axis;
        axis.gridContainer.set("x", axis.x() - _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__["relativeToValue"](axis.get("centerX", 0), axis.width()) - axis.parent.get("paddingLeft", 0));
        axis.bulletsContainer.set("y", this.y());
        const chart = axis.chart;
        if (chart) {
            const plotContainer = chart.plotContainer;
            const axisHeader = axis.axisHeader;
            let width = axis.get("marginLeft", 0);
            let x = axis.x() - width;
            const parent = axis.parent;
            if (parent) {
                x -= parent.get("paddingLeft", 0);
            }
            if (axisHeader.children.length > 0) {
                width = axis.axisHeader.width();
                axis.set("marginLeft", width + 1);
            }
            else {
                axisHeader.set("width", width);
            }
            axisHeader.setAll({ x: x, y: -1, height: plotContainer.height() + 2 });
        }
    }
    /**
     * @ignore
     */
    processAxis() {
        super.processAxis();
        const axis = this.axis;
        axis.set("width", _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]);
        const verticalLayout = this._root.verticalLayout;
        axis.set("layout", verticalLayout);
        axis.labelsContainer.set("width", _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]);
        axis.axisHeader.setAll({ layout: verticalLayout });
    }
    /**
     * @ignore
     */
    axisLength() {
        return this.axis.width();
    }
    /**
     * Converts axis relative position to actual coordinate in pixels.
     *
     * @param   position  Position
     * @return            Point
     */
    positionToPoint(position) {
        return { x: this.positionToCoordinate(position), y: 0 };
    }
    /**
     * @ignore
     */
    updateTick(tick, position, endPosition, count) {
        if (tick) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](position)) {
                position = 0;
            }
            let location = 0.5;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](count) && count > 1) {
                location = tick.get("multiLocation", location);
            }
            else {
                location = tick.get("location", location);
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            tick.set("x", this.positionToCoordinate(position));
            let length = tick.get("length", 0);
            const inside = tick.get("inside", this.get("inside", false));
            if (this.get("opposite")) {
                tick.set("y", _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]);
                if (!inside) {
                    length *= -1;
                }
            }
            else {
                tick.set("y", 0);
                if (inside) {
                    length *= -1;
                }
            }
            tick.set("draw", (display) => {
                display.moveTo(0, 0);
                display.lineTo(0, length);
            });
            this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));
        }
    }
    /**
     * @ignore
     */
    updateLabel(label, position, endPosition, count) {
        if (label) {
            let location = 0.5;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](count) && count > 1) {
                location = label.get("multiLocation", location);
            }
            else {
                location = label.get("location", location);
            }
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](position)) {
                position = 0;
            }
            const inside = label.get("inside", this.get("inside", false));
            const opposite = this.get("opposite");
            if (opposite) {
                if (!inside) {
                    label.set("position", "relative");
                    label.set("y", _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]);
                }
                else {
                    label.set("position", "absolute");
                    label.set("y", 0);
                }
            }
            else {
                if (!inside) {
                    label.set("y", undefined);
                    label.set("position", "relative");
                }
                else {
                    label.set("y", 0);
                    label.set("position", "absolute");
                }
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            label.set("x", this.positionToCoordinate(position));
            this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));
        }
    }
    /**
     * @ignore
     */
    updateGrid(grid, position, endPosition) {
        if (grid) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](position)) {
                position = 0;
            }
            let location = grid.get("location", 0.5);
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            grid.set("x", this.positionToCoordinate(position));
            this.toggleVisibility(grid, position, 0, 1);
        }
    }
    /**
     * @ignore
     */
    updateBullet(bullet, position, endPosition) {
        if (bullet) {
            const sprite = bullet.get("sprite");
            if (sprite) {
                if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](position)) {
                    position = 0;
                }
                let location = bullet.get("location", 0.5);
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                let bulletPosition = this.axis.roundAxisPosition(position, location);
                let previousBullet = this.axis._bullets[bulletPosition];
                let d = -1;
                if (this.get("opposite")) {
                    d = 1;
                }
                if (bullet.get("stacked")) {
                    if (previousBullet) {
                        let previousSprite = previousBullet.get("sprite");
                        if (previousSprite) {
                            sprite.set("y", previousSprite.y() + previousSprite.height() * d);
                        }
                    }
                    else {
                        sprite.set("y", 0);
                    }
                }
                this.axis._bullets[bulletPosition] = bullet;
                sprite.set("x", this.positionToCoordinate(position));
                this.toggleVisibility(sprite, position, 0, 1);
            }
        }
    }
    /**
     * @ignore
     */
    updateFill(fill, position, endPosition) {
        if (fill) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](position)) {
                position = 0;
            }
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endPosition)) {
                endPosition = 1;
            }
            let x0 = this.positionToCoordinate(position);
            let x1 = this.positionToCoordinate(endPosition);
            this.fillDrawMethod(fill, x0, x1);
        }
    }
    fillDrawMethod(fill, x0, x1) {
        fill.set("draw", (display) => {
            //display.drawRect(x0, 0, x1 - x0, this.axis!.gridContainer.height());
            // using for holes, so can not be rectangle
            const h = this.axis.gridContainer.height();
            const w = this.width();
            if (x1 < x0) {
                [x1, x0] = [x0, x1];
            }
            if (x0 > w || x1 < 0) {
                return;
            }
            /*
            const limit = 10000;

            x0 = Math.max(-limit, x0);
            x1 = Math.min(limit, x1);
            */
            display.moveTo(x0, 0);
            display.lineTo(x1, 0);
            display.lineTo(x1, h);
            display.lineTo(x0, h);
            display.lineTo(x0, 0);
        });
    }
    /**
     * @ignore
     */
    positionTooltip(tooltip, position) {
        this._positionTooltip(tooltip, { x: this.positionToCoordinate(position), y: 0 });
    }
    /**
     * @ignore
     */
    updateTooltipBounds(tooltip) {
        const inside = this.get("inside");
        const num = 100000;
        let global = this._display.toGlobal({ x: 0, y: 0 });
        let x = global.x;
        let y = 0;
        let w = this.axisLength();
        let h = num;
        let pointerOrientation = "up";
        if (this.get("opposite")) {
            if (inside) {
                pointerOrientation = "up";
                y = global.y;
                h = num;
            }
            else {
                pointerOrientation = "down";
                y = global.y - num;
                h = num;
            }
        }
        else {
            if (inside) {
                pointerOrientation = "down";
                y = global.y - num;
                h = num;
            }
            else {
                pointerOrientation = "up";
                y = global.y;
                h = num;
            }
        }
        const bounds = { left: x, right: x + w, top: y, bottom: y + h };
        const oldBounds = tooltip.get("bounds");
        if (!_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__["sameBounds"](bounds, oldBounds)) {
            tooltip.set("bounds", bounds);
            tooltip.set("pointerOrientation", pointerOrientation);
        }
    }
}
Object.defineProperty(AxisRendererX, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisRendererX"
});
Object.defineProperty(AxisRendererX, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__["AxisRenderer"].classNames.concat([AxisRendererX.className])
});
//# sourceMappingURL=AxisRendererX.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js ***!
  \************************************************************************************/
/*! exports provided: AxisRendererY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisRendererY", function() { return AxisRendererY; });
/* harmony import */ var _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxisRenderer */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");





/**
 * Used to render vertical axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Axis_renderer} for more info
 * @important
 */
class AxisRendererY extends _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__["AxisRenderer"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_downY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_4__["Rectangle"].new(this._root, { height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"], isMeasured: false, themeTags: ["axis", "y", "thumb"] })
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__["mergeTags"](this._settings.themeTags, ["renderer", "y"]);
        if (this._settings.opposite) {
            this._settings.themeTags.push("opposite");
        }
        super._afterNew();
        this.setPrivateRaw("letter", "Y");
        const gridTemplate = this.grid.template;
        gridTemplate.set("width", _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]);
        gridTemplate.set("height", 0);
        gridTemplate.set("draw", (display, graphics) => {
            display.moveTo(0, 0);
            display.lineTo(graphics.width(), 0);
        });
        this.set("draw", (display, renderer) => {
            display.moveTo(0, 0);
            display.lineTo(0, renderer.height());
        });
    }
    _getPan(point1, point2) {
        return (point1.y - point2.y) / this.height();
    }
    _changed() {
        super._changed();
        const axis = this.axis;
        axis.ghostLabel.setPrivate("visible", !this.get("inside"));
        axis.ghostLabel.set("y", -1000);
        const thumb = this.thumb;
        const opposite = "opposite";
        const inside = "inside";
        const chart = this.chart;
        if (this.isDirty(opposite) || this.isDirty(inside)) {
            const axisChildren = axis.children;
            if (this.get(inside)) {
                axis.addTag(inside);
            }
            else {
                axis.removeTag(inside);
            }
            if (chart) {
                if (this.get(opposite)) {
                    const children = chart.rightAxesContainer.children;
                    if (children.indexOf(axis) == -1) {
                        children.moveValue(axis, 0);
                    }
                    axis.addTag(opposite);
                    axisChildren.moveValue(this, 0);
                }
                else {
                    const children = chart.leftAxesContainer.children;
                    if (children.indexOf(axis) == -1) {
                        children.moveValue(axis);
                    }
                    axis.removeTag(opposite);
                    axisChildren.moveValue(this);
                }
                axis.ghostLabel._applyThemes();
                this.labels.each((label) => {
                    label._applyThemes();
                });
                this.root._markDirtyRedraw();
            }
            axis.markDirtySize();
        }
        var w = axis.labelsContainer.width();
        if (chart) {
            if (this.get(opposite)) {
                thumb.set("centerX", 0);
            }
            else {
                thumb.set("centerX", w);
            }
        }
        thumb.setPrivate("width", w);
    }
    /**
     * @ignore
     */
    processAxis() {
        super.processAxis();
        const axis = this.axis;
        if (axis.get("height") == null) {
            axis.set("height", _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]);
        }
        const horizontalLayout = this._root.horizontalLayout;
        axis.set("layout", horizontalLayout);
        axis.labelsContainer.set("height", _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]);
        axis.axisHeader.set("layout", horizontalLayout);
    }
    _updatePositions() {
        const axis = this.axis;
        axis.gridContainer.set("y", axis.y() - _core_util_Utils__WEBPACK_IMPORTED_MODULE_3__["relativeToValue"](axis.get("centerY", 0), axis.height()));
        axis.bulletsContainer.set("x", this.x());
        const chart = axis.chart;
        if (chart) {
            const plotContainer = chart.plotContainer;
            const axisHeader = axis.axisHeader;
            let height = axis.get("marginTop", 0);
            if (axisHeader.children.length > 0) {
                height = axis.axisHeader.height();
                axis.set("marginTop", height + 1);
            }
            else {
                axisHeader.set("height", height);
            }
            axisHeader.setAll({ y: axis.y() - height, x: -1, width: plotContainer.width() + 2 });
        }
    }
    /**
     * @ignore
     */
    axisLength() {
        return this.axis.innerHeight();
    }
    /**
     * Converts axis relative position to actual coordinate in pixels.
     *
     * @param   position  Position
     * @return            Point
     */
    positionToPoint(position) {
        return { x: 0, y: this.positionToCoordinate(position) };
    }
    /**
     * @ignore
     */
    updateLabel(label, position, endPosition, count) {
        if (label) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](position)) {
                position = 0;
            }
            let location = 0.5;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](count) && count > 1) {
                location = label.get("multiLocation", location);
            }
            else {
                location = label.get("location", location);
            }
            const opposite = this.get("opposite");
            const inside = label.get("inside", this.get("inside", false));
            if (opposite) {
                label.set("x", 0);
                if (inside) {
                    label.set("position", "absolute");
                }
                else {
                    label.set("position", "relative");
                }
            }
            else {
                if (inside) {
                    label.set("x", 0);
                    label.set("position", "absolute");
                }
                else {
                    label.set("x", undefined);
                    label.set("position", "relative");
                }
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            label.set("y", this.positionToCoordinate(position));
            this.toggleVisibility(label, position, label.get("minPosition", 0), label.get("maxPosition", 1));
        }
    }
    /**
     * @ignore
     */
    updateGrid(grid, position, endPosition) {
        if (grid) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](position)) {
                position = 0;
            }
            let location = grid.get("location", 0.5);
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            grid.set("y", this.positionToCoordinate(position));
            this.toggleVisibility(grid, position, 0, 1);
        }
    }
    /**
     * @ignore
     */
    updateTick(tick, position, endPosition, count) {
        if (tick) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](position)) {
                position = 0;
            }
            let location = 0.5;
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](count) && count > 1) {
                location = tick.get("multiLocation", location);
            }
            else {
                location = tick.get("location", location);
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endPosition) && endPosition != position) {
                position = position + (endPosition - position) * location;
            }
            tick.set("y", this.positionToCoordinate(position));
            let length = tick.get("length", 0);
            const inside = tick.get("inside", this.get("inside", false));
            if (this.get("opposite")) {
                tick.set("x", 0);
                if (inside) {
                    length *= -1;
                }
            }
            else {
                if (!inside) {
                    length *= -1;
                }
            }
            tick.set("draw", (display) => {
                display.moveTo(0, 0);
                display.lineTo(length, 0);
            });
            this.toggleVisibility(tick, position, tick.get("minPosition", 0), tick.get("maxPosition", 1));
        }
    }
    /**
     * @ignore
     */
    updateBullet(bullet, position, endPosition) {
        if (bullet) {
            const sprite = bullet.get("sprite");
            if (sprite) {
                if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](position)) {
                    position = 0;
                }
                let location = bullet.get("location", 0.5);
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endPosition) && endPosition != position) {
                    position = position + (endPosition - position) * location;
                }
                let bulletPosition = this.axis.roundAxisPosition(position, location);
                let previousBullet = this.axis._bullets[bulletPosition];
                let d = 1;
                if (this.get("opposite")) {
                    d = -1;
                }
                if (bullet.get("stacked")) {
                    if (previousBullet) {
                        let previousSprite = previousBullet.get("sprite");
                        if (previousSprite) {
                            sprite.set("x", previousSprite.x() + previousSprite.width() * d);
                        }
                    }
                    else {
                        sprite.set("x", 0);
                    }
                }
                this.axis._bullets[bulletPosition] = bullet;
                sprite.set("y", this.positionToCoordinate(position));
                this.toggleVisibility(sprite, position, 0, 1);
            }
        }
    }
    /**
     * @ignore
     */
    updateFill(fill, position, endPosition) {
        if (fill) {
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](position)) {
                position = 0;
            }
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endPosition)) {
                endPosition = 1;
            }
            let y0 = this.positionToCoordinate(position);
            let y1 = this.positionToCoordinate(endPosition);
            this.fillDrawMethod(fill, y0, y1);
        }
    }
    fillDrawMethod(fill, y0, y1) {
        fill.set("draw", (display) => {
            // using for holes, so can not be rectangle
            const w = this.axis.gridContainer.width();
            const h = this.height();
            if (y1 < y0) {
                [y1, y0] = [y0, y1];
            }
            if (y0 > h || y1 < 0) {
                return;
            }
            //y0 = Math.max(0, y0);
            //y1 = Math.min(h, y1);
            display.moveTo(0, y0);
            display.lineTo(w, y0);
            display.lineTo(w, y1);
            display.lineTo(0, y1);
            display.lineTo(0, y0);
        });
    }
    /**
     * Converts relative position (0-1) on axis to a pixel coordinate.
     *
     * @param position  Position (0-1)
     * @return Coordinate (px)
     */
    positionToCoordinate(position) {
        if (!this._inversed) {
            return (this._end - position) * this._axisLength;
        }
        else {
            return (position - this._start) * this._axisLength;
        }
    }
    /**
     * @ignore
     */
    positionTooltip(tooltip, position) {
        this._positionTooltip(tooltip, { x: 0, y: this.positionToCoordinate(position) });
    }
    /**
     * @ignore
     */
    updateTooltipBounds(tooltip) {
        const inside = this.get("inside");
        const num = 100000;
        let global = this._display.toGlobal({ x: 0, y: 0 });
        let y = global.y;
        let x = 0;
        let h = this.axisLength();
        let w = num;
        let pointerOrientation = "right";
        if (this.get("opposite")) {
            if (inside) {
                pointerOrientation = "right";
                x = global.x - num;
                w = num;
            }
            else {
                pointerOrientation = "left";
                x = global.x;
                w = num;
            }
        }
        else {
            if (inside) {
                pointerOrientation = "left";
                x = global.x;
                w = num;
            }
            else {
                pointerOrientation = "right";
                x = global.x - num;
                w = num;
            }
        }
        const bounds = { left: x, right: x + w, top: y, bottom: y + h };
        const oldBounds = tooltip.get("bounds");
        if (!_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__["sameBounds"](bounds, oldBounds)) {
            tooltip.set("bounds", bounds);
            tooltip.set("pointerOrientation", pointerOrientation);
        }
    }
    _updateLC() {
        const axis = this.axis;
        const parent = axis.parent;
        if (parent) {
            const h = parent.innerHeight();
            this._lc = this.axisLength() / h;
            this._ls = axis.y() / h;
        }
    }
    /**
     * @ignore
     */
    toAxisPosition(position) {
        const start = this._start || 0;
        const end = this._end || 1;
        position -= this._ls;
        position = position * (end - start) / this._lc;
        if (this.get("inversed")) {
            position = start + position;
        }
        else {
            position = end - position;
        }
        return position;
    }
    /**
     * @ignore
     */
    fixPosition(position) {
        if (!this.get("inversed")) {
            return 1 - position;
        }
        return position;
    }
}
Object.defineProperty(AxisRendererY, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisRendererY"
});
Object.defineProperty(AxisRendererY, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _AxisRenderer__WEBPACK_IMPORTED_MODULE_0__["AxisRenderer"].classNames.concat([AxisRendererY.className])
});
//# sourceMappingURL=AxisRendererY.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js ***!
  \*******************************************************************************/
/*! exports provided: AxisTick */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisTick", function() { return AxisTick; });
/* harmony import */ var _core_render_Tick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Tick */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js");

/**
 * Draws an axis tick.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Ticks} for more info
 * @important
 */
class AxisTick extends _core_render_Tick__WEBPACK_IMPORTED_MODULE_0__["Tick"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_tickPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
}
Object.defineProperty(AxisTick, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "AxisTick"
});
Object.defineProperty(AxisTick, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Tick__WEBPACK_IMPORTED_MODULE_0__["Tick"].classNames.concat([AxisTick.className])
});
//# sourceMappingURL=AxisTick.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js ***!
  \***********************************************************************************/
/*! exports provided: CategoryAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CategoryAxis", function() { return CategoryAxis; });
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Axis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_PopulateString__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/PopulateString */ "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js");






/**
 * Creates a category axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-axis/} for more info
 * @important
 */
class CategoryAxis extends _Axis__WEBPACK_IMPORTED_MODULE_0__["Axis"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_frequency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_itemMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__["mergeTags"](this._settings.themeTags, ["axis"]);
        this.fields.push("category");
        this.setPrivateRaw("name", "category");
        this.addTag("category");
        super._afterNew();
    }
    _prepareChildren() {
        super._prepareChildren();
        const len = this.dataItems.length;
        let i = 0;
        if (this._valuesDirty) {
            this._itemMap = {};
            _core_util_Array__WEBPACK_IMPORTED_MODULE_1__["each"](this.dataItems, (dataItem) => {
                dataItem.setRaw("index", i);
                this._itemMap[dataItem.get("category")] = dataItem;
                i++;
            });
            this.setPrivateRaw("maxZoomFactor", len);
        }
        this.setPrivateRaw("startIndex", Math.max(Math.round(this.get("start", 0) * len), 0));
        this.setPrivateRaw("endIndex", Math.min(Math.round(this.get("end", 1) * len), len));
        if (this._sizeDirty || this._valuesDirty || (this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("endIndex") || this.isPrivateDirty("startIndex") || this.isPrivateDirty("width") || this.isPrivateDirty("height"))) {
            if (this.dataItems.length > 0) {
                this._handleRangeChange();
                this._prepareAxisItems();
                this._updateAxisRanges();
            }
        }
    }
    _handleRangeChange() {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_1__["each"](this.series, (series) => {
            let startCategory = this.dataItems[this.startIndex()].get("category");
            let endCategory = this.dataItems[this.endIndex() - 1].get("category");
            let baseAxis = series.get("baseAxis");
            let xAxis = series.get("xAxis");
            let yAxis = series.get("yAxis");
            if (xAxis instanceof CategoryAxis && yAxis instanceof CategoryAxis) {
                series._markDirtyAxes();
            }
            else if (baseAxis === this) {
                let key;
                let openKey;
                let otherAxis = yAxis;
                if (xAxis === baseAxis) {
                    if (series.get("categoryXField")) {
                        key = "categoryX";
                    }
                    if (series.get("openCategoryXField")) {
                        openKey = "openCategoryX";
                    }
                }
                else if (yAxis === baseAxis) {
                    if (series.get("categoryYField")) {
                        key = "categoryY";
                    }
                    if (series.get("openCategoryYField")) {
                        openKey = "openCategoryY";
                    }
                    otherAxis = xAxis;
                }
                if (otherAxis.className == "ValueAxis") {
                    if (key || openKey) {
                        let startDataItem;
                        let endDataItem;
                        for (let i = 0, len = series.dataItems.length; i < len; i++) {
                            let dataItem = series.dataItems[i];
                            if (key) {
                                if (dataItem.get(key) === startCategory) {
                                    startDataItem = dataItem;
                                    break;
                                }
                            }
                            if (openKey) {
                                if (dataItem.get(openKey) === startCategory) {
                                    startDataItem = dataItem;
                                    break;
                                }
                            }
                        }
                        for (let i = series.dataItems.length - 1; i >= 0; i--) {
                            let dataItem = series.dataItems[i];
                            if (key) {
                                if (dataItem.get(key) === endCategory) {
                                    endDataItem = dataItem;
                                    break;
                                }
                            }
                            if (openKey) {
                                if (dataItem.get(openKey) === endCategory) {
                                    endDataItem = dataItem;
                                    break;
                                }
                            }
                        }
                        let startIndex = 0;
                        let endIndex = series.dataItems.length;
                        if (startDataItem) {
                            startIndex = series.dataItems.indexOf(startDataItem);
                        }
                        if (endDataItem) {
                            endIndex = series.dataItems.indexOf(endDataItem) + 1;
                        }
                        series.setPrivate("startIndex", startIndex);
                        series.setPrivate("endIndex", endIndex);
                        let hasValue = false;
                        for (let i = startIndex; i < endIndex; i++) {
                            const dataItem = series.dataItems[i];
                            _core_util_Array__WEBPACK_IMPORTED_MODULE_1__["each"](series.__valueXShowFields, (key) => {
                                let value = dataItem.get(key);
                                if (value != null) {
                                    hasValue = true;
                                }
                            });
                            _core_util_Array__WEBPACK_IMPORTED_MODULE_1__["each"](series.__valueYShowFields, (key) => {
                                let value = dataItem.get(key);
                                if (value != null) {
                                    hasValue = true;
                                }
                            });
                            if (hasValue) {
                                break;
                            }
                        }
                        series.setPrivate("outOfSelection", !hasValue);
                    }
                }
                series._markDirtyAxes(); // must be outside
            }
        });
    }
    _prepareAxisItems() {
        const renderer = this.get("renderer");
        const len = this.dataItems.length;
        let startIndex = this.startIndex();
        if (startIndex > 0) {
            startIndex--;
        }
        let endIndex = this.endIndex();
        if (endIndex < len) {
            endIndex++;
        }
        let maxCount = renderer.axisLength() / Math.max(renderer.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER);
        let frequency = Math.max(1, Math.min(len, Math.ceil((endIndex - startIndex) / maxCount)));
        startIndex = Math.floor(startIndex / frequency) * frequency;
        this._frequency = frequency;
        for (let j = 0; j < len; j++) {
            this.dataItems[j].hide();
        }
        let f = this.dataItems[startIndex].get("index", 0);
        for (let i = startIndex; i < endIndex; i = i + frequency) {
            let dataItem = this.dataItems[i];
            this._createAssets(dataItem, []);
            if (dataItem.isHidden()) {
                dataItem.show();
            }
            this._prepareDataItem(dataItem, f, frequency);
            f++;
        }
        this._updateGhost();
    }
    _prepareDataItem(dataItem, fillIndex, count) {
        let renderer = this.get("renderer");
        let categoryLocation = dataItem.get("categoryLocation", 0);
        let endCategoryLocation = dataItem.get("endCategoryLocation", 1);
        let index = dataItem.get("index");
        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](index)) {
            index = this.categoryToIndex(dataItem.get("category"));
        }
        let position = this.indexToPosition(index, categoryLocation);
        let endCategory = dataItem.get("endCategory");
        let endIndex;
        if (endCategory) {
            endIndex = this.categoryToIndex(endCategory);
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](endIndex)) {
                endIndex = index;
            }
        }
        else {
            endIndex = index;
        }
        let endPosition = this.indexToPosition(endIndex, endCategoryLocation);
        let fillEndIndex;
        let fillEndPosition;
        if (dataItem.get("isRange")) {
            fillEndIndex = endIndex;
        }
        else {
            fillEndIndex = index + this._frequency - 1;
        }
        fillEndPosition = this.indexToPosition(fillEndIndex, endCategoryLocation);
        renderer.updateLabel(dataItem.get("label"), position, endPosition, count);
        renderer.updateGrid(dataItem.get("grid"), position, endPosition);
        renderer.updateTick(dataItem.get("tick"), position, endPosition, count);
        renderer.updateFill(dataItem.get("axisFill"), position, fillEndPosition);
        this._processBullet(dataItem);
        renderer.updateBullet(dataItem.get("bullet"), position, endPosition);
        const fillRule = this.get("fillRule");
        if (fillRule) {
            fillRule(dataItem, fillIndex);
        }
    }
    startIndex() {
        let len = this.dataItems.length;
        return Math.min(Math.max(this.getPrivate("startIndex", 0), 0), len - 1);
    }
    endIndex() {
        let len = this.dataItems.length;
        return Math.max(1, Math.min(this.getPrivate("endIndex", len), len));
    }
    /**
     * @ignore
     */
    baseValue() {
    }
    /**
     * @ignore
     */
    basePosition() {
        return 0;
    }
    /**
     * Returns X coordinate in pixels corresponding to specific category index.
     *
     * @param   value  Index
     * @return         X coordinate
     */
    getX(value) {
        let axisDataItem = this._itemMap[value];
        if (axisDataItem) {
            return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get("index", 0)));
        }
        return NaN;
    }
    /**
     * Returns Y coordinate in pixels corresponding to specific category index.
     *
     * @param   value  Index
     * @return         Y coordinate
     */
    getY(value) {
        let axisDataItem = this._itemMap[value];
        if (axisDataItem) {
            return this._settings.renderer.positionToCoordinate(this.indexToPosition(axisDataItem.get("index", 0)));
        }
        return NaN;
    }
    /**
     * @ignore
     */
    getDataItemPositionX(dataItem, field, cellLocation, _axisLocation) {
        const category = dataItem.get(field);
        const axisDataItem = this._itemMap[category];
        if (axisDataItem) {
            return this.indexToPosition(axisDataItem.get("index", 0), cellLocation);
        }
        return NaN;
    }
    /**
     * @ignore
     */
    getDataItemCoordinateX(dataItem, field, cellLocation, _axisLocation) {
        return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, _axisLocation));
    }
    /**
     * @ignore
     */
    getDataItemPositionY(dataItem, field, cellLocation, _axisLocation) {
        const category = dataItem.get(field);
        const axisDataItem = this._itemMap[category];
        if (axisDataItem) {
            return this.indexToPosition(axisDataItem.get("index", 0), cellLocation);
        }
        return NaN;
    }
    /**
     * @ignore
     */
    getDataItemCoordinateY(dataItem, field, cellLocation, _axisLocation) {
        return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, _axisLocation));
    }
    /**
     * Converts category index to a relative position.
     *
     * `location` indicates relative position within category: 0 - start, 1 - end.
     *
     * If not set, will use middle (0.5) of the category.
     *
     * @param   index     Index
     * @param   location  Location
     * @return            Index
     */
    indexToPosition(index, location) {
        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](location)) {
            location = 0.5;
        }
        let len = this.dataItems.length;
        let startLocation = this.get("startLocation", 0);
        let endLocation = this.get("endLocation", 1);
        len -= startLocation;
        len -= (1 - endLocation);
        let position = (index + location - startLocation) / len;
        let dataItem = this.dataItems[index];
        if (dataItem) {
            position += dataItem.get("deltaPosition", 0);
        }
        return position;
    }
    /**
     * Returns an index of a category.
     *
     * @param   category  Category to look up
     * @return            Index
     */
    categoryToIndex(category) {
        let dataItem = this._itemMap[category];
        if (dataItem) {
            return dataItem.get("index");
        }
        return NaN;
    }
    /**
     * @ignore
     */
    dataItemToPosition(dataItem) {
        return this.indexToPosition(dataItem.get("index"));
    }
    /**
     * @ignore
     */
    roundAxisPosition(position, location) {
        position += (0.5 - location) / this.dataItems.length;
        return this.indexToPosition(this.axisPositionToIndex(position), location);
    }
    /**
     * Returns an index of the category that corresponds to specific pixel
     * position within axis.
     *
     * @param position  Position (px)
     * @return Category index
     */
    axisPositionToIndex(position) {
        let len = this.dataItems.length;
        return _core_util_Math__WEBPACK_IMPORTED_MODULE_3__["fitToRange"](Math.floor(position * len), 0, len - 1); //$math.fitToRange(Math.floor((end - start) * len * position + len * start), 0, len - 1);
    }
    /**
     * Returns text to be used in an axis tooltip for specific relative position.
     *
     * @param   position  Position
     * @return            Tooltip text
     */
    getTooltipText(position) {
        //@todo number formatter + tag
        const dataItem = this.dataItems[this.axisPositionToIndex(position)];
        if (dataItem) {
            const label = dataItem.get("label");
            if (label) {
                return Object(_core_util_PopulateString__WEBPACK_IMPORTED_MODULE_5__["populateString"])(label, this.get("tooltipText", ""));
            }
        }
    }
    _updateTooltipText(tooltip, position) {
        tooltip._setDataItem(this.dataItems[this.axisPositionToIndex(position)]);
        tooltip.label.text.markDirtyText();
    }
    /**
     * Returns a data item from series that is closest to the `position`.
     *
     * @param   series    Series
     * @param   position  Relative position
     * @return            Data item
     */
    getSeriesItem(series, position) {
        if (this.dataItems.length > 0) {
            let fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
            let index = this.axisPositionToIndex(position);
            // try simple first
            let seriesDataItem = series.dataItems[index];
            let axisDataItem = this.dataItems[index];
            let category = axisDataItem.get("category");
            if (seriesDataItem && axisDataItem) {
                if (seriesDataItem.get(fieldName) === category) {
                    return seriesDataItem;
                }
            }
            // if not found, try looking
            for (let i = 0, len = series.dataItems.length; i < len; i++) {
                let dataItem = series.dataItems[i];
                if (dataItem.get(fieldName) === category) {
                    return dataItem;
                }
            }
        }
    }
    /**
     * Zooms the axis to specific `start` and `end` indexes.
     *
     * Optional `duration` specifies duration of zoom animation in milliseconds.
     *
     * @param  start     Start index
     * @param  end       End index
     * @param  duration  Duration in milliseconds
     */
    zoomToIndexes(start, end, duration) {
        let len = this.dataItems.length;
        this.zoom(start / len, end / len, duration);
    }
    zoomToCategories(startCategory, endCategory, duration) {
        this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1, duration);
    }
    /**
     * Returns position span between start and end of a single cell in axis.
     *
     * @since 5.2.30
     * @return Position
     */
    getCellWidthPosition() {
        return this._frequency / this.dataItems.length / (this.get("end", 1) - this.get("start", 0));
    }
}
Object.defineProperty(CategoryAxis, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "CategoryAxis"
});
Object.defineProperty(CategoryAxis, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Axis__WEBPACK_IMPORTED_MODULE_0__["Axis"].classNames.concat([CategoryAxis.className])
});
//# sourceMappingURL=CategoryAxis.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryDateAxis.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryDateAxis.js ***!
  \***************************************************************************************/
/*! exports provided: CategoryDateAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CategoryDateAxis", function() { return CategoryDateAxis; });
/* harmony import */ var _CategoryAxis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CategoryAxis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js");
/* harmony import */ var _core_util_Time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Time */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");





/**
 * Category-based date axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-date-axis/} for more info
 * @important
 */
class CategoryDateAxis extends _CategoryAxis__WEBPACK_IMPORTED_MODULE_0__["CategoryAxis"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_frequency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_itemMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__["mergeTags"](this._settings.themeTags, ["axis"]);
        this.fields.push("category");
        super._afterNew();
    }
    _prepareAxisItems() {
        // temp
        this.setPrivateRaw("baseInterval", this.get("baseInterval"));
        const renderer = this.get("renderer");
        const len = this.dataItems.length;
        let startIndex = this.startIndex();
        if (startIndex > 0) {
            startIndex--;
        }
        let endIndex = this.endIndex();
        if (endIndex < len) {
            endIndex++;
        }
        let maxCount = renderer.axisLength() / Math.max(renderer.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER);
        let frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));
        startIndex = Math.floor(startIndex / frequency) * frequency;
        this._frequency = frequency;
        for (let j = 0; j < len; j++) {
            this.dataItems[j].hide();
        }
        let startTime = Number(this.dataItems[startIndex].get("category"));
        let endTime = Number(this.dataItems[endIndex - 1].get("category"));
        let realDuration = (endTime - startTime);
        if (endIndex - startIndex < maxCount) {
            realDuration = (endTime - startTime) - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();
        }
        // if all items are on axis
        let gridInterval = _core_util_Time__WEBPACK_IMPORTED_MODULE_1__["chooseInterval"](0, realDuration, maxCount, this.get("gridIntervals"));
        const nextGridUnit = _core_util_Time__WEBPACK_IMPORTED_MODULE_1__["getNextUnit"](gridInterval.timeUnit);
        const baseInterval = this.getPrivate("baseInterval");
        if (_core_util_Time__WEBPACK_IMPORTED_MODULE_1__["getIntervalDuration"](gridInterval) < this.baseDuration()) {
            gridInterval = Object.assign({}, baseInterval);
        }
        const formats = this.get("dateFormats");
        let previousValue = -Infinity;
        let previousIndex = -Infinity;
        let previousUnitValue = -Infinity;
        let format;
        let selectedItems = [];
        let changed = false;
        for (let i = startIndex; i < endIndex; i++) {
            let dataItem = this.dataItems[i];
            let index = dataItem.get("index");
            let skip = false;
            let value = Number(dataItem.get("category"));
            let date = new Date(value);
            let unitValue = _core_util_Time__WEBPACK_IMPORTED_MODULE_1__["getUnitValue"](date, gridInterval.timeUnit);
            format = formats[gridInterval.timeUnit];
            let added = false;
            if (gridInterval.timeUnit != "year" && gridInterval.timeUnit != "week") {
                if (nextGridUnit && this.get("markUnitChange") && _core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](previousValue)) {
                    if (_core_util_Time__WEBPACK_IMPORTED_MODULE_1__["checkChange"](value, previousValue, nextGridUnit, this._root.utc)) {
                        format = this.get("periodChangeDateFormats")[gridInterval.timeUnit];
                        if (index - frequency * 0.5 < previousIndex) {
                            selectedItems.pop();
                        }
                        selectedItems.push({ format: format, dataItem: dataItem });
                        changed = true;
                        added = true;
                        previousIndex = index;
                        previousUnitValue = unitValue;
                    }
                }
            }
            let shouldAdd = false;
            if (gridInterval.timeUnit === "day" || gridInterval.timeUnit === "week") {
                if (index - previousIndex >= frequency) {
                    shouldAdd = true;
                }
            }
            else {
                if (unitValue % gridInterval.count === 0) {
                    if (unitValue != previousUnitValue) {
                        shouldAdd = true;
                    }
                }
            }
            if (!added && shouldAdd) {
                if (index - frequency * 0.7 < previousIndex) {
                    if (changed) {
                        skip = true;
                    }
                }
                if (!skip) {
                    selectedItems.push({ format: format, dataItem: dataItem });
                    previousIndex = index;
                    previousUnitValue = unitValue;
                }
                changed = false;
            }
            previousValue = value;
        }
        if (selectedItems.length > 0) {
            let f = selectedItems[0].dataItem.get("index", 0);
            _core_util_Array__WEBPACK_IMPORTED_MODULE_3__["each"](selectedItems, (item) => {
                const dataItem = item.dataItem;
                const format = item.format;
                this._createAssets(dataItem, []);
                if (dataItem.isHidden()) {
                    dataItem.show();
                }
                let value = Number(dataItem.get("category"));
                let date = new Date(value);
                const label = dataItem.get("label");
                if (label) {
                    label.set("text", this._root.dateFormatter.format(date, format));
                }
                f++;
                this._prepareDataItem(dataItem, f, frequency);
            });
        }
    }
    /**
     * Returns a duration of currently active `baseInterval` in milliseconds.
     *
     * @return Duration
     */
    baseDuration() {
        return _core_util_Time__WEBPACK_IMPORTED_MODULE_1__["getIntervalDuration"](this.getPrivate("baseInterval"));
    }
    /**
     * Returns text to be used in an axis tooltip for specific relative position.
     *
     * @param   position  Position
     * @return            Tooltip text
     */
    getTooltipText(position) {
        //@todo number formatter + tag
        let dataItem = this.dataItems[this.axisPositionToIndex(position)];
        if (dataItem) {
            let format = this.get("dateFormats")[this.getPrivate("baseInterval").timeUnit];
            return this._root.dateFormatter.format(new Date(dataItem.get("category", 0)), this.get("tooltipDateFormat", format));
        }
    }
    _updateTooltipText(tooltip, position) {
        tooltip.label.set("text", this.getTooltipText(position));
    }
}
Object.defineProperty(CategoryDateAxis, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "CategoryDateAxis"
});
Object.defineProperty(CategoryDateAxis, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _CategoryAxis__WEBPACK_IMPORTED_MODULE_0__["CategoryAxis"].classNames.concat([CategoryDateAxis.className])
});
//# sourceMappingURL=CategoryDateAxis.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/DateAxis.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/DateAxis.js ***!
  \*******************************************************************************/
/*! exports provided: DateAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateAxis", function() { return DateAxis; });
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _ValueAxis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ValueAxis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Order__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Order */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_Time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/util/Time */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js");








/**
 * Creates a date axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info
 * @important
 */
class DateAxis extends _ValueAxis__WEBPACK_IMPORTED_MODULE_1__["ValueAxis"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_dataGrouped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_seriesDataGrouped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_groupingCalculated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_intervalDuration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_baseDuration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_intervalMax", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_intervalMin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this._settings.themeTags, ["axis"]);
        super._afterNew();
        this._setBaseInterval(this.get("baseInterval"));
        this.on("baseInterval", () => {
            this._setBaseInterval(this.get("baseInterval"));
        });
    }
    _setBaseInterval(interval) {
        this.setPrivateRaw("baseInterval", interval);
        this._baseDuration = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getIntervalDuration"](interval);
    }
    _fixZoomFactor() {
        var maxZoomFactor = this.get("maxZoomFactor");
        if (maxZoomFactor != null && maxZoomFactor != Infinity) {
            this.setPrivateRaw("maxZoomFactor", maxZoomFactor);
        }
        else {
            this.setPrivateRaw("maxZoomFactor", Math.round((this.getPrivate("max", 0) - this.getPrivate("min", 0)) / this.baseMainDuration()));
        }
    }
    _groupData() {
        const min = this.getPrivate("min");
        const max = this.getPrivate("max");
        if ((_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](min) && _core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](max))) {
            this._fixZoomFactor();
            const groupInterval = this.getPrivate("groupInterval");
            if (groupInterval) {
                this._setBaseInterval(groupInterval);
            }
            else {
                this._setBaseInterval(this.get("baseInterval"));
            }
            if (this.isDirty("groupInterval")) {
                let groupInterval = this.get("groupInterval");
                if (groupInterval) {
                    this.setRaw("groupIntervals", [groupInterval]);
                }
            }
            if (this.isDirty("groupData")) {
                if (!this._dataGrouped) {
                    if (this.get("groupData")) {
                        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.series, (series) => {
                            this._groupSeriesData(series);
                        });
                        this._handleRangeChange();
                    }
                    else {
                        let baseInterval = this.get("baseInterval");
                        let mainDataSetId = baseInterval.timeUnit + baseInterval.count;
                        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.series, (series) => {
                            series.setDataSet(mainDataSetId);
                        });
                        this._setBaseInterval(baseInterval);
                        this.setPrivateRaw("groupInterval", undefined);
                        this.markDirtyExtremes();
                    }
                    this._dataGrouped = true;
                }
            }
        }
    }
    _groupSeriesData(series) {
        if (this.get("groupData") && !series.get("groupDataDisabled")) {
            this._dataGrouped = true; // helps to avoid double grouping
            this._seriesDataGrouped = true;
            // make array of intervals which will be used;
            let intervals = [];
            let baseDuration = this.baseMainDuration();
            let groupIntervals = this.get("groupIntervals");
            if (groupIntervals) { }
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](groupIntervals, (interval) => {
                let intervalDuration = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getIntervalDuration"](interval);
                if (intervalDuration > baseDuration) {
                    intervals.push(interval);
                }
            });
            series._dataSets = {};
            const key = this.getPrivate("name") + this.get("renderer").getPrivate("letter");
            let fields;
            const baseAxis = series.get("baseAxis");
            if (series.get("xAxis") === baseAxis) {
                fields = series._valueYFields;
            }
            else if (series.get("yAxis") === baseAxis) {
                fields = series._valueXFields;
            }
            let dataItems = series._mainDataItems;
            let baseInterval = this.get("baseInterval");
            let mainDataSetId = baseInterval.timeUnit + baseInterval.count;
            series._dataSets[mainDataSetId] = dataItems;
            const groupCallback = series.get("groupDataCallback");
            let groupOriginals = series.get("groupDataWithOriginals", false);
            if (groupCallback) {
                groupOriginals = true;
            }
            const firstDay = this._root.locale.firstDayOfWeek;
            const utc = this._root.utc;
            const timezone = this._root.timezone;
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](intervals, (interval) => {
                let previousTime = -Infinity;
                let dataSetId = interval.timeUnit + interval.count;
                series._dataSets[dataSetId] = [];
                let newDataItem;
                let sum = {};
                let count = {};
                let groupFieldValues = {};
                let workingFields = {};
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](fields, (field) => {
                    sum[field] = 0;
                    count[field] = 0;
                    groupFieldValues[field] = series.get((field + "Grouped"));
                    workingFields[field] = field + "Working";
                });
                let intervalDuration = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getDuration"](interval.timeUnit);
                let firstItem = dataItems[0];
                let firstDate;
                if (firstItem) {
                    firstDate = new Date(dataItems[0].get(key));
                }
                let prevNewDataItem;
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](dataItems, (dataItem) => {
                    let time = dataItem.get(key);
                    let roundedTime = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(time), interval.timeUnit, interval.count, firstDay, utc, firstDate, timezone).getTime();
                    let dataContext;
                    if (previousTime < roundedTime - intervalDuration / 24) {
                        dataContext = _core_util_Object__WEBPACK_IMPORTED_MODULE_5__["copy"](dataItem.dataContext);
                        newDataItem = new _core_render_Component__WEBPACK_IMPORTED_MODULE_0__["DataItem"](series, dataContext, series._makeDataItem(dataContext));
                        newDataItem.setRaw(key, roundedTime);
                        series._dataSets[dataSetId].push(newDataItem);
                        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](fields, (field) => {
                            let value = dataItem.get(field);
                            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](value)) {
                                newDataItem.setRaw(field, value);
                                newDataItem.setRaw(workingFields[field], value);
                                count[field] = 1;
                                sum[field] = value;
                            }
                            else {
                                sum[field] = 0;
                                count[field] = 0;
                            }
                        });
                        if (groupOriginals) {
                            newDataItem.set("originals", [dataItem]);
                        }
                        if (groupCallback && prevNewDataItem) {
                            groupCallback(prevNewDataItem, interval);
                        }
                        prevNewDataItem = newDataItem;
                    }
                    else {
                        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](fields, (field) => {
                            let groupKey = groupFieldValues[field];
                            let value = dataItem.get(field);
                            if (value !== undefined) {
                                let currentValue = newDataItem.get(field);
                                switch (groupKey) {
                                    case "close":
                                        newDataItem.setRaw(field, value);
                                        break;
                                    case "sum":
                                        if (value != null) {
                                            newDataItem.setRaw(field, currentValue + value);
                                        }
                                        break;
                                    case "open":
                                        break;
                                    case "low":
                                        if (value < currentValue) {
                                            newDataItem.setRaw(field, value);
                                        }
                                        break;
                                    case "high":
                                        if (value > currentValue) {
                                            newDataItem.setRaw(field, value);
                                        }
                                        break;
                                    case "average":
                                        count[field]++;
                                        sum[field] += value;
                                        let average = sum[field] / count[field];
                                        newDataItem.setRaw(field, average);
                                        break;
                                    case "extreme":
                                        if (Math.abs(value) > Math.abs(currentValue)) {
                                            newDataItem.setRaw(field, value);
                                        }
                                        break;
                                }
                                newDataItem.setRaw(workingFields[field], newDataItem.get(field));
                                let dataContext = _core_util_Object__WEBPACK_IMPORTED_MODULE_5__["copy"](dataItem.dataContext);
                                dataContext[key] = roundedTime;
                                newDataItem.dataContext = dataContext;
                            }
                        });
                        if (groupOriginals) {
                            newDataItem.get("originals").push(dataItem);
                        }
                    }
                    previousTime = roundedTime;
                });
                if (groupCallback && prevNewDataItem) {
                    groupCallback(prevNewDataItem, interval);
                }
            });
            if (series._dataSetId) {
                series.setDataSet(series._dataSetId);
            }
            this.markDirtySize();
        }
    }
    _clearDirty() {
        super._clearDirty();
        this._groupingCalculated = false;
        this._dataGrouped = false;
    }
    /**
     * Returns a time interval axis would group data to for a specified duration.
     *
     * @since 5.2.1
     */
    getGroupInterval(duration) {
        let baseInterval = this.get("baseInterval");
        let groupInterval = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["chooseInterval"](0, duration, this.get("groupCount", Infinity), this.get("groupIntervals"));
        if (_core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getIntervalDuration"](groupInterval) < _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getIntervalDuration"](baseInterval)) {
            groupInterval = Object.assign({}, baseInterval);
        }
        return groupInterval;
    }
    /**
     * Return `max` of a specified time interval.
     *
     * Will work only if the axis was grouped to this interval at least once.
     *
     * @since 5.2.1
     * @param   interval  Interval
     * @return            Max
     */
    getIntervalMax(interval) {
        return this._intervalMax[interval.timeUnit + interval.count];
    }
    /**
     * Return `min` of a specified time interval.
     *
     * Will work only if the axis was grouped to this interval at least once.
     *
     * @since 5.2.1
     * @param   interval  Interval
     * @return            Min
     */
    getIntervalMin(interval) {
        return this._intervalMin[interval.timeUnit + interval.count];
    }
    _handleRangeChange() {
        super._handleRangeChange();
        let selectionMin = Math.round(this.getPrivate("selectionMin"));
        let selectionMax = Math.round(this.getPrivate("selectionMax"));
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](selectionMin) && _core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](selectionMax)) {
            if (this.get("endLocation") == 0) {
                selectionMax += 1;
            }
            if (this.get("groupData") && !this._groupingCalculated) {
                this._groupingCalculated = true;
                let modifiedDifference = (selectionMax - selectionMin) + (this.get("startLocation", 0) + (1 - this.get("endLocation", 1)) * this.baseDuration());
                let groupInterval = this.get("groupInterval");
                if (!groupInterval) {
                    groupInterval = this.getGroupInterval(modifiedDifference);
                }
                let current = this.getPrivate("groupInterval");
                if (groupInterval && (!current || (current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count) || this._seriesDataGrouped)) {
                    this._seriesDataGrouped = false;
                    this.setPrivateRaw("groupInterval", groupInterval);
                    this._setBaseInterval(groupInterval);
                    let newId = groupInterval.timeUnit + groupInterval.count;
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.series, (series) => {
                        if (series.get("baseAxis") === this) {
                            series.setDataSet(newId);
                        }
                    });
                    this.markDirtyExtremes();
                    this._root.events.once("frameended", () => {
                        this._root.events.once("frameended", () => {
                            const type = "groupintervalchanged";
                            if (this.events.isEnabled(type)) {
                                this.events.dispatch(type, { type: type, target: this });
                            }
                        });
                    });
                }
            }
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.series, (series) => {
                if (series.get("baseAxis") === this) {
                    let fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
                    const start = _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["getSortedIndex"](series.dataItems, (dataItem) => {
                        return _core_util_Order__WEBPACK_IMPORTED_MODULE_3__["compare"](dataItem.get(fieldName), selectionMin);
                    });
                    let startIndex = start.index;
                    if (startIndex > 0) {
                        startIndex -= 1;
                    }
                    selectionMax += this.baseDuration() * (1 - this.get("endLocation", 1));
                    const end = _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["getSortedIndex"](series.dataItems, (dataItem) => {
                        return _core_util_Order__WEBPACK_IMPORTED_MODULE_3__["compare"](dataItem.get(fieldName), selectionMax);
                    });
                    let endIndex = end.index;
                    let endIndex2 = endIndex;
                    if (endIndex2 > 0) {
                        endIndex2--;
                    }
                    const firstDataItem = series.dataItems[startIndex];
                    const lastDataItem = series.dataItems[endIndex2];
                    let lastDate;
                    let firstDate;
                    if (firstDataItem) {
                        firstDate = firstDataItem.get(fieldName);
                    }
                    if (lastDataItem) {
                        lastDate = lastDataItem.get(fieldName);
                    }
                    let outOfSelection = false;
                    if (lastDate != null && firstDate != null) {
                        if (lastDate < selectionMin || firstDate > selectionMax) {
                            outOfSelection = true;
                        }
                    }
                    series.setPrivate("outOfSelection", outOfSelection);
                    series.setPrivate("startIndex", startIndex);
                    series.setPrivate("endIndex", endIndex);
                }
            });
        }
    }
    _adjustMinMax(min, max, gridCount, _strictMode) {
        return { min: min, max: max, step: (max - min) / gridCount };
    }
    /**
     * @ignore
     */
    intervalDuration() {
        return this._intervalDuration;
    }
    _saveMinMax(min, max) {
        let groupInterval = this.getPrivate("groupInterval");
        if (!groupInterval) {
            groupInterval = this.get("baseInterval");
        }
        let id = groupInterval.timeUnit + groupInterval.count;
        this._intervalMin[id] = min;
        this._intervalMax[id] = max;
    }
    _getM(timeUnit) {
        if (timeUnit == "month" || timeUnit == "year" || timeUnit == "day") {
            return 1.05;
        }
        return 1.01;
    }
    _prepareAxisItems() {
        const min = this.getPrivate("min");
        const max = this.getPrivate("max");
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](min) && _core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](max)) {
            const selectionMin = Math.round(this.getPrivate("selectionMin"));
            const selectionMax = Math.round(this.getPrivate("selectionMax"));
            const renderer = this.get("renderer");
            const baseInterval = this.getPrivate("baseInterval");
            let value = selectionMin;
            let i = 0;
            const intervals = this.get("gridIntervals");
            let gridInterval = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["chooseInterval"](0, selectionMax - selectionMin, renderer.gridCount(), intervals);
            if (_core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getIntervalDuration"](gridInterval) < this.baseDuration()) {
                gridInterval = Object.assign({}, baseInterval);
            }
            const intervalDuration = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getIntervalDuration"](gridInterval);
            this._intervalDuration = intervalDuration;
            const nextGridUnit = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getNextUnit"](gridInterval.timeUnit);
            const firstDay = this._root.locale.firstDayOfWeek;
            const utc = this._root.utc;
            const timezone = this._root.timezone;
            value = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, firstDay, utc, new Date(min), timezone).getTime();
            let previousValue = value - intervalDuration;
            let format;
            const formats = this.get("dateFormats");
            this.setPrivateRaw("gridInterval", gridInterval);
            while (value < selectionMax + intervalDuration) {
                let dataItem;
                if (this.dataItems.length < i + 1) {
                    dataItem = new _core_render_Component__WEBPACK_IMPORTED_MODULE_0__["DataItem"](this, undefined, {});
                    this._dataItems.push(dataItem);
                    this.processDataItem(dataItem);
                }
                else {
                    dataItem = this.dataItems[i];
                }
                this._createAssets(dataItem, []);
                if (dataItem.isHidden()) {
                    dataItem.show();
                }
                dataItem.setRaw("value", value);
                let endValue = value + _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getDuration"](gridInterval.timeUnit, gridInterval.count * this._getM(gridInterval.timeUnit));
                endValue = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(endValue), gridInterval.timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
                dataItem.setRaw("endValue", endValue);
                let date = new Date(value);
                format = formats[gridInterval.timeUnit];
                if (nextGridUnit && this.get("markUnitChange") && _core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](previousValue)) {
                    if (gridInterval.timeUnit != "year") {
                        if (_core_util_Time__WEBPACK_IMPORTED_MODULE_7__["checkChange"](value, previousValue, nextGridUnit, utc, timezone)) {
                            format = this.get("periodChangeDateFormats")[gridInterval.timeUnit];
                        }
                    }
                }
                const label = dataItem.get("label");
                if (label) {
                    label.set("text", this._root.dateFormatter.format(date, format));
                }
                this._prepareDataItem(dataItem, gridInterval.count);
                previousValue = value;
                value = endValue;
                if (value == previousValue) {
                    break;
                }
                i++;
            }
            for (let j = i; j < this.dataItems.length; j++) {
                this.dataItems[j].hide();
            }
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.series, (series) => {
                if (series.inited) {
                    series._markDirtyAxes();
                }
            });
        }
        this._updateGhost();
    }
    _updateFinals(start, end) {
        this.setPrivateRaw("selectionMinFinal", this.positionToValue(start));
        this.setPrivateRaw("selectionMaxFinal", this.positionToValue(end));
    }
    _getDelta() {
        this._deltaMinMax = this.baseDuration() / 2;
    }
    _fixMin(min) {
        const baseInterval = this.getPrivate("baseInterval");
        const firstDay = this._root.locale.firstDayOfWeek;
        const timezone = this._root.timezone;
        const utc = this._root.utc;
        const timeUnit = baseInterval.timeUnit;
        let startTime = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(min), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();
        let endTime = startTime + _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getDuration"](timeUnit, baseInterval.count * this._getM(timeUnit));
        endTime = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
        return startTime + (endTime - startTime) * this.get("startLocation", 0);
    }
    _fixMax(max) {
        const baseInterval = this.getPrivate("baseInterval");
        const firstDay = this._root.locale.firstDayOfWeek;
        const timezone = this._root.timezone;
        const utc = this._root.utc;
        const timeUnit = baseInterval.timeUnit;
        let startTime = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(max), timeUnit, baseInterval.count, firstDay, utc, undefined, timezone).getTime();
        let endTime = startTime + _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getDuration"](timeUnit, baseInterval.count * this._getM(timeUnit));
        endTime = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
        return startTime + (endTime - startTime) * this.get("endLocation", 1);
    }
    _updateDates(_date) {
    }
    /**
     * Returns a duration of currently active `baseInterval` in milliseconds.
     *
     * @return Duration
     */
    baseDuration() {
        return this._baseDuration;
        //return $time.getIntervalDuration(this.getPrivate("baseInterval"));
    }
    /**
     * Returns a duration of user-defined `baseInterval` in milliseconds.
     *
     * @return Duration
     */
    baseMainDuration() {
        return _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getIntervalDuration"](this.get("baseInterval"));
    }
    /**
     * @ignore
     */
    processSeriesDataItem(dataItem, fields) {
        const baseInterval = this.getPrivate("baseInterval");
        if (!dataItem.open) {
            dataItem.open = {};
        }
        if (!dataItem.close) {
            dataItem.close = {};
        }
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](fields, (field) => {
            let value = dataItem.get(field);
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](value)) {
                let startTime = dataItem.open[field];
                let endTime = dataItem.close[field];
                // this is done to save cpu, as rounding is quite expensive, especially with timezone set. 
                // if value is between prev start and end, it means it didn't change, all is fine.
                if (value >= startTime && value <= endTime) {
                }
                else {
                    const firstDay = this._root.locale.firstDayOfWeek;
                    const utc = this._root.utc;
                    const timezone = this._root.timezone;
                    const timeUnit = baseInterval.timeUnit;
                    const count = baseInterval.count;
                    startTime = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(value), timeUnit, count, firstDay, utc, undefined, timezone).getTime();
                    endTime = startTime + _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getDuration"](timeUnit, count * this._getM(timeUnit));
                    endTime = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(endTime), timeUnit, 1, firstDay, utc, undefined, timezone).getTime();
                    dataItem.open[field] = startTime;
                    dataItem.close[field] = endTime;
                }
                this._updateDates(startTime);
            }
        });
    }
    /**
     * @ignore
     */
    getDataItemPositionX(dataItem, field, cellLocation, axisLocation) {
        let openValue;
        let closeValue;
        if (dataItem.open && dataItem.close) {
            openValue = dataItem.open[field];
            closeValue = dataItem.close[field];
        }
        else {
            openValue = dataItem.get(field);
            closeValue = openValue;
        }
        let value = openValue + (closeValue - openValue) * cellLocation;
        value = this._baseValue + (value - this._baseValue) * axisLocation;
        return this.valueToPosition(value);
    }
    /**
     * @ignore
     */
    getDataItemCoordinateX(dataItem, field, cellLocation, axisLocation) {
        return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));
    }
    /**
     * @ignore
     */
    getDataItemPositionY(dataItem, field, cellLocation, axisLocation) {
        let openValue;
        let closeValue;
        if (dataItem.open && dataItem.close) {
            openValue = dataItem.open[field];
            closeValue = dataItem.close[field];
        }
        else {
            openValue = dataItem.get(field);
            closeValue = openValue;
        }
        let value = openValue + (closeValue - openValue) * cellLocation;
        value = this._baseValue + (value - this._baseValue) * axisLocation;
        return this.valueToPosition(value);
    }
    /**
     * @ignore
     */
    getDataItemCoordinateY(dataItem, field, cellLocation, axisLocation) {
        return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));
    }
    /**
     * @ignore
     */
    roundAxisPosition(position, location) {
        let value = this.positionToValue(position);
        value = value - (location - 0.5) * this.baseDuration();
        let baseInterval = this.getPrivate("baseInterval");
        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNaN"](value)) {
            const firstDay = this._root.locale.firstDayOfWeek;
            const timeUnit = baseInterval.timeUnit;
            const utc = this._root.utc;
            const timezone = this._root.timezone;
            const count = baseInterval.count;
            value = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(value), timeUnit, count, firstDay, utc, new Date(this.getPrivate("min", 0)), timezone).getTime();
            let duration = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getDateIntervalDuration"](baseInterval, new Date(value), firstDay, utc, timezone);
            if (timezone) {
                value = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["round"](new Date(value + this.baseDuration() * 0.05), timeUnit, count, firstDay, utc, new Date(this.getPrivate("min", 0)), timezone).getTime();
                duration = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getDateIntervalDuration"](baseInterval, new Date(value + duration * location), firstDay, utc, timezone);
            }
            return this.valueToPosition(value + duration * location);
        }
        return NaN;
    }
    /**
     * Returns text to be used in an axis tooltip for specific relative position.
     *
     * @param   position  Position
     * @return            Tooltip text
     */
    getTooltipText(position) {
        //@todo number formatter + tag
        if (this.getPrivate("min") != null) {
            let format = this.get("tooltipDateFormats")[this.getPrivate("baseInterval").timeUnit];
            let value = this.positionToValue(position);
            let date = new Date(value);
            let baseInterval = this.getPrivate("baseInterval");
            let duration = _core_util_Time__WEBPACK_IMPORTED_MODULE_7__["getDateIntervalDuration"](baseInterval, date, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);
            return this._root.dateFormatter.format(new Date(value + this.get("tooltipIntervalOffset", -this.get("tooltipLocation", 0.5)) * duration), this.get("tooltipDateFormat", format));
        }
        return "";
    }
    /**
     * Returns a data item from series that is closest to the `position`.
     *
     * @param   series    Series
     * @param   position  Relative position
     * @return            Data item
     */
    getSeriesItem(series, position, location) {
        let fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
        let value = this.positionToValue(position);
        if (location == null) {
            location = 0.5;
        }
        value = value - (location - 0.5) * this.baseDuration();
        const result = _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["getSortedIndex"](series.dataItems, (dataItem) => {
            var diValue = 0;
            if (dataItem.open) {
                diValue = dataItem.open[fieldName];
            }
            return _core_util_Order__WEBPACK_IMPORTED_MODULE_3__["compare"](diValue, value);
        });
        if (series.get("snapTooltip")) {
            let first = series.dataItems[result.index - 1];
            let second = series.dataItems[result.index];
            if (first && second) {
                if (first.open && second.close) {
                    let open = first.open[fieldName];
                    let close = second.close[fieldName];
                    if (Math.abs(value - open) > Math.abs(value - close)) {
                        return second;
                    }
                }
            }
            if (first) {
                return first;
            }
            if (second) {
                return second;
            }
        }
        else {
            // @todo check if is in range
            const dataItem = series.dataItems[result.index - 1];
            if (dataItem) {
                if (dataItem.open && dataItem.close) {
                    let open = dataItem.open[fieldName];
                    let close = dataItem.close[fieldName];
                    if (value >= open && value <= close) {
                        return dataItem;
                    }
                }
            }
        }
    }
    /**
     * @ignore
     */
    shouldGap(dataItem, nextItem, autoGapCount, fieldName) {
        const value1 = dataItem.get(fieldName);
        const value2 = nextItem.get(fieldName);
        if (value2 - value1 > this.baseDuration() * autoGapCount) {
            return true;
        }
        return false;
    }
    /**
     * Zooms the axis to specific `start` and `end` dates.
     *
     * Optional `duration` specifies duration of zoom animation in milliseconds.
     *
     * @param  start     Start Date
     * @param  end       End Date
     * @param  duration  Duration in milliseconds
     */
    zoomToDates(start, end, duration) {
        this.zoomToValues(start.getTime(), end.getTime(), duration);
    }
    /**
     * Returns a `Date` object corresponding to specific position within plot
     * area.
     *
     * @param   position  Pposition
     * @return            Date
     */
    positionToDate(position) {
        return new Date(this.positionToValue(position));
    }
    /**
     * Returns a relative position within plot area that corresponds to specific
     * date.
     *
     * @param   date  Date
     * @return        Position
     */
    dateToPosition(date) {
        return this.valueToPosition(date.getTime());
    }
    /**
     * Returns relative position between two grid lines of the axis.
     *
     * @since 5.2.30
     * @return Position
     */
    getCellWidthPosition() {
        let max = this.getPrivate("selectionMax", this.getPrivate("max"));
        let min = this.getPrivate("selectionMin", this.getPrivate("min"));
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](max) && _core_util_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](min)) {
            return this._intervalDuration / (max - min);
        }
        return 0.05;
    }
}
Object.defineProperty(DateAxis, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "DateAxis"
});
Object.defineProperty(DateAxis, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _ValueAxis__WEBPACK_IMPORTED_MODULE_1__["ValueAxis"].classNames.concat([DateAxis.className])
});
//# sourceMappingURL=DateAxis.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/DurationAxis.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/DurationAxis.js ***!
  \***********************************************************************************/
/*! exports provided: DurationAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DurationAxis", function() { return DurationAxis; });
/* harmony import */ var _ValueAxis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ValueAxis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");



/**
 * Creates a duration axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info
 * @important
 */
class DurationAxis extends _ValueAxis__WEBPACK_IMPORTED_MODULE_0__["ValueAxis"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_dataGrouped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_groupingCalculated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_intervalDuration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__["mergeTags"](this._settings.themeTags, ["axis"]);
        super._afterNew();
    }
    _adjustMinMax(min, max, gridCount, strictMode) {
        let minMaxStep;
        const durationFormatter = this.getDurationFormatter();
        const baseUnit = this.get("baseUnit");
        // we don't allow to go to smaller units, setting so to avoid invalidation
        this.setRaw("maxPrecision", 0);
        if (baseUnit == "millisecond" || baseUnit == "second" || baseUnit == "minute" || baseUnit == "hour") {
            // will fail if 0
            if (gridCount <= 1) {
                gridCount = 1;
            }
            gridCount = Math.round(gridCount);
            //let initialMin: number = min;
            //let initialMax: number = max;
            let difference = max - min;
            // in case min and max is the same, use max
            if (difference === 0) {
                difference = Math.abs(max);
            }
            let step = difference / gridCount;
            let divisors = [60, 30, 20, 15, 10, 2, 1];
            let realDivisor = 1;
            if (baseUnit == "hour") {
                divisors = [24, 12, 6, 4, 2, 1];
            }
            for (let divisor of divisors) {
                if (difference / divisor > gridCount) {
                    realDivisor = divisor;
                    break;
                }
            }
            let count = Math.ceil(((max - min) / realDivisor) / gridCount);
            let exponent = Math.log(Math.abs(count)) * Math.LOG10E;
            let power = Math.pow(10, Math.floor(exponent)) / 10;
            let reducedCount = count / power;
            // find closest to divisor
            let closest = _core_util_Math__WEBPACK_IMPORTED_MODULE_2__["closest"](divisors, reducedCount);
            count = closest * power;
            step = realDivisor * count;
            min = Math.floor(min / step) * step;
            max = Math.ceil(max / step) * step;
            /*
            causese SO with seconds
            if (strictMode) {
                min -= step;
                if (min < 0 && initialMin >= 0) {
                    min = 0;
                }
                max += step;

                if (max > 0 && initialMax <= 0) {
                    max = 0;
                }
            }*/
            minMaxStep = { min: min, max: max, step: step };
        }
        else {
            minMaxStep = super._adjustMinMax(min, max, gridCount, strictMode);
        }
        // choose duration formatter based on step
        this.setPrivateRaw("durationFormat", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));
        return minMaxStep;
    }
    _formatText(value) {
        const formatter = this.getDurationFormatter();
        return formatter.format(value, this.getPrivate("durationFormat"), this.get("baseUnit"));
    }
    /**
     * Returns text to be used in an axis tooltip for specific relative position.
     *
     * @param   position  Position
     * @return            Tooltip text
     */
    getTooltipText(position) {
        const formatter = this.getDurationFormatter();
        const extraDecimals = this.get("extraTooltipPrecision", 0);
        const decimals = this.getPrivate("stepDecimalPlaces", 0) + extraDecimals;
        const value = _core_util_Math__WEBPACK_IMPORTED_MODULE_2__["round"](this.positionToValue(position), decimals);
        return formatter.format(value, this.getPrivate("durationFormat"), this.get("baseUnit"));
    }
}
Object.defineProperty(DurationAxis, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "DurationAxis"
});
Object.defineProperty(DurationAxis, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _ValueAxis__WEBPACK_IMPORTED_MODULE_0__["ValueAxis"].classNames.concat([DurationAxis.className])
});
//# sourceMappingURL=DurationAxis.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/GaplessDateAxis.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/GaplessDateAxis.js ***!
  \**************************************************************************************/
/*! exports provided: GaplessDateAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GaplessDateAxis", function() { return GaplessDateAxis; });
/* harmony import */ var _DateAxis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DateAxis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/DateAxis.js");
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Order__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Order */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js");
/* harmony import */ var _core_util_Time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Time */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");







/**
 * A version of a [[DateAxis]] which removes intervals that don't have any data
 * items in them.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/gapless-date-axis/} for more info
 * @important
 */
class GaplessDateAxis extends _DateAxis__WEBPACK_IMPORTED_MODULE_0__["DateAxis"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_frequency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_dates", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    _afterNew() {
        this.valueFields.push("date");
        super._afterNew();
    }
    _updateDates(date) {
        const dates = this._dates;
        const result = _core_util_Array__WEBPACK_IMPORTED_MODULE_2__["getSortedIndex"](dates, (x) => _core_util_Order__WEBPACK_IMPORTED_MODULE_3__["compare"](x, date));
        if (!result.found) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__["insertIndex"](dates, result.index, date);
        }
    }
    _updateAllDates() {
        this._dates.length = 0;
        _core_util_Array__WEBPACK_IMPORTED_MODULE_2__["each"](this.series, (series) => {
            let field = "valueX";
            if (series.get("yAxis") == this) {
                field = "valueY";
            }
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__["each"](series.dataItems, (dataItem) => {
                let value = dataItem.get(field);
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](value)) {
                    if (dataItem.open) {
                        this._updateDates(dataItem.open[field]);
                    }
                }
            });
        });
    }
    /**
     * Convers value to a relative position on axis.
     *
     * @param   value  Value
     * @return         Relative position
     */
    valueToPosition(value) {
        const dates = this._dates;
        const startLocation = this.get("startLocation", 0);
        const endLocation = this.get("endLocation", 1);
        const len = dates.length - startLocation - (1 - endLocation);
        const result = _core_util_Array__WEBPACK_IMPORTED_MODULE_2__["getSortedIndex"](dates, (x) => _core_util_Order__WEBPACK_IMPORTED_MODULE_3__["compare"](x, value));
        let index = result.index;
        if (result.found) {
            return (index - startLocation) / len;
        }
        else {
            if (index > 0) {
                index -= 1;
            }
            let itemValue = dates[index];
            let d = 0;
            if (itemValue > value) {
                d = itemValue - value;
            }
            else {
                d = value - itemValue;
            }
            return (index - startLocation) / len + d / this.baseDuration() / len;
        }
    }
    /**
     * Converts numeric value from axis scale to index.
     *
     * @param  value  Value
     * @return        Index
     */
    valueToIndex(value) {
        const dates = this._dates;
        const result = _core_util_Array__WEBPACK_IMPORTED_MODULE_2__["getSortedIndex"](dates, (x) => _core_util_Order__WEBPACK_IMPORTED_MODULE_3__["compare"](x, value));
        let index = result.index;
        if (result.found) {
            return index;
        }
        else {
            if (index > 0) {
                index -= 1;
            }
            return index;
        }
    }
    /**
     * Converts a relative position to a corresponding numeric value from axis
     * scale.
     *
     * @param   position  Relative position
     * @return            Value
     */
    positionToValue(position) {
        const startLocation = this.get("startLocation", 0);
        const endLocation = this.get("endLocation", 1);
        let len = Math.round(this._dates.length - startLocation - (1 - endLocation));
        let index = position * len;
        let findex = Math.floor(index);
        if (findex < 0) {
            findex = 0;
        }
        if (findex > len - 1) {
            findex = len - 1;
        }
        return this._dates[findex] + (index - findex + startLocation) * this.baseDuration();
    }
    _fixZoomFactor() {
        this.setPrivateRaw("maxZoomFactor", this._dates.length - this.get("startLocation", 0) - (1 - this.get("endLocation", 1)));
    }
    /**
     * Zooms the axis to specific `start` and `end` values.
     *
     * Optional `duration` specifies duration of zoom animation in milliseconds.
     *
     * @param  start     Start value
     * @param  end       End value
     * @param  duration  Duration in milliseconds
     */
    zoomToValues(start, end, duration) {
        const min = this.getPrivate("min", 0);
        const max = this.getPrivate("max", 0);
        start = _core_util_Math__WEBPACK_IMPORTED_MODULE_6__["fitToRange"](start, min, max);
        end = _core_util_Math__WEBPACK_IMPORTED_MODULE_6__["fitToRange"](end, min, max);
        this.zoom(this.valueToPosition(start), this.valueToPosition(end), duration);
    }
    _prepareAxisItems() {
        let startTime = this.getPrivate("selectionMin", 0);
        let endTime = this.getPrivate("selectionMax", 0);
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](startTime) && _core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](endTime)) {
            if (this._seriesValuesDirty) {
                this._seriesValuesDirty = false;
                this._updateAllDates();
            }
            const dates = this._dates;
            const renderer = this.get("renderer");
            const len = dates.length;
            let startIndex = this.valueToIndex(startTime);
            if (startIndex > 0) {
                startIndex--;
            }
            let endIndex = this.valueToIndex(endTime);
            if (endIndex < len - 1) {
                endIndex++;
            }
            let maxCount = renderer.axisLength() / Math.max(renderer.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER);
            let frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));
            frequency = Math.max(1, frequency);
            startIndex = Math.floor(startIndex / frequency) * frequency;
            this._frequency = frequency;
            for (let j = 0, length = this.dataItems.length; j < length; j++) {
                this.dataItems[j].hide();
            }
            let realDuration = (endTime - startTime) - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();
            // if all items are on axis
            let gridInterval = _core_util_Time__WEBPACK_IMPORTED_MODULE_4__["chooseInterval"](0, realDuration, maxCount, this.get("gridIntervals"));
            const baseInterval = this.getPrivate("baseInterval");
            let intervalDuration = _core_util_Time__WEBPACK_IMPORTED_MODULE_4__["getIntervalDuration"](gridInterval);
            if (intervalDuration < this.baseDuration()) {
                gridInterval = Object.assign({}, baseInterval);
                intervalDuration = _core_util_Time__WEBPACK_IMPORTED_MODULE_4__["getIntervalDuration"](gridInterval);
            }
            this._intervalDuration = intervalDuration;
            const formats = this.get("dateFormats");
            let selectedItems = [];
            let firstDate = new Date();
            if (this._dates[0]) {
                firstDate = new Date(this._dates[0]);
            }
            let startDate = _core_util_Time__WEBPACK_IMPORTED_MODULE_4__["round"](new Date(this.getPrivate("min", 0)), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, firstDate, this._root.timezone);
            let value = _core_util_Time__WEBPACK_IMPORTED_MODULE_4__["add"](startDate, gridInterval.timeUnit, -1, this._root.utc, this._root.timezone).getTime();
            let selectionMax = this.getPrivate("selectionMax");
            let previousPosition = -Infinity;
            let minDifference = (this.get("end", 1) - this.get("start", 0)) / maxCount;
            while (value <= selectionMax) {
                let index = this.valueToIndex(value);
                let realValue = this._dates[index];
                if (realValue < value) {
                    for (let i = index, len = this._dates.length; i < len; i++) {
                        let realValue = this._dates[i];
                        if (realValue >= value) {
                            index = i;
                            break;
                        }
                    }
                }
                let position = this.valueToPosition(realValue);
                if (position - previousPosition >= minDifference * 0.95) {
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_2__["move"](selectedItems, index);
                    previousPosition = position;
                }
                let previousValue = value;
                value += _core_util_Time__WEBPACK_IMPORTED_MODULE_4__["getDuration"](gridInterval.timeUnit, gridInterval.count * this._getM(gridInterval.timeUnit));
                value = _core_util_Time__WEBPACK_IMPORTED_MODULE_4__["round"](new Date(value), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();
                if (value == previousValue) {
                    break;
                }
            }
            if (selectedItems.length > 0) {
                let i = 0;
                let previousValue = value - intervalDuration * 10;
                const nextGridUnit = _core_util_Time__WEBPACK_IMPORTED_MODULE_4__["getNextUnit"](gridInterval.timeUnit);
                _core_util_Array__WEBPACK_IMPORTED_MODULE_2__["each"](selectedItems, (index) => {
                    let dataItem;
                    if (this.dataItems.length < i + 1) {
                        dataItem = new _core_render_Component__WEBPACK_IMPORTED_MODULE_1__["DataItem"](this, undefined, {});
                        this._dataItems.push(dataItem);
                        this.processDataItem(dataItem);
                    }
                    else {
                        dataItem = this.dataItems[i];
                    }
                    let value = dates[index];
                    let date = new Date(value);
                    let endValue = value;
                    if (i < selectedItems.length - 1) {
                        endValue = dates[selectedItems[i + 1]];
                    }
                    else {
                        endValue += intervalDuration;
                    }
                    dataItem.setRaw("value", value);
                    dataItem.setRaw("endValue", endValue);
                    dataItem.setRaw("index", i);
                    if (index > startIndex - 100 && index < endIndex + 100) {
                        let format = formats[gridInterval.timeUnit];
                        format = formats[gridInterval.timeUnit];
                        if (nextGridUnit && this.get("markUnitChange") && _core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](previousValue)) {
                            if (gridInterval.timeUnit != "year") {
                                if (_core_util_Time__WEBPACK_IMPORTED_MODULE_4__["checkChange"](value, previousValue, nextGridUnit, this._root.utc, this._root.timezone)) {
                                    format = this.get("periodChangeDateFormats")[gridInterval.timeUnit];
                                }
                            }
                        }
                        this._createAssets(dataItem, []);
                        const label = dataItem.get("label");
                        if (label) {
                            label.set("text", this._root.dateFormatter.format(date, format));
                        }
                        if (dataItem.isHidden()) {
                            dataItem.show();
                        }
                        this._prepareDataItem(dataItem, gridInterval.count);
                    }
                    i++;
                    previousValue = value;
                });
            }
            _core_util_Array__WEBPACK_IMPORTED_MODULE_2__["each"](this.series, (series) => {
                if (series.inited) {
                    series._markDirtyAxes();
                }
            });
        }
        this._updateGhost();
    }
}
Object.defineProperty(GaplessDateAxis, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "GaplessDateAxis"
});
Object.defineProperty(GaplessDateAxis, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _DateAxis__WEBPACK_IMPORTED_MODULE_0__["DateAxis"].classNames.concat([GaplessDateAxis.className])
});
//# sourceMappingURL=GaplessDateAxis.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js ***!
  \***************************************************************************/
/*! exports provided: Grid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Grid", function() { return Grid; });
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");

/**
 * Creates an axis grid line.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/#Grid} for more info
 * @important
 */
class Grid extends _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
            this._clear = true;
        }
    }
}
Object.defineProperty(Grid, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Grid"
});
Object.defineProperty(Grid, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"].classNames.concat([Grid.className])
});
//# sourceMappingURL=Grid.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js ***!
  \********************************************************************************/
/*! exports provided: ValueAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ValueAxis", function() { return ValueAxis; });
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Axis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js");
/* harmony import */ var _core_util_Disposer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");







/**
 * Creates a value axis.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/} for more info
 * @important
 */
class ValueAxis extends _Axis__WEBPACK_IMPORTED_MODULE_1__["Axis"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_dirtyExtremes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dirtySelectionExtremes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_deltaMinMax", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_minReal", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_maxReal", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_baseValue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_syncDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_minLogAdjusted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
    }
    /**
     * @ignore
     */
    markDirtyExtremes() {
        this._dirtyExtremes = true;
        this.markDirty();
    }
    /**
     * @ignore
     */
    markDirtySelectionExtremes() {
        this._dirtySelectionExtremes = true;
        this.markDirty();
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this._settings.themeTags, ["axis"]);
        this.setPrivateRaw("name", "value");
        this.addTag("value");
        super._afterNew();
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.isDirty("syncWithAxis")) {
            let previousValue = this._prevSettings.syncWithAxis;
            if (previousValue) {
                if (this._syncDp) {
                    this._syncDp.dispose();
                }
            }
            let syncWithAxis = this.get("syncWithAxis");
            if (syncWithAxis) {
                this._syncDp = new _core_util_Disposer__WEBPACK_IMPORTED_MODULE_2__["MultiDisposer"]([
                    syncWithAxis.onPrivate("selectionMinFinal", () => {
                        this._dirtySelectionExtremes = true;
                    }),
                    syncWithAxis.onPrivate("selectionMaxFinal", () => {
                        this._dirtySelectionExtremes = true;
                    })
                ]);
            }
        }
        //if (this._dirtyExtremes || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("maxPrecision")) {
        if (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("strictMinMaxSelection") || this.isDirty("maxPrecision") || this.isDirty("numberFormat")) {
            this._getMinMax();
            this.ghostLabel.set("text", "");
            this._dirtyExtremes = false;
        }
        if (this._dirtySelectionExtremes && !this._isPanning && this.get("autoZoom", true)) {
            this._getSelectionMinMax();
            this._dirtySelectionExtremes = false;
        }
        this._groupData();
        if (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("min") || this.isPrivateDirty("selectionMax") || this.isPrivateDirty("selectionMin") || this.isPrivateDirty("max") || this.isPrivateDirty("step") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("logarithmic")) {
            this._handleRangeChange();
            this._prepareAxisItems();
            this._updateAxisRanges();
        }
        this._baseValue = this.baseValue();
    }
    _groupData() {
    }
    _formatText(value) {
        const numberFormat = this.get("numberFormat");
        const formatter = this.getNumberFormatter();
        let text = "";
        if (numberFormat) {
            text = formatter.format(value, numberFormat);
        }
        else {
            text = formatter.format(value, undefined, this.getPrivate("stepDecimalPlaces"));
        }
        return text;
    }
    _prepareAxisItems() {
        const min = this.getPrivate("min");
        const max = this.getPrivate("max");
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](min) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](max)) {
            const logarithmic = this.get("logarithmic");
            const step = this.getPrivate("step");
            const selectionMin = this.getPrivate("selectionMin");
            const selectionMax = this.getPrivate("selectionMax") + step;
            let value = selectionMin - step;
            let i = 0;
            let differencePower = 1;
            let minLog = min;
            if (logarithmic) {
                value = this._minLogAdjusted;
                if (value < selectionMin) {
                    while (value < selectionMin) {
                        value += step;
                    }
                }
                minLog = value;
                if (minLog <= 0) {
                    minLog = 1;
                    if (step < 1) {
                        minLog = step;
                    }
                }
                differencePower = Math.log(selectionMax - step) * Math.LOG10E - Math.log(minLog) * Math.LOG10E;
                if (differencePower > 2) {
                    value = Math.pow(10, Math.log(minLog) * Math.LOG10E - 5);
                }
            }
            let previous = -Infinity;
            while (value < selectionMax) {
                let dataItem;
                if (this.dataItems.length < i + 1) {
                    dataItem = new _core_render_Component__WEBPACK_IMPORTED_MODULE_0__["DataItem"](this, undefined, {});
                    this._dataItems.push(dataItem);
                    this.processDataItem(dataItem);
                }
                else {
                    dataItem = this.dataItems[i];
                }
                this._createAssets(dataItem, []);
                if (dataItem.isHidden()) {
                    dataItem.show();
                }
                dataItem.setRaw("value", value);
                const label = dataItem.get("label");
                if (label) {
                    label.set("text", this._formatText(value));
                }
                this._prepareDataItem(dataItem);
                if (!logarithmic) {
                    value += step;
                }
                else {
                    if (differencePower > 2) {
                        value = Math.pow(10, Math.log(minLog) * Math.LOG10E + i - 5);
                    }
                    else {
                        value += step;
                    }
                }
                if (previous == value) {
                    break;
                }
                let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
                if (stepPower < 1) {
                    // exponent is less then 1 too. Count decimals of exponent
                    let decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;
                    // round value to avoid floating point issues
                    value = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](value, decCount);
                }
                i++;
                previous = value;
            }
            for (let j = i; j < this.dataItems.length; j++) {
                this.dataItems[j].hide();
            }
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.series, (series) => {
                if (series.inited) {
                    series._markDirtyAxes();
                }
            });
            this._updateGhost();
        }
    }
    _prepareDataItem(dataItem, count) {
        let renderer = this.get("renderer");
        let value = dataItem.get("value");
        let endValue = dataItem.get("endValue");
        let position = this.valueToPosition(value);
        let endPosition = position;
        let fillEndPosition = this.valueToPosition(value + this.getPrivate("step"));
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](endValue)) {
            endPosition = this.valueToPosition(endValue);
            fillEndPosition = endPosition;
        }
        if (dataItem.get("isRange")) {
            if (endValue == null) {
                fillEndPosition = position;
            }
        }
        renderer.updateLabel(dataItem.get("label"), position, endPosition, count);
        const grid = dataItem.get("grid");
        renderer.updateGrid(grid, position, endPosition);
        if (grid) {
            if (value == this.get("baseValue", 0)) {
                grid.addTag("base");
                grid._applyThemes();
            }
            else if (grid.hasTag("base")) {
                grid.removeTag("base");
                grid._applyThemes();
            }
        }
        renderer.updateTick(dataItem.get("tick"), position, endPosition, count);
        renderer.updateFill(dataItem.get("axisFill"), position, fillEndPosition);
        this._processBullet(dataItem);
        renderer.updateBullet(dataItem.get("bullet"), position, endPosition);
        if (!dataItem.get("isRange")) {
            const fillRule = this.get("fillRule");
            if (fillRule) {
                fillRule(dataItem);
            }
        }
    }
    _handleRangeChange() {
        let selectionMin = this.positionToValue(this.get("start", 0));
        let selectionMax = this.positionToValue(this.get("end", 1));
        const gridCount = this.get("renderer").gridCount();
        let minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
        let stepDecimalPlaces = _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["decimalPlaces"](minMaxStep.step);
        this.setPrivateRaw("stepDecimalPlaces", stepDecimalPlaces);
        selectionMin = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](selectionMin, stepDecimalPlaces);
        selectionMax = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](selectionMax, stepDecimalPlaces);
        minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
        let step = minMaxStep.step;
        selectionMin = minMaxStep.min;
        selectionMax = minMaxStep.max;
        if (this.getPrivate("selectionMin") !== selectionMin || this.getPrivate("selectionMax") !== selectionMax || this.getPrivate("step") !== step) {
            // do not change to setPrivate, will cause SO
            this.setPrivateRaw("selectionMin", selectionMin);
            this.setPrivateRaw("selectionMax", selectionMax);
            this.setPrivateRaw("step", step);
        }
    }
    /**
     * Converts a relative position to a corresponding numeric value from axis
     * scale.
     *
     * @param   position  Relative position
     * @return            Value
     */
    positionToValue(position) {
        const min = this.getPrivate("min");
        const max = this.getPrivate("max");
        if (!this.get("logarithmic")) {
            return position * (max - min) + min;
        }
        else {
            return Math.pow(Math.E, (position * ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E)) + Math.log(min) * Math.LOG10E) / Math.LOG10E);
        }
    }
    /**
     * Convers value to a relative position on axis.
     *
     * @param   value  Value
     * @return         Relative position
     */
    valueToPosition(value) {
        const min = this.getPrivate("min");
        const max = this.getPrivate("max");
        if (!this.get("logarithmic")) {
            return (value - min) / (max - min);
        }
        else {
            if (value <= 0) {
                let treatZeroAs = this.get("treatZeroAs");
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](treatZeroAs)) {
                    value = treatZeroAs;
                }
            }
            return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));
        }
    }
    /**
     * @ignore
     */
    valueToFinalPosition(value) {
        const min = this.getPrivate("minFinal");
        const max = this.getPrivate("maxFinal");
        if (!this.get("logarithmic")) {
            return (value - min) / (max - min);
        }
        else {
            if (value <= 0) {
                let treatZeroAs = this.get("treatZeroAs");
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](treatZeroAs)) {
                    value = treatZeroAs;
                }
            }
            return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / ((Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E));
        }
    }
    /**
     * Returns X coordinate in pixels corresponding to specific value.
     *
     * @param   value     Numeric value
     * @param   location  Location
     * @param   baseValue Base value
     * @return            X coordinate
     */
    getX(value, location, baseValue) {
        value = baseValue + (value - baseValue) * location;
        const position = this.valueToPosition(value);
        return this._settings.renderer.positionToCoordinate(position);
    }
    /**
     * Returns X coordinate in pixels corresponding to specific value.
     *
     * @param   value     Numeric value
     * @param   location  Location
     * @param   baseValue Base value
     * @return            X coordinate
     */
    getY(value, location, baseValue) {
        value = baseValue + (value - baseValue) * location;
        const position = this.valueToPosition(value);
        return this._settings.renderer.positionToCoordinate(position);
    }
    /**
     * @ignore
     */
    getDataItemCoordinateX(dataItem, field, _cellLocation, axisLocation) {
        return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, _cellLocation, axisLocation));
    }
    /**
     * @ignore
     */
    getDataItemPositionX(dataItem, field, _cellLocation, axisLocation) {
        let value = dataItem.get(field);
        const stackToItem = dataItem.get("stackToItemX");
        if (stackToItem) {
            const series = dataItem.component;
            value = value * axisLocation + series.getStackedXValueWorking(dataItem, field);
        }
        else {
            value = this._baseValue + (value - this._baseValue) * axisLocation;
        }
        return this.valueToPosition(value);
    }
    /**
     * @ignore
     */
    getDataItemCoordinateY(dataItem, field, _cellLocation, axisLocation) {
        return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, _cellLocation, axisLocation));
    }
    /**
     * @ignore
     */
    getDataItemPositionY(dataItem, field, _cellLocation, axisLocation) {
        let value = dataItem.get(field);
        const stackToItem = dataItem.get("stackToItemY");
        if (stackToItem) {
            const series = dataItem.component;
            value = value * axisLocation + series.getStackedYValueWorking(dataItem, field);
        }
        else {
            value = this._baseValue + (value - this._baseValue) * axisLocation;
        }
        return this.valueToPosition(value);
    }
    /**
     * Returns relative position of axis' `baseValue`.
     *
     * @return  Base value position
     */
    basePosition() {
        return this.valueToPosition(this.baseValue());
    }
    /**
     * Base value of the [[ValueAxis]], which determines positive and negative
     * values.
     *
     * @return Base value
     */
    baseValue() {
        const min = Math.min(this.getPrivate("minFinal", -Infinity), this.getPrivate("selectionMin", -Infinity));
        const max = Math.max(this.getPrivate("maxFinal", Infinity), this.getPrivate("selectionMax", Infinity));
        let baseValue = this.get("baseValue", 0);
        if (baseValue < min) {
            baseValue = min;
        }
        if (baseValue > max) {
            baseValue = max;
        }
        return baseValue;
    }
    /**
     * @ignore
     */
    cellEndValue(value) {
        return value;
    }
    fixSmallStep(step) {
        // happens because of floating point error
        if (1 + step === 1) {
            step *= 2;
            return this.fixSmallStep(step);
        }
        return step;
    }
    _fixMin(min) {
        return min;
    }
    _fixMax(max) {
        return max;
    }
    _calculateTotals() {
        if (this.get("calculateTotals")) {
            let series = this.series[0];
            if (series) {
                let startIndex = series.startIndex();
                if (series.dataItems.length > 0) {
                    if (startIndex > 0) {
                        startIndex--;
                    }
                    let endIndex = series.endIndex();
                    if (endIndex < series.dataItems.length) {
                        endIndex++;
                    }
                    let field;
                    let vc;
                    if (series.get("yAxis") == this) {
                        field = "valueY";
                        vc = "vcy";
                    }
                    else if (series.get("xAxis") == this) {
                        field = "valueX";
                        vc = "vcx";
                    }
                    let fieldWorking = field + "Working";
                    if (field) {
                        for (let i = startIndex; i < endIndex; i++) {
                            let sum = 0;
                            let total = 0;
                            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.series, (series) => {
                                if (!series.get("excludeFromTotal")) {
                                    let dataItem = series.dataItems[i];
                                    if (dataItem) {
                                        let value = dataItem.get(fieldWorking) * series.get(vc);
                                        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNaN"](value)) {
                                            sum += value;
                                            total += Math.abs(value);
                                        }
                                    }
                                }
                            });
                            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.series, (series) => {
                                if (!series.get("excludeFromTotal")) {
                                    let dataItem = series.dataItems[i];
                                    if (dataItem) {
                                        let value = dataItem.get(fieldWorking) * series.get(vc);
                                        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNaN"](value)) {
                                            dataItem.set((field + "Total"), total);
                                            dataItem.set((field + "Sum"), sum);
                                            dataItem.set((field + "TotalPercent"), value / total * 100);
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
        }
    }
    _getSelectionMinMax() {
        const min = this.getPrivate("minFinal");
        const max = this.getPrivate("maxFinal");
        const minDefined = this.get("min");
        const maxDefined = this.get("max");
        let extraMin = this.get("extraMin", 0);
        let extraMax = this.get("extraMax", 0);
        if (this.get("logarithmic")) {
            if (this.get("extraMin") == null) {
                extraMin = 0.1;
            }
            if (this.get("extraMax") == null) {
                extraMax = 0.2;
            }
        }
        const gridCount = this.get("renderer").gridCount();
        const selectionStrictMinMax = this.get("strictMinMaxSelection");
        const strictMinMax = this.get("strictMinMax");
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](min) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](max)) {
            let selectionMin = max;
            let selectionMax = min;
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.series, (series) => {
                if (!series.get("ignoreMinMax")) {
                    let seriesMin;
                    let seriesMax;
                    const outOfSelection = series.getPrivate("outOfSelection");
                    if (series.get("xAxis") === this) {
                        if (!outOfSelection) {
                            seriesMin = series.getPrivate("selectionMinX", series.getPrivate("minX"));
                            seriesMax = series.getPrivate("selectionMaxX", series.getPrivate("maxX"));
                        }
                    }
                    else if (series.get("yAxis") === this) {
                        if (!outOfSelection) {
                            seriesMin = series.getPrivate("selectionMinY", series.getPrivate("minY"));
                            seriesMax = series.getPrivate("selectionMaxY", series.getPrivate("maxY"));
                        }
                    }
                    if (!series.isHidden() && !series.isShowing()) {
                        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](seriesMin)) {
                            selectionMin = Math.min(selectionMin, seriesMin);
                        }
                        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](seriesMax)) {
                            selectionMax = Math.max(selectionMax, seriesMax);
                        }
                    }
                }
            });
            this.axisRanges.each((range) => {
                if (range.get("affectsMinMax")) {
                    let value = range.get("value");
                    if (value != null) {
                        selectionMin = Math.min(selectionMin, value);
                        selectionMax = Math.max(selectionMax, value);
                    }
                    value = range.get("endValue");
                    if (value != null) {
                        selectionMin = Math.min(selectionMin, value);
                        selectionMax = Math.max(selectionMax, value);
                    }
                }
            });
            if (selectionMin > selectionMax) {
                [selectionMin, selectionMax] = [selectionMax, selectionMin];
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](minDefined)) {
                if (strictMinMax) {
                    selectionMin = minDefined;
                }
                else {
                    selectionMin = min;
                }
            }
            else if (strictMinMax) {
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](this._minReal)) {
                    selectionMin = this._minReal;
                }
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](maxDefined)) {
                if (strictMinMax) {
                    selectionMax = maxDefined;
                }
                else {
                    selectionMax = max;
                }
            }
            else if (strictMinMax) {
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](this._maxReal)) {
                    selectionMax = this._maxReal;
                }
            }
            if (selectionMin === selectionMax) {
                selectionMin -= this._deltaMinMax;
                selectionMax += this._deltaMinMax;
                let minMaxStep2 = this._adjustMinMax(selectionMin, selectionMax, gridCount, strictMinMax);
                selectionMin = minMaxStep2.min;
                selectionMax = minMaxStep2.max;
            }
            let selectionMinReal = selectionMin;
            let selectionMaxReal = selectionMax;
            selectionMin -= (selectionMax - selectionMin) * extraMin;
            selectionMax += (selectionMax - selectionMin) * extraMax;
            let minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount);
            selectionMin = minMaxStep.min;
            selectionMax = minMaxStep.max;
            selectionMin = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["fitToRange"](selectionMin, min, max);
            selectionMax = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["fitToRange"](selectionMax, min, max);
            // do it for the second time !important			
            minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);
            if (!strictMinMax) {
                selectionMin = minMaxStep.min;
                selectionMax = minMaxStep.max;
            }
            const syncWithAxis = this.get("syncWithAxis");
            if (syncWithAxis) {
                minMaxStep = this._syncAxes(selectionMin, selectionMax, minMaxStep.step, syncWithAxis.getPrivate("selectionMinFinal", syncWithAxis.getPrivate("minFinal", 0)), syncWithAxis.getPrivate("selectionMaxFinal", syncWithAxis.getPrivate("maxFinal", 1)), syncWithAxis.getPrivate("selectionStepFinal", syncWithAxis.getPrivate("step", 1)));
                selectionMin = minMaxStep.min;
                selectionMax = minMaxStep.max;
            }
            if (strictMinMax) {
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](minDefined)) {
                    selectionMin = Math.max(selectionMin, minDefined);
                }
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](maxDefined)) {
                    selectionMax = Math.min(selectionMax, maxDefined);
                }
            }
            if (selectionStrictMinMax) {
                selectionMin = selectionMinReal - (selectionMax - selectionMin) * extraMin;
                selectionMax = selectionMaxReal + (selectionMax - selectionMin) * extraMax;
            }
            if (this.get("logarithmic")) {
                if (selectionMin <= 0) {
                    selectionMin = selectionMinReal * (1 - Math.min(extraMin, 0.99));
                }
                if (selectionMin < min) {
                    selectionMin = min;
                }
                if (selectionMax > max) {
                    selectionMax = max;
                }
            }
            let len = Math.min(20, Math.ceil(Math.log(this.getPrivate("maxZoomFactor", 100) + 1) / Math.LN10) + 2);
            let start = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](this.valueToFinalPosition(selectionMin), len);
            let end = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](this.valueToFinalPosition(selectionMax), len);
            this.setPrivateRaw("selectionMinFinal", selectionMin);
            this.setPrivateRaw("selectionMaxFinal", selectionMax);
            this.setPrivateRaw("selectionStepFinal", minMaxStep.step);
            this.zoom(start, end);
        }
    }
    _getMinMax() {
        let minDefined = this.get("min");
        let maxDefined = this.get("max");
        let min = Infinity;
        let max = -Infinity;
        let extraMin = this.get("extraMin", 0);
        let extraMax = this.get("extraMax", 0);
        if (this.get("logarithmic")) {
            if (this.get("extraMin") == null) {
                extraMin = 0.1;
            }
            if (this.get("extraMax") == null) {
                extraMax = 0.2;
            }
        }
        let minDiff = Infinity;
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.series, (series) => {
            if (!series.get("ignoreMinMax")) {
                let seriesMin;
                let seriesMax;
                if (series.get("xAxis") === this) {
                    seriesMin = series.getPrivate("minX");
                    seriesMax = series.getPrivate("maxX");
                }
                else if (series.get("yAxis") === this) {
                    seriesMin = series.getPrivate("minY");
                    seriesMax = series.getPrivate("maxY");
                }
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](seriesMin) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](seriesMax)) {
                    min = Math.min(min, seriesMin);
                    max = Math.max(max, seriesMax);
                    let diff = seriesMax - seriesMin;
                    if (diff <= 0) {
                        diff = Math.abs(seriesMax / 100);
                    }
                    if (diff < minDiff) {
                        minDiff = diff;
                    }
                }
            }
        });
        this.axisRanges.each((range) => {
            if (range.get("affectsMinMax")) {
                let value = range.get("value");
                if (value != null) {
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
                value = range.get("endValue");
                if (value != null) {
                    min = Math.min(min, value);
                    max = Math.max(max, value);
                }
            }
        });
        if (this.get("logarithmic")) {
            let treatZeroAs = this.get("treatZeroAs");
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](treatZeroAs)) {
                if (min <= 0) {
                    min = treatZeroAs;
                }
            }
            if (min <= 0) {
                new Error("Logarithmic value axis can not have values <= 0.");
            }
        }
        if (min === 0 && max === 0) {
            max = 0.9;
            min = -0.9;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](minDefined)) {
            min = minDefined;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](maxDefined)) {
            max = maxDefined;
        }
        // meaning no min/max found on series/ranges and no min/max was defined
        if (min === Infinity || max === -Infinity) {
            this.setPrivate("minFinal", undefined);
            this.setPrivate("maxFinal", undefined);
            return;
        }
        const initialMin = min;
        const initialMax = max;
        // adapter
        let minAdapted = this.adapters.fold("min", min);
        let maxAdapted = this.adapters.fold("max", max);
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](minAdapted)) {
            min = minAdapted;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](maxAdapted)) {
            max = maxAdapted;
        }
        // DateAxis does some magic here
        min = this._fixMin(min);
        max = this._fixMax(max);
        // this happens if starLocation and endLocation are 0.5 and DateAxis has only one date		
        if (max - min <= 1 / Math.pow(10, 15)) {
            if (max - min !== 0) {
                this._deltaMinMax = (max - min) / 2;
            }
            else {
                this._getDelta(max);
            }
            min -= this._deltaMinMax;
            max += this._deltaMinMax;
        }
        // add extras
        min -= (max - min) * extraMin;
        max += (max - min) * extraMax;
        if (this.get("logarithmic")) {
            // don't let min go below 0 if real min is >= 0
            if (min < 0 && initialMin >= 0) {
                min = 0;
            }
            // don't let max go above 0 if real max is <= 0
            if (max > 0 && initialMax <= 0) {
                max = 0;
            }
        }
        this._minReal = min;
        this._maxReal = max;
        let strictMinMax = this.get("strictMinMax");
        let strictMinMaxSelection = this.get("strictMinMaxSelection", false);
        if (strictMinMaxSelection) {
            strictMinMax = strictMinMaxSelection;
        }
        let strict = strictMinMax;
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](maxDefined)) {
            strict = true;
        }
        let gridCount = this.get("renderer").gridCount();
        let minMaxStep = this._adjustMinMax(min, max, gridCount, strict);
        min = minMaxStep.min;
        max = minMaxStep.max;
        // do it for the second time with strict true (importat!)
        minMaxStep = this._adjustMinMax(min, max, gridCount, true);
        min = minMaxStep.min;
        max = minMaxStep.max;
        // return min max if strict
        if (strictMinMax) {
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](minDefined)) {
                min = minDefined;
            }
            else {
                min = this._minReal;
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](maxDefined)) {
                max = maxDefined;
            }
            else {
                max = this._maxReal;
            }
            if (max - min <= 0.00000001) {
                min -= this._deltaMinMax;
                max += this._deltaMinMax;
            }
            min -= (max - min) * extraMin;
            max += (max - min) * extraMax;
        }
        minAdapted = this.adapters.fold("min", min);
        maxAdapted = this.adapters.fold("max", max);
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](minAdapted)) {
            min = minAdapted;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](maxAdapted)) {
            max = maxAdapted;
        }
        if (minDiff == Infinity) {
            minDiff = (max - min);
        }
        // this is to avoid floating point number error
        let decCount = Math.round(Math.abs(Math.log(Math.abs(max - min)) * Math.LOG10E)) + 5;
        min = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](min, decCount);
        max = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](max, decCount);
        const syncWithAxis = this.get("syncWithAxis");
        if (syncWithAxis) {
            minMaxStep = this._syncAxes(min, max, minMaxStep.step, syncWithAxis.getPrivate("minFinal", syncWithAxis.getPrivate("min", 0)), syncWithAxis.getPrivate("maxFinal", syncWithAxis.getPrivate("max", 1)), syncWithAxis.getPrivate("step", 1));
            min = minMaxStep.min;
            max = minMaxStep.max;
        }
        this.setPrivateRaw("maxZoomFactor", Math.max(1, Math.ceil((max - min) / minDiff * this.get("maxZoomFactor", 100))));
        this._fixZoomFactor();
        if (this.get("logarithmic")) {
            this._minLogAdjusted = min;
            min = this._minReal;
            max = this._maxReal;
            if (min <= 0) {
                min = initialMin * (1 - Math.min(extraMin, 0.99));
            }
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](min) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](max)) {
            if (this.getPrivate("minFinal") !== min || this.getPrivate("maxFinal") !== max) {
                this.setPrivate("minFinal", min);
                this.setPrivate("maxFinal", max);
                this._saveMinMax(min, max);
                const duration = this.get("interpolationDuration", 0);
                const easing = this.get("interpolationEasing");
                this.animatePrivate({ key: "min", to: min, duration, easing });
                this.animatePrivate({ key: "max", to: max, duration, easing });
            }
        }
    }
    _fixZoomFactor() {
    }
    _getDelta(max) {
        // the number by which we need to raise 10 to get difference
        let exponent = Math.log(Math.abs(max)) * Math.LOG10E;
        // here we find a number which is power of 10 and has the same count of numbers as difference has
        let power = Math.pow(10, Math.floor(exponent));
        // reduce this number by 10 times
        power = power / 10;
        this._deltaMinMax = power;
    }
    _saveMinMax(_min, _max) {
    }
    _adjustMinMax(min, max, gridCount, strictMode) {
        // will fail if 0
        if (gridCount <= 1) {
            gridCount = 1;
        }
        gridCount = Math.round(gridCount);
        let initialMin = min;
        let initialMax = max;
        let difference = max - min;
        // in case min and max is the same, use max
        if (difference === 0) {
            difference = Math.abs(max);
        }
        // the number by which we need to raise 10 to get difference
        let exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
        // here we find a number which is power of 10 and has the same count of numbers as difference has
        let power = Math.pow(10, Math.floor(exponent));
        // reduce this number by 10 times
        power = power / 10;
        let extra = power;
        if (strictMode) {
            extra = 0;
        }
        // round down min
        if (strictMode) {
            min = Math.floor(min / power) * power;
            // round up max
            max = Math.ceil(max / power) * power;
        }
        else {
            min = Math.ceil(min / power) * power - extra;
            // round up max
            max = Math.floor(max / power) * power + extra;
        }
        // don't let min go below 0 if real min is >= 0
        if (min < 0 && initialMin >= 0) {
            min = 0;
        }
        // don't let max go above 0 if real max is <= 0
        if (max > 0 && initialMax <= 0) {
            max = 0;
        }
        exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
        power = Math.pow(10, Math.floor(exponent));
        power = power / 100; // used to be 10 in v4, but this caused issue that there could be limited number of grids with even very small minGridDistance
        // approximate difference between two grid lines
        let step = Math.ceil((difference / gridCount) / power) * power;
        let stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
        // the step should divide by  2, 5, and 10.
        let stepDivisor = Math.ceil(step / stepPower); // number 0 - 10
        if (stepDivisor > 5) {
            stepDivisor = 10;
        }
        else if (stepDivisor <= 5 && stepDivisor > 2) {
            stepDivisor = 5;
        }
        // now get real step
        step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;
        let maxPrecision = this.get("maxPrecision");
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](maxPrecision)) {
            let ceiledStep = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["ceil"](step, maxPrecision);
            if (maxPrecision < Number.MAX_VALUE && step !== ceiledStep) {
                step = ceiledStep;
            }
        }
        let decCount = 0;
        // in case numbers are smaller than 1
        if (stepPower < 1) {
            // exponent is less then 1 too. Count decimals of exponent
            decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;
            // round step
            step = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](step, decCount);
        }
        // final min and max
        let minCount = Math.floor(min / step);
        min = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](step * minCount, decCount);
        let maxCount;
        if (!strictMode) {
            maxCount = Math.ceil(max / step);
        }
        else {
            maxCount = Math.floor(max / step);
        }
        if (maxCount === minCount) {
            maxCount++;
        }
        max = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](step * maxCount, decCount);
        if (max < initialMax) {
            max = max + step;
        }
        if (min > initialMin) {
            min = min - step;
        }
        step = this.fixSmallStep(step);
        return { min: min, max: max, step: step };
    }
    /**
     * Returns text to be used in an axis tooltip for specific relative position.
     *
     * @param   position  Position
     * @return            Tooltip text
     */
    getTooltipText(position) {
        const numberFormat = this.get("tooltipNumberFormat", this.get("numberFormat"));
        const formatter = this.getNumberFormatter();
        const extraDecimals = this.get("extraTooltipPrecision", 0);
        const decimals = this.getPrivate("stepDecimalPlaces", 0) + extraDecimals;
        const value = _core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](this.positionToValue(position), decimals);
        if (numberFormat) {
            return formatter.format(value, numberFormat);
        }
        else {
            return formatter.format(value, undefined, decimals);
            //label.set("text", this.getNumberFormatter().format(value, undefined, this.getPrivate("stepDecimalPlaces")));
        }
        // //@todo number formatter + tag
        // return $math.round(this.positionToValue(position), this.getPrivate("stepDecimalPlaces")).toString();
    }
    /**
     * Returns a data item from series that is closest to the `position`.
     *
     * @param   series    Series
     * @param   position  Relative position
     * @return            Data item
     */
    getSeriesItem(series, position) {
        let fieldName = (this.getPrivate("name") + this.get("renderer").getPrivate("letter"));
        let value = this.positionToValue(position);
        let index = undefined;
        let oldDiff;
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](series.dataItems, (dataItem, i) => {
            const diff = Math.abs(dataItem.get(fieldName) - value);
            if (index === undefined || diff < oldDiff) {
                index = i;
                oldDiff = diff;
            }
        });
        if (index != null) {
            return series.dataItems[index];
        }
    }
    /**
     * Zooms the axis to specific `start` and `end` values.
     *
     * Optional `duration` specifies duration of zoom animation in milliseconds.
     *
     * @param  start     Start value
     * @param  end       End value
     * @param  duration  Duration in milliseconds
     */
    zoomToValues(start, end, duration) {
        const min = this.getPrivate("minFinal", 0);
        const max = this.getPrivate("maxFinal", 0);
        if (this.getPrivate("min") != null && this.getPrivate("max") != null) {
            this.zoom((start - min) / (max - min), (end - min) / (max - min), duration);
        }
    }
    /**
     * Syncs with a target axis.
     *
     * @param  min  Min
     * @param  max  Max
     * @param  step Step
     */
    _syncAxes(min, max, step, syncMin, syncMax, syncStep) {
        let axis = this.get("syncWithAxis");
        if (axis) {
            let count = Math.round(syncMax - syncMin) / syncStep;
            let currentCount = Math.round((max - min) / step);
            let gridCount = this.get("renderer").gridCount();
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](count) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](currentCount)) {
                let synced = false;
                let c = 0;
                let diff = (max - min) * 0.01;
                let omin = min;
                let omax = max;
                let ostep = step;
                while (synced != true) {
                    synced = this._checkSync(omin, omax, ostep, count);
                    c++;
                    if (c > 500) {
                        synced = true;
                    }
                    if (!synced) {
                        if (c / 3 == Math.round(c / 3)) {
                            omin = min - diff * c;
                            if (min >= 0 && omin < 0) {
                                omin = 0;
                            }
                        }
                        else {
                            omax = max + diff * c;
                            if (omax <= 0 && omax > 0) {
                                omax = 0;
                            }
                        }
                        let minMaxStep = this._adjustMinMax(omin, omax, gridCount, true);
                        omin = minMaxStep.min;
                        omax = minMaxStep.max;
                        ostep = minMaxStep.step;
                    }
                    else {
                        min = omin;
                        max = omax;
                        step = ostep;
                    }
                }
            }
        }
        return { min: min, max: max, step: step };
    }
    /**
     * Returns `true` if axis needs to be resunced with some other axis.
     */
    _checkSync(min, max, step, count) {
        let currentCount = (max - min) / step;
        for (let i = 1; i < count; i++) {
            if (_core_util_Math__WEBPACK_IMPORTED_MODULE_5__["round"](currentCount / i, 1) == count || currentCount * i == count) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns relative position between two grid lines of the axis.
     *
     * @return Position
     */
    getCellWidthPosition() {
        let max = this.getPrivate("selectionMax", this.getPrivate("max"));
        let min = this.getPrivate("selectionMin", this.getPrivate("min"));
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](max) && _core_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](min)) {
            return this.getPrivate("step", 1) / (max - min);
        }
        return 0.05;
    }
}
Object.defineProperty(ValueAxis, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "ValueAxis"
});
Object.defineProperty(ValueAxis, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Axis__WEBPACK_IMPORTED_MODULE_1__["Axis"].classNames.concat([ValueAxis.className])
});
//# sourceMappingURL=ValueAxis.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js ***!
  \*****************************************************************************************/
/*! exports provided: BaseColumnSeries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseColumnSeries", function() { return BaseColumnSeries; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/@amcharts/amcharts5/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _XYSeries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XYSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");






/**
 * Base class for all "column-based" series
 */
class BaseColumnSeries extends _XYSeries__WEBPACK_IMPORTED_MODULE_1__["XYSeries"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_ph", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_pw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    _makeGraphics(listTemplate, dataItem) {
        return this.makeColumn(dataItem, listTemplate);
    }
    _makeFieldNames() {
        super._makeFieldNames();
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const categoryAxis = "CategoryAxis";
        const valueAxis = "ValueAxis";
        if (xAxis.isType(categoryAxis)) {
            if (!this.get("openCategoryXField")) {
                this._xOpenField = this._xField;
            }
        }
        if (xAxis.isType(valueAxis)) {
            if (!this.get("openValueXField")) {
                this._xOpenField = this._xField;
            }
        }
        if (yAxis.isType(categoryAxis)) {
            if (!this.get("openCategoryYField")) {
                this._yOpenField = this._yField;
            }
        }
        if (yAxis.isType(valueAxis)) {
            if (!this.get("openValueYField")) {
                this._yOpenField = this._yField;
            }
        }
    }
    _prepareChildren() {
        super._prepareChildren();
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const len = this.dataItems.length;
        const startIndex = Math.max(0, this.startIndex() - 2);
        const endIndex = Math.min(this.endIndex() + 2, len - 1);
        if (xAxis.inited && yAxis.inited) {
            for (let i = startIndex; i <= endIndex; i++) {
                let dataItem = this.dataItems[i];
                this._createGraphics(dataItem);
            }
        }
    }
    _updateChildren() {
        const chart = this.chart;
        if (chart) {
            this._ph = chart.plotContainer.height();
            this._pw = chart.plotContainer.width();
        }
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const baseAxis = this.get("baseAxis");
        const columnsTemplate = this.columns.template;
        if (this.isDirty("fill")) {
            if (columnsTemplate.get("fill") == null) {
                columnsTemplate.set("fill", this.get("fill"));
            }
        }
        if (this.isDirty("stroke")) {
            if (columnsTemplate.get("stroke") == null) {
                columnsTemplate.set("stroke", this.get("stroke"));
            }
        }
        let index = 0;
        let clusterCount = 0;
        let i = 0;
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](baseAxis.series, (series) => {
            if (series instanceof BaseColumnSeries) {
                const stacked = series.get("stacked");
                if (stacked && i == 0) {
                    clusterCount++;
                }
                if (!stacked && series.get("clustered")) {
                    clusterCount++;
                }
            }
            if (series === this) {
                index = clusterCount - 1;
            }
            i++;
        });
        if (!this.get("clustered")) {
            index = 0;
            clusterCount = 1;
        }
        if (clusterCount === 0) {
            clusterCount = 1;
            index = 0;
        }
        const xRenderer = xAxis.get("renderer");
        const yRenderer = yAxis.get("renderer");
        const cellStartLocation = "cellStartLocation";
        const cellEndLocation = "cellEndLocation";
        const cellLocationX0 = xRenderer.get(cellStartLocation, 0);
        const cellLocationX1 = xRenderer.get(cellEndLocation, 1);
        const cellLocationY0 = yRenderer.get(cellStartLocation, 0);
        const cellLocationY1 = yRenderer.get(cellEndLocation, 1);
        this._aLocationX0 = cellLocationX0 + (index / clusterCount) * (cellLocationX1 - cellLocationX0);
        this._aLocationX1 = cellLocationX0 + (index + 1) / clusterCount * (cellLocationX1 - cellLocationX0);
        ;
        this._aLocationY0 = cellLocationY0 + (index / clusterCount) * (cellLocationY1 - cellLocationY0);
        this._aLocationY1 = cellLocationY0 + (index + 1) / clusterCount * (cellLocationY1 - cellLocationY0);
        if (xAxis.inited && yAxis.inited) {
            if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty) {
                const len = this.dataItems.length;
                let startIndex = Math.max(0, this.startIndex() - 2);
                let endIndex = Math.min(this.endIndex() + 2, len - 1);
                for (let i = 0; i < startIndex; i++) {
                    this._toggleColumn(this.dataItems[i], false);
                }
                let previous = this.dataItems[startIndex];
                for (let i = startIndex; i <= endIndex; i++) {
                    let dataItem = this.dataItems[i];
                    if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                        previous = dataItem;
                        if (i > 0 && startIndex > 0) {
                            for (let j = i - 1; j >= 0; j--) {
                                let dataItem = this.dataItems[j];
                                if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                                    previous = dataItem;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                    else {
                        this._toggleColumn(dataItem, false);
                    }
                }
                for (let i = startIndex; i <= endIndex; i++) {
                    let dataItem = this.dataItems[i];
                    this._updateGraphics(dataItem, previous);
                    if (dataItem.get("valueX") != null && dataItem.get("valueY") != null) {
                        previous = dataItem;
                    }
                }
                for (let i = endIndex + 1; i < len; i++) {
                    this._toggleColumn(this.dataItems[i], false);
                }
            }
        }
        else {
            this._skipped = true;
        }
        this.updateLegendMarker(this.get("tooltipDataItem"));
        super._updateChildren();
    }
    _createGraphics(dataItem) {
        let graphics = dataItem.get("graphics");
        if (!graphics) {
            graphics = this._makeGraphics(this.columns, dataItem);
            dataItem.set("graphics", graphics);
            graphics._setDataItem(dataItem);
            const legendDataItem = dataItem.get("legendDataItem");
            if (legendDataItem) {
                const markerRectangle = legendDataItem.get("markerRectangle");
                if (markerRectangle) {
                    markerRectangle.setAll({ fill: graphics.get("fill"), stroke: graphics.get("stroke") });
                }
            }
            this.axisRanges.each((axisRange) => {
                const container = axisRange.container;
                const graphicsArray = dataItem.get("rangeGraphics", []);
                dataItem.set("rangeGraphics", graphicsArray);
                const rangeGraphics = this._makeGraphics(axisRange.columns, dataItem);
                graphicsArray.push(rangeGraphics);
                rangeGraphics.setPrivate("list", axisRange.columns);
                container.children.push(rangeGraphics);
            });
        }
    }
    _updateGraphics(dataItem, previousDataItem) {
        let graphics = dataItem.get("graphics");
        //if (!graphics) {
        //	this._createGraphics(dataItem);
        //	graphics = dataItem.get("graphics")!;
        //}
        const xField = this._xField;
        const yField = this._yField;
        const valueX = dataItem.get(xField);
        const valueY = dataItem.get(yField);
        if (valueX != null && valueY != null) {
            const xOpenField = this._xOpenField;
            const yOpenField = this._yOpenField;
            const locationX = this.get("locationX", dataItem.get("locationX", 0.5));
            const locationY = this.get("locationY", dataItem.get("locationY", 0.5));
            const openLocationX = this.get("openLocationX", dataItem.get("openLocationX", locationX));
            const openLocationY = this.get("openLocationY", dataItem.get("openLocationY", locationY));
            const width = graphics.get("width");
            const height = graphics.get("height");
            const stacked = this.get("stacked");
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const baseAxis = this.get("baseAxis");
            const xStart = xAxis.get("start");
            const xEnd = xAxis.get("end");
            const yStart = yAxis.get("start");
            const yEnd = yAxis.get("end");
            let l;
            let r;
            let t;
            let b;
            let vcy = this.get("vcy", 1);
            let vcx = this.get("vcx", 1);
            let fitW = false;
            let fitH = false;
            if (yAxis.isType("CategoryAxis") && xAxis.isType("CategoryAxis")) {
                let startLocation = this._aLocationX0 + openLocationX - 0.5;
                let endLocation = this._aLocationX1 + locationX - 0.5;
                if (width instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["Percent"]) {
                    let offset = (endLocation - startLocation) * (1 - width.value) / 2;
                    startLocation += offset;
                    endLocation -= offset;
                }
                l = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);
                r = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);
                startLocation = this._aLocationY0 + openLocationY - 0.5;
                endLocation = this._aLocationY1 + locationY - 0.5;
                if (height instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["Percent"]) {
                    let offset = (endLocation - startLocation) * (1 - height.value) / 2;
                    startLocation += offset;
                    endLocation -= offset;
                }
                t = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);
                b = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);
                dataItem.setRaw("point", { x: l + (r - l) / 2, y: t + (b - t) / 2 });
            }
            else if (xAxis === baseAxis) {
                let startLocation = this._aLocationX0 + openLocationX - 0.5;
                let endLocation = this._aLocationX1 + locationX - 0.5;
                if (width instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["Percent"]) {
                    let offset = (endLocation - startLocation) * (1 - width.value) / 2;
                    startLocation += offset;
                    endLocation -= offset;
                }
                l = xAxis.getDataItemPositionX(dataItem, xOpenField, startLocation, vcx);
                r = xAxis.getDataItemPositionX(dataItem, xField, endLocation, vcx);
                t = yAxis.getDataItemPositionY(dataItem, yField, locationY, vcy);
                if (this._yOpenField !== this._yField) {
                    b = yAxis.getDataItemPositionY(dataItem, yOpenField, openLocationY, vcy);
                }
                else {
                    if (stacked) {
                        let stackToItemY = dataItem.get("stackToItemY");
                        if (stackToItemY) {
                            b = yAxis.getDataItemPositionY(stackToItemY, yField, openLocationY, stackToItemY.component.get("vcy"));
                        }
                        else {
                            b = yAxis.basePosition();
                        }
                    }
                    else {
                        b = yAxis.basePosition();
                    }
                }
                dataItem.setRaw("point", { x: l + (r - l) / 2, y: t });
                fitH = true;
            }
            else if (yAxis === baseAxis) {
                let startLocation = this._aLocationY0 + openLocationY - 0.5;
                let endLocation = this._aLocationY1 + locationY - 0.5;
                if (height instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["Percent"]) {
                    let offset = (endLocation - startLocation) * (1 - height.value) / 2;
                    startLocation += offset;
                    endLocation -= offset;
                }
                t = yAxis.getDataItemPositionY(dataItem, yOpenField, startLocation, vcy);
                b = yAxis.getDataItemPositionY(dataItem, yField, endLocation, vcy);
                r = xAxis.getDataItemPositionX(dataItem, xField, locationX, vcx);
                if (this._xOpenField !== this._xField) {
                    l = xAxis.getDataItemPositionX(dataItem, xOpenField, openLocationX, vcx);
                }
                else {
                    if (stacked) {
                        let stackToItemX = dataItem.get("stackToItemX");
                        if (stackToItemX) {
                            l = xAxis.getDataItemPositionX(stackToItemX, xField, openLocationX, stackToItemX.component.get("vcx"));
                        }
                        else {
                            l = xAxis.basePosition();
                        }
                    }
                    else {
                        l = xAxis.basePosition();
                    }
                }
                fitW = true;
                dataItem.setRaw("point", { x: r, y: t + (b - t) / 2 });
            }
            this._updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH);
            if ((l < xStart && r < xStart) || (l > xEnd && r > xEnd) || (t < yStart && b <= yStart) || (t >= yEnd && b > yEnd) || _core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNaN"](l) || _core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNaN"](t)) {
                this._toggleColumn(dataItem, false);
            }
            else {
                this._toggleColumn(dataItem, true);
            }
            let rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](rangeGraphics, (graphics) => {
                    this._updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH);
                });
            }
            this._applyGraphicsStates(dataItem, previousDataItem);
        }
    }
    _updateSeriesGraphics(dataItem, graphics, l, r, t, b, fitW, fitH) {
        const width = graphics.get("width");
        const height = graphics.get("height");
        const maxWidth = graphics.get("maxWidth");
        const maxHeight = graphics.get("maxHeight");
        const ptl = this.getPoint(l, t);
        const pbr = this.getPoint(r, b);
        const tooltipPoint = dataItem.get("point");
        if (tooltipPoint) {
            const point = this.getPoint(tooltipPoint.x, tooltipPoint.y);
            tooltipPoint.x = point.x + this._x;
            tooltipPoint.y = point.y + this._y;
        }
        l = ptl.x;
        r = pbr.x;
        t = ptl.y;
        b = pbr.y;
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](width)) {
            const offset = ((r - l) - width) / 2;
            l += offset;
            r -= offset;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](maxWidth) && maxWidth < Math.abs(r - l)) {
            const offset = ((r - l) - maxWidth) / 2;
            l += offset;
            r -= offset;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](height)) {
            const offset = ((b - t) - height) / 2;
            t += offset;
            b -= offset;
        }
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](maxHeight) && maxHeight < Math.abs(b - t)) {
            const offset = ((b - t) - maxHeight) / 2;
            t += offset;
            b -= offset;
        }
        if (this.get("adjustBulletPosition")) {
            if (fitW) {
                r = Math.min(Math.max(0, r), this._pw);
                l = Math.min(Math.max(0, l), this._pw);
            }
            if (fitH) {
                t = Math.min(Math.max(0, t), this._ph);
                b = Math.min(Math.max(0, b), this._ph);
            }
        }
        dataItem.setRaw("left", l);
        dataItem.setRaw("right", r);
        dataItem.setRaw("top", t);
        dataItem.setRaw("bottom", b);
        graphics.setPrivate("width", r - l);
        graphics.setPrivate("height", b - t);
        graphics.set("x", l);
        graphics.set("y", b - (b - t));
    }
    _handleDataSetChange() {
        super._handleDataSetChange();
        _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this._dataItems, (dataItem) => {
            this._toggleColumn(dataItem, false);
        });
    }
    _applyGraphicsStates(dataItem, previousDataItem) {
        const graphics = dataItem.get("graphics");
        const dropFromOpen = graphics.states.lookup("dropFromOpen");
        const riseFromOpen = graphics.states.lookup("riseFromOpen");
        const dropFromPrevious = graphics.states.lookup("dropFromPrevious");
        const riseFromPrevious = graphics.states.lookup("riseFromPrevious");
        if (dropFromOpen || dropFromPrevious || riseFromOpen || riseFromPrevious) {
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const baseAxis = this.get("baseAxis");
            let open;
            let close;
            let previousClose;
            if (baseAxis === xAxis && yAxis.isType("ValueAxis")) {
                open = dataItem.get(this._yOpenField);
                close = dataItem.get(this._yField);
                previousClose = previousDataItem.get(this._yField);
            }
            else if (baseAxis === yAxis && xAxis.isType("ValueAxis")) {
                open = dataItem.get(this._xOpenField);
                close = dataItem.get(this._xField);
                previousClose = previousDataItem.get(this._xField);
            }
            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](open) && _core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](close)) {
                if (close < open) {
                    if (dropFromOpen) {
                        dropFromOpen.apply();
                    }
                }
                else {
                    if (riseFromOpen) {
                        riseFromOpen.apply();
                    }
                }
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_5__["isNumber"](previousClose)) {
                    if (close < previousClose) {
                        if (dropFromPrevious) {
                            dropFromPrevious.apply();
                        }
                    }
                    else {
                        if (riseFromPrevious) {
                            riseFromPrevious.apply();
                        }
                    }
                }
            }
        }
    }
    /**
     * @ignore
     */
    disposeDataItem(dataItem) {
        super.disposeDataItem(dataItem);
        const graphics = dataItem.get("graphics");
        if (graphics) {
            this.columns.removeValue(graphics);
            graphics.dispose();
        }
        const rangeGraphics = dataItem.get("rangeGraphics");
        if (rangeGraphics) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](rangeGraphics, (graphics) => {
                const list = graphics.getPrivate("list");
                if (list) {
                    list.removeValue(graphics);
                }
                graphics.dispose();
            });
        }
    }
    /**
     * Hides series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    hideDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            hideDataItem: { get: () => super.hideDataItem }
        });
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const promises = [_super.hideDataItem.call(this, dataItem, duration)];
            const graphics = dataItem.get("graphics");
            if (graphics) {
                promises.push(graphics.hide(duration));
            }
            const rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](rangeGraphics, (graphics) => {
                    promises.push(graphics.hide(duration));
                });
            }
            yield Promise.all(promises);
        });
    }
    _toggleColumn(dataItem, visible) {
        const graphics = dataItem.get("graphics");
        if (graphics) {
            graphics.setPrivate("visible", visible);
        }
        const rangeGraphics = dataItem.get("rangeGraphics");
        if (rangeGraphics) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](rangeGraphics, (graphics) => {
                graphics.setPrivate("visible", visible);
            });
        }
        const bullets = dataItem.bullets;
        if (bullets) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](bullets, (bullet) => {
                bullet.setPrivate("hidden", !visible);
            });
        }
    }
    /**
     * Shows series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    showDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            showDataItem: { get: () => super.showDataItem }
        });
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const promises = [_super.showDataItem.call(this, dataItem, duration)];
            const graphics = dataItem.get("graphics");
            if (graphics) {
                promises.push(graphics.show(duration));
            }
            const rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](rangeGraphics, (graphics) => {
                    promises.push(graphics.show(duration));
                });
            }
            yield Promise.all(promises);
        });
    }
    /**
     * @ignore
     */
    updateLegendMarker(dataItem) {
        let legendDataItem = this.get("legendDataItem");
        if (this.get("useLastColorForLegendMarker")) {
            if (!dataItem) {
                const lastDataItem = this.dataItems[this.endIndex() - 1];
                if (lastDataItem) {
                    dataItem = lastDataItem;
                }
            }
        }
        if (legendDataItem) {
            let graphics = this.columns.template;
            if (dataItem) {
                let column = dataItem.get("graphics");
                if (column) {
                    graphics = column;
                }
            }
            const markerRectangle = legendDataItem.get("markerRectangle");
            if (markerRectangle) {
                if (!legendDataItem.get("itemContainer").get("disabled")) {
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](_core_render_Graphics__WEBPACK_IMPORTED_MODULE_3__["visualSettings"], (setting) => {
                        markerRectangle.set(setting, graphics.get(setting, this.get(setting)));
                    });
                }
            }
        }
    }
    _getTooltipTarget(dataItem) {
        if (this.get("seriesTooltipTarget") == "bullet") {
            return super._getTooltipTarget(dataItem);
        }
        let column = dataItem.get("graphics");
        if (column) {
            return column;
        }
        return this;
    }
}
Object.defineProperty(BaseColumnSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "BaseColumnSeries"
});
Object.defineProperty(BaseColumnSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _XYSeries__WEBPACK_IMPORTED_MODULE_1__["XYSeries"].classNames.concat([BaseColumnSeries.className])
});
//# sourceMappingURL=BaseColumnSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/Candlestick.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/Candlestick.js ***!
  \************************************************************************************/
/*! exports provided: Candlestick */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Candlestick", function() { return Candlestick; });
/* harmony import */ var _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");

/**
 * A candle element used in a [[CandlestickSeries]].
 */
class Candlestick extends _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__["RoundedRectangle"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("lowX0") || this.isDirty("lowY0") || this.isDirty("lowX1") || this.isDirty("lowY1") || this.isDirty("highX0") || this.isDirty("highX1") || this.isDirty("highY0") || this.isDirty("highY1")) {
            this._clear = true;
        }
    }
    _draw() {
        super._draw();
        const display = this._display;
        display.moveTo(this.get("lowX0", 0), this.get("lowY0", 0));
        display.lineTo(this.get("lowX1", 0), this.get("lowY1", 0));
        display.moveTo(this.get("highX0", 0), this.get("highY0", 0));
        display.lineTo(this.get("highX1", 0), this.get("highY1", 0));
    }
}
Object.defineProperty(Candlestick, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Candlestick"
});
Object.defineProperty(Candlestick, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__["RoundedRectangle"].classNames.concat([Candlestick.className])
});
//# sourceMappingURL=Candlestick.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/CandlestickSeries.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/CandlestickSeries.js ***!
  \******************************************************************************************/
/*! exports provided: CandlestickSeries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CandlestickSeries", function() { return CandlestickSeries; });
/* harmony import */ var _ColumnSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColumnSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js");
/* harmony import */ var _Candlestick__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Candlestick */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/Candlestick.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");






/**
 * Candlestick series.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/candlestick-series/} for more info
 * @important
 */
class CandlestickSeries extends _ColumnSeries__WEBPACK_IMPORTED_MODULE_0__["ColumnSeries"] {
    constructor() {
        super(...arguments);
        /**
         * A list of candles in the series.
         *
         * `columns.template` can be used to configure candles.
         *
         * @default new ListTemplate<Candlestick>
         */
        Object.defineProperty(this, "columns", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_3__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_2__["Template"].new({
                themeTags: ["autocolor"]
            }), () => _Candlestick__WEBPACK_IMPORTED_MODULE_1__["Candlestick"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__["mergeTags"](this.columns.template.get("themeTags", []), ["candlestick", "series", "column"])
            }, [this.columns.template]))
        });
    }
    /**
     * @ignore
     */
    makeColumn(dataItem, listTemplate) {
        const column = this.mainContainer.children.push(listTemplate.make());
        column._setDataItem(dataItem);
        listTemplate.push(column);
        return column;
    }
    _updateGraphics(dataItem, previousDataItem) {
        super._updateGraphics(dataItem, previousDataItem);
        const xAxis = this.getRaw("xAxis");
        const yAxis = this.getRaw("yAxis");
        const baseAxis = this.getRaw("baseAxis");
        let vcy = this.get("vcy", 1);
        let vcx = this.get("vcx", 1);
        let lx0;
        let lx1;
        let ly0;
        let ly1;
        let hx0;
        let hx1;
        let hy0;
        let hy1;
        let locationX = this.get("locationX", dataItem.get("locationX", 0.5));
        let locationY = this.get("locationY", dataItem.get("locationY", 0.5));
        let openLocationX = this.get("openLocationX", dataItem.get("openLocationX", locationX));
        let openLocationY = this.get("openLocationY", dataItem.get("openLocationY", locationY));
        let orientation;
        if (yAxis === baseAxis) {
            let open = xAxis.getDataItemPositionX(dataItem, this._xOpenField, 1, vcx);
            let close = xAxis.getDataItemPositionX(dataItem, this._xField, 1, vcx);
            lx1 = xAxis.getDataItemPositionX(dataItem, this._xLowField, 1, vcx);
            hx1 = xAxis.getDataItemPositionX(dataItem, this._xHighField, 1, vcx);
            hx0 = Math.max(open, close);
            lx0 = Math.min(open, close);
            let startLocation = this._aLocationY0 + openLocationY - 0.5;
            let endLocation = this._aLocationY1 + locationY - 0.5;
            ly0 = yAxis.getDataItemPositionY(dataItem, this._yField, startLocation + (endLocation - startLocation) / 2, vcy);
            ly1 = ly0;
            hy0 = ly0;
            hy1 = ly0;
            orientation = "horizontal";
        }
        else {
            let open = yAxis.getDataItemPositionY(dataItem, this._yOpenField, 1, vcy);
            let close = yAxis.getDataItemPositionY(dataItem, this._yField, 1, vcy);
            ly1 = yAxis.getDataItemPositionY(dataItem, this._yLowField, 1, vcy);
            hy1 = yAxis.getDataItemPositionY(dataItem, this._yHighField, 1, vcy);
            hy0 = Math.max(open, close);
            ly0 = Math.min(open, close);
            let startLocation = this._aLocationX0 + openLocationX - 0.5;
            let endLocation = this._aLocationX1 + locationX - 0.5;
            lx0 = xAxis.getDataItemPositionX(dataItem, this._xField, startLocation + (endLocation - startLocation) / 2, vcx);
            lx1 = lx0;
            hx0 = lx0;
            hx1 = lx0;
            orientation = "vertical";
        }
        this._updateCandleGraphics(dataItem, lx0, lx1, ly0, ly1, hx0, hx1, hy0, hy1, orientation);
    }
    _updateCandleGraphics(dataItem, lx0, lx1, ly0, ly1, hx0, hx1, hy0, hy1, orientation) {
        let column = dataItem.get("graphics");
        if (column) {
            let pl0 = this.getPoint(lx0, ly0);
            let pl1 = this.getPoint(lx1, ly1);
            let ph0 = this.getPoint(hx0, hy0);
            let ph1 = this.getPoint(hx1, hy1);
            let x = column.x();
            let y = column.y();
            column.set("lowX0", pl0.x - x);
            column.set("lowY0", pl0.y - y);
            column.set("lowX1", pl1.x - x);
            column.set("lowY1", pl1.y - y);
            column.set("highX0", ph0.x - x);
            column.set("highY0", ph0.y - y);
            column.set("highX1", ph1.x - x);
            column.set("highY1", ph1.y - y);
            column.set("orientation", orientation);
            let rangeGraphics = dataItem.get("rangeGraphics");
            if (rangeGraphics) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_5__["each"](rangeGraphics, (column) => {
                    column.set("lowX0", pl0.x - x);
                    column.set("lowY0", pl0.y - y);
                    column.set("lowX1", pl1.x - x);
                    column.set("lowY1", pl1.y - y);
                    column.set("highX0", ph0.x - x);
                    column.set("highY0", ph0.y - y);
                    column.set("highX1", ph1.x - x);
                    column.set("highY1", ph1.y - y);
                    column.set("orientation", orientation);
                });
            }
        }
    }
    _processAxisRange(axisRange) {
        super._processAxisRange(axisRange);
        axisRange.columns = new _core_util_List__WEBPACK_IMPORTED_MODULE_3__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_2__["Template"].new({}), () => _Candlestick__WEBPACK_IMPORTED_MODULE_1__["Candlestick"]._new(this._root, {
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__["mergeTags"](axisRange.columns.template.get("themeTags", []), ["candlestick", "series", "column"]),
        }, [this.columns.template, axisRange.columns.template]));
    }
}
Object.defineProperty(CandlestickSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "CandlestickSeries"
});
Object.defineProperty(CandlestickSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _ColumnSeries__WEBPACK_IMPORTED_MODULE_0__["ColumnSeries"].classNames.concat([CandlestickSeries.className])
});
//# sourceMappingURL=CandlestickSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js ***!
  \*************************************************************************************/
/*! exports provided: ColumnSeries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColumnSeries", function() { return ColumnSeries; });
/* harmony import */ var _BaseColumnSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseColumnSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");





class ColumnSeries extends _BaseColumnSeries__WEBPACK_IMPORTED_MODULE_0__["BaseColumnSeries"] {
    constructor() {
        super(...arguments);
        /**
         * A [[TemplateList]] of all columns in series.
         *
         * `columns.template` can be used to set default settings for all columns,
         * or to change on existing ones.
         */
        Object.defineProperty(this, "columns", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_2__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_1__["Template"].new({}), () => _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__["RoundedRectangle"]._new(this._root, {
                position: "absolute",
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__["mergeTags"](this.columns.template.get("themeTags", []), ["series", "column"])
            }, [this.columns.template]))
        });
    }
    /**
     * @ignore
     */
    makeColumn(dataItem, listTemplate) {
        const column = this.mainContainer.children.push(listTemplate.make());
        column._setDataItem(dataItem);
        listTemplate.push(column);
        return column;
    }
    _processAxisRange(axisRange) {
        super._processAxisRange(axisRange);
        axisRange.columns = new _core_util_List__WEBPACK_IMPORTED_MODULE_2__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_1__["Template"].new({}), () => _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__["RoundedRectangle"]._new(this._root, {
            position: "absolute",
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__["mergeTags"](axisRange.columns.template.get("themeTags", []), ["series", "column"]),
        }, [this.columns.template, axisRange.columns.template]));
    }
}
Object.defineProperty(ColumnSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "ColumnSeries"
});
Object.defineProperty(ColumnSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _BaseColumnSeries__WEBPACK_IMPORTED_MODULE_0__["BaseColumnSeries"].classNames.concat([ColumnSeries.className])
});
//# sourceMappingURL=ColumnSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js ***!
  \***********************************************************************************/
/*! exports provided: LineSeries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSeries", function() { return LineSeries; });
/* harmony import */ var _XYSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XYSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/index.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");











/**
 * Used to plot line and/or area series.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/line-series/} for more info
 * @important
 */
class LineSeries extends _XYSeries__WEBPACK_IMPORTED_MODULE_0__["XYSeries"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_endIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_strokeGenerator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Object(d3_shape__WEBPACK_IMPORTED_MODULE_2__["line"])()
        });
        Object.defineProperty(this, "_fillGenerator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Object(d3_shape__WEBPACK_IMPORTED_MODULE_2__["area"])()
        });
        Object.defineProperty(this, "_legendStroke", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_legendFill", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A [[TemplateList]] of all line segments in series.
         *
         * `strokes.template` can be used to set default settings for all line
         * segments, or to change on existing ones.
         *
         * @default new ListTemplate<Graphics>
         */
        Object.defineProperty(this, "strokes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_4__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_3__["Template"].new({}), () => _core_render_Graphics__WEBPACK_IMPORTED_MODULE_1__["Graphics"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_10__["mergeTags"](this.strokes.template.get("themeTags", []), ["line", "series", "stroke"])
            }, [this.strokes.template]))
        });
        /**
         * A [[TemplateList]] of all segment fills in series.
         *
         * `fills.template` can be used to set default settings for all segment
         * fills, or to change on existing ones.
         *
         * @default new ListTemplate<Graphics>
         */
        Object.defineProperty(this, "fills", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_4__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_3__["Template"].new({}), () => _core_render_Graphics__WEBPACK_IMPORTED_MODULE_1__["Graphics"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_10__["mergeTags"](this.strokes.template.get("themeTags", []), ["line", "series", "fill"])
            }, [this.fills.template]))
        });
        // custom set from data
        Object.defineProperty(this, "_fillTemplate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_strokeTemplate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_previousPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [0, 0, 0, 0]
        });
        Object.defineProperty(this, "_dindex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_sindex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    _afterNew() {
        this._fillGenerator.y0(function (p) {
            return p[3];
        });
        this._fillGenerator.x0(function (p) {
            return p[2];
        });
        this._fillGenerator.y1(function (p) {
            return p[1];
        });
        this._fillGenerator.x1(function (p) {
            return p[0];
        });
        super._afterNew();
    }
    /**
     * @ignore
     */
    makeStroke(strokes) {
        const stroke = this.mainContainer.children.push(strokes.make());
        strokes.push(stroke);
        return stroke;
    }
    /**
     * @ignore
     */
    makeFill(fills) {
        const fill = this.mainContainer.children.push(fills.make());
        fills.push(fill);
        return fill;
    }
    _updateChildren() {
        this._strokeTemplate = undefined;
        this._fillTemplate = undefined;
        let xAxis = this.get("xAxis");
        let yAxis = this.get("yAxis");
        if (this.isDirty("stroke")) {
            const stroke = this.get("stroke");
            this.strokes.template.set("stroke", stroke);
            const legendStroke = this._legendStroke;
            if (legendStroke) {
                legendStroke.states.lookup("default").set("stroke", stroke);
            }
        }
        if (this.isDirty("fill")) {
            const fill = this.get("fill");
            this.fills.template.set("fill", fill);
            const legendFill = this._legendFill;
            if (legendFill) {
                legendFill.states.lookup("default").set("fill", fill);
            }
        }
        if (this.isDirty("curveFactory")) {
            const curveFactory = this.get("curveFactory");
            if (curveFactory) {
                this._strokeGenerator.curve(curveFactory);
                this._fillGenerator.curve(curveFactory);
            }
        }
        if (xAxis.inited && yAxis.inited) {
            if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty || this.isDirty("connect") || this.isDirty("curveFactory")) {
                this.fills.each((fill) => {
                    fill.setPrivate("visible", false);
                });
                this.strokes.each((fill) => {
                    fill.setPrivate("visible", false);
                });
                this.axisRanges.each((axisRange) => {
                    let fills = axisRange.fills;
                    if (fills) {
                        fills.each((fill) => {
                            fill.setPrivate("visible", false);
                        });
                    }
                    let strokes = axisRange.strokes;
                    if (strokes) {
                        strokes.each((stroke) => {
                            stroke.setPrivate("visible", false);
                        });
                    }
                });
                let startIndex = this.startIndex();
                let strokeTemplateField = this.strokes.template.get("templateField");
                let fillTemplateField = this.fills.template.get("templateField");
                let strokeTemplateFound = true;
                let fillTemplateFound = true;
                if (strokeTemplateField) {
                    strokeTemplateFound = false;
                }
                if (fillTemplateField) {
                    fillTemplateFound = false;
                }
                for (let i = startIndex - 1; i >= 0; i--) {
                    let dataItem = this.dataItems[i];
                    let hasValues = true;
                    let dataContext = dataItem.dataContext;
                    if (strokeTemplateField) {
                        if (dataContext[strokeTemplateField]) {
                            strokeTemplateFound = true;
                        }
                    }
                    if (fillTemplateField) {
                        if (dataContext[fillTemplateField]) {
                            fillTemplateFound = true;
                        }
                    }
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](this._valueFields, (field) => {
                        if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_8__["isNumber"](dataItem.get(field))) {
                            hasValues = false;
                        }
                    });
                    if (hasValues && strokeTemplateFound && fillTemplateFound) {
                        startIndex = i;
                        break;
                    }
                }
                let len = this.dataItems.length;
                let endIndex = this.endIndex();
                if (endIndex < len) {
                    endIndex++;
                    for (let i = endIndex; i < len; i++) {
                        let dataItem = this.dataItems[i];
                        let hasValues = true;
                        _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](this._valueFields, (field) => {
                            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_8__["isNumber"](dataItem.get(field))) {
                                hasValues = false;
                            }
                        });
                        if (hasValues) {
                            endIndex = i + 1;
                            break;
                        }
                    }
                }
                if (startIndex > 0) {
                    startIndex--;
                }
                this._endIndex = endIndex;
                this._clearGraphics();
                this._sindex = 0;
                this._dindex = startIndex;
                if (this.dataItems.length == 1) {
                    this._startSegment(0);
                }
                else {
                    // this is done to avoid recursion with a lot of segments 
                    while (this._dindex < endIndex - 1) {
                        this._startSegment(this._dindex);
                        this._sindex++;
                    }
                }
            }
        }
        else {
            this._skipped = true;
        }
        super._updateChildren();
    }
    _clearGraphics() {
        this.strokes.clear();
        this.fills.clear();
    }
    _startSegment(dataItemIndex) {
        let endIndex = this._endIndex;
        let currentEndIndex = endIndex;
        const autoGapCount = this.get("autoGapCount");
        const connect = this.get("connect");
        const fill = this.makeFill(this.fills);
        const fillTemplate = this._fillTemplate;
        const originalTemplate = this.fills.template;
        if (fillTemplate && fillTemplate != originalTemplate) {
            fill.template = fillTemplate;
        }
        fill.setPrivate("visible", true);
        const stroke = this.makeStroke(this.strokes);
        const strokeTemplate = this._strokeTemplate;
        if (strokeTemplate && strokeTemplate != this.strokes.template) {
            stroke.template = strokeTemplate;
        }
        stroke.setPrivate("visible", true);
        let xAxis = this.get("xAxis");
        let yAxis = this.get("yAxis");
        let baseAxis = this.get("baseAxis");
        let vcx = this.get("vcx", 1);
        let vcy = this.get("vcy", 1);
        let xField = this._xField;
        let yField = this._yField;
        let xOpenField = this._xOpenField;
        let yOpenField = this._yOpenField;
        const xOpenFieldValue = this.get("openValueXField");
        const yOpenFieldValue = this.get("openValueYField");
        if (!xOpenFieldValue) {
            xOpenField = this._xField;
        }
        if (!yOpenFieldValue) {
            yOpenField = this._yField;
        }
        const stacked = this.get("stacked");
        const basePosX = xAxis.basePosition();
        const basePosY = yAxis.basePosition();
        let baseField;
        if (baseAxis === yAxis) {
            baseField = this._yField;
        }
        else {
            baseField = this._xField;
        }
        const segments = [];
        let points = [];
        segments.push(points);
        const strokeTemplateField = this.strokes.template.get("templateField");
        const fillTemplateField = this.fills.template.get("templateField");
        let locationX = this.get("locationX", 0.5);
        let locationY = this.get("locationY", 0.5);
        let openLocationX = this.get("openLocationX", locationX);
        let openLocationY = this.get("openLocationY", locationY);
        const minDistance = this.get("minDistance", 0);
        let i;
        let fillVisible = this.fills.template.get("visible");
        if (this.axisRanges.length > 0) {
            fillVisible = true;
        }
        let getOpen = false;
        if (stacked || xOpenFieldValue || yOpenFieldValue) {
            getOpen = true;
        }
        const o = {
            points, segments, stacked, getOpen, basePosX, basePosY, fillVisible, xField, yField, xOpenField, yOpenField, vcx, vcy, baseAxis, xAxis, yAxis, locationX, locationY, openLocationX, openLocationY, minDistance
        };
        for (i = dataItemIndex; i < currentEndIndex; i++) {
            this._dindex = i;
            const dataItem = this._dataItems[i];
            let valueX = dataItem.get(xField);
            let valueY = dataItem.get(yField);
            if (valueX == null || valueY == null) {
                if (!connect) {
                    points = [];
                    segments.push(points);
                    o.points = points;
                }
            }
            else {
                this._getPoints(dataItem, o);
            }
            if (strokeTemplateField) {
                let strokeTemplate = dataItem.dataContext[strokeTemplateField];
                if (strokeTemplate) {
                    if (!(strokeTemplate instanceof _core_util_Template__WEBPACK_IMPORTED_MODULE_3__["Template"])) {
                        strokeTemplate = _core_util_Template__WEBPACK_IMPORTED_MODULE_3__["Template"].new(strokeTemplate);
                    }
                    this._strokeTemplate = strokeTemplate;
                    if (i > dataItemIndex) {
                        currentEndIndex = i;
                        break;
                    }
                    else {
                        stroke.template = strokeTemplate;
                    }
                }
            }
            if (fillTemplateField) {
                let fillTemplate = dataItem.dataContext[fillTemplateField];
                if (fillTemplate) {
                    if (!(fillTemplate instanceof _core_util_Template__WEBPACK_IMPORTED_MODULE_3__["Template"])) {
                        fillTemplate = _core_util_Template__WEBPACK_IMPORTED_MODULE_3__["Template"].new(fillTemplate);
                    }
                    this._fillTemplate = fillTemplate;
                    if (i > dataItemIndex) {
                        currentEndIndex = i;
                        break;
                    }
                    else {
                        fill.template = fillTemplate;
                    }
                }
            }
            if (!connect) {
                let nextItem = this.dataItems[i + 1];
                if (nextItem) {
                    if (baseAxis.shouldGap(dataItem, nextItem, autoGapCount, baseField)) {
                        points = [];
                        segments.push(points);
                        o.points = points;
                    }
                }
            }
        }
        fill.setRaw("userData", [dataItemIndex, i]);
        stroke.setRaw("userData", [dataItemIndex, i]);
        if (i === endIndex) {
            this._endLine(points, segments[0][0]);
        }
        if (stroke) {
            this._drawStroke(stroke, segments);
        }
        if (fill) {
            this._drawFill(fill, segments);
        }
        this.axisRanges.each((axisRange) => {
            const container = axisRange.container;
            const fills = axisRange.fills;
            const fill = this.makeFill(fills);
            if (container) {
                container.children.push(fill);
            }
            fill.setPrivate("visible", true);
            this._drawFill(fill, segments);
            const strokes = axisRange.strokes;
            const stroke = this.makeStroke(strokes);
            if (container) {
                container.children.push(stroke);
            }
            stroke.setPrivate("visible", true);
            this._drawStroke(stroke, segments);
            fill.setRaw("userData", [dataItemIndex, i]);
            stroke.setRaw("userData", [dataItemIndex, i]);
        });
    }
    _getPoints(dataItem, o) {
        let points = o.points;
        let itemLocationX = dataItem.get("locationX", o.locationX);
        let itemLocationY = dataItem.get("locationY", o.locationY);
        let xPos = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX, o.vcx);
        let yPos = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY, o.vcy);
        if (this._shouldInclude(xPos)) {
            const iPoint = this.getPoint(xPos, yPos);
            const point = [iPoint.x, iPoint.y];
            iPoint.x += this._x;
            iPoint.y += this._y;
            dataItem.set("point", iPoint);
            if (o.fillVisible) {
                let xPos0 = xPos;
                let yPos0 = yPos;
                if (o.baseAxis === o.xAxis) {
                    yPos0 = o.basePosY;
                }
                else if (o.baseAxis === o.yAxis) {
                    xPos0 = o.basePosX;
                }
                if (o.getOpen) {
                    let valueX = dataItem.get(o.xOpenField);
                    let valueY = dataItem.get(o.yOpenField);
                    if (valueX != null && valueY != null) {
                        let itemLocationX = dataItem.get("openLocationX", o.openLocationX);
                        let itemLocationY = dataItem.get("openLocationY", o.openLocationY);
                        if (o.stacked) {
                            let stackToItemX = dataItem.get("stackToItemX");
                            let stackToItemY = dataItem.get("stackToItemY");
                            if (stackToItemX) {
                                xPos0 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX, stackToItemX.component.get("vcx"));
                                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__["isNaN"](xPos0)) {
                                    xPos0 = o.basePosX;
                                }
                            }
                            else {
                                if (o.yAxis === o.baseAxis) {
                                    xPos0 = o.basePosX;
                                }
                                else {
                                    xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);
                                }
                            }
                            if (stackToItemY) {
                                yPos0 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY, stackToItemY.component.get("vcy"));
                                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_8__["isNaN"](yPos0)) {
                                    yPos0 = o.basePosY;
                                }
                            }
                            else {
                                if (o.xAxis === o.baseAxis) {
                                    yPos0 = o.basePosY;
                                }
                                else {
                                    yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);
                                }
                            }
                        }
                        else {
                            xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX, o.vcx);
                            yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY, o.vcy);
                        }
                    }
                }
                let closeIPoint = this.getPoint(xPos0, yPos0);
                point[2] = closeIPoint.x;
                point[3] = closeIPoint.y;
            }
            if (o.minDistance > 0) {
                const p0 = point[0];
                const p1 = point[1];
                const p2 = point[2];
                const p3 = point[3];
                const prev = this._previousPoint;
                const pp0 = prev[0];
                const pp1 = prev[1];
                const pp2 = prev[2];
                const pp3 = prev[3];
                if (Math.hypot(p0 - pp0, p1 - pp1) > o.minDistance || (p2 && p3 && Math.hypot(p2 - pp2, p3 - pp3) > o.minDistance)) {
                    points.push(point);
                    this._previousPoint = point;
                }
            }
            else {
                points.push(point);
            }
        }
    }
    _endLine(_points, _firstPoint) {
    }
    _drawStroke(graphics, segments) {
        if (graphics.get("visible") && !graphics.get("forceHidden")) {
            graphics.set("draw", (display) => {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](segments, (segment) => {
                    this._strokeGenerator.context(display);
                    this._strokeGenerator(segment);
                });
            });
        }
    }
    _drawFill(graphics, segments) {
        if (graphics.get("visible") && !graphics.get("forceHidden")) {
            graphics.set("draw", (display) => {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_9__["each"](segments, (segment) => {
                    this._fillGenerator.context(display);
                    this._fillGenerator(segment);
                });
            });
        }
    }
    _processAxisRange(axisRange) {
        super._processAxisRange(axisRange);
        axisRange.fills = new _core_util_List__WEBPACK_IMPORTED_MODULE_4__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_3__["Template"].new({}), () => _core_render_Graphics__WEBPACK_IMPORTED_MODULE_1__["Graphics"]._new(this._root, {
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_10__["mergeTags"](axisRange.fills.template.get("themeTags", []), ["line", "series", "fill"]),
        }, [this.fills.template, axisRange.fills.template]));
        axisRange.strokes = new _core_util_List__WEBPACK_IMPORTED_MODULE_4__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_3__["Template"].new({}), () => _core_render_Graphics__WEBPACK_IMPORTED_MODULE_1__["Graphics"]._new(this._root, {
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_10__["mergeTags"](axisRange.strokes.template.get("themeTags", []), ["line", "series", "stroke"]),
        }, [this.strokes.template, axisRange.strokes.template]));
    }
    /**
     * @ignore
     */
    createLegendMarker(_dataItem) {
        const legendDataItem = this.get("legendDataItem");
        if (legendDataItem) {
            const marker = legendDataItem.get("marker");
            const markerRectangle = legendDataItem.get("markerRectangle");
            if (markerRectangle) {
                markerRectangle.setPrivate("visible", false);
            }
            marker.set("background", _core_render_Rectangle__WEBPACK_IMPORTED_MODULE_7__["Rectangle"].new(marker._root, { fillOpacity: 0, fill: Object(_core_util_Color__WEBPACK_IMPORTED_MODULE_5__["color"])(0x000000) }));
            const legendStroke = marker.children.push(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_1__["Graphics"]._new(marker._root, {
                themeTags: ["line", "series", "legend", "marker", "stroke"], interactive: false
            }, [this.strokes.template]));
            this._legendStroke = legendStroke;
            const legendFill = marker.children.push(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_1__["Graphics"]._new(marker._root, {
                themeTags: ["line", "series", "legend", "marker", "fill"]
            }, [this.fills.template]));
            this._legendFill = legendFill;
            const disabledColor = this._root.interfaceColors.get("disabled");
            legendStroke.states.create("disabled", { fill: disabledColor, stroke: disabledColor });
            legendFill.states.create("disabled", { fill: disabledColor, stroke: disabledColor });
            if (this.bullets.length > 0) {
                const bulletFunction = this.bullets.getIndex(0);
                if (bulletFunction) {
                    const bullet = bulletFunction(marker._root, this, new _core_render_Component__WEBPACK_IMPORTED_MODULE_6__["DataItem"](this, {}, {}));
                    if (bullet) {
                        const sprite = bullet.get("sprite");
                        if (sprite instanceof _core_render_Graphics__WEBPACK_IMPORTED_MODULE_1__["Graphics"]) {
                            sprite.states.create("disabled", { fill: disabledColor, stroke: disabledColor });
                        }
                        if (sprite) {
                            sprite.set("tooltipText", undefined);
                            sprite.set("tooltipHTML", undefined);
                            marker.children.push(sprite);
                            sprite.setAll({ x: marker.width() / 2, y: marker.height() / 2 });
                        }
                    }
                }
            }
        }
    }
}
Object.defineProperty(LineSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "LineSeries"
});
Object.defineProperty(LineSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _XYSeries__WEBPACK_IMPORTED_MODULE_0__["XYSeries"].classNames.concat([LineSeries.className])
});
//# sourceMappingURL=LineSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/OHLC.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/OHLC.js ***!
  \*****************************************************************************/
/*! exports provided: OHLC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OHLC", function() { return OHLC; });
/* harmony import */ var _Candlestick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Candlestick */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/Candlestick.js");

class OHLC extends _Candlestick__WEBPACK_IMPORTED_MODULE_0__["Candlestick"] {
    _draw() {
        const display = this._display;
        display.moveTo(this.get("lowX1", 0), this.get("lowY1", 0));
        display.lineTo(this.get("highX1", 0), this.get("highY1", 0));
        let w = this.width();
        let h = this.height();
        if (this.get("orientation") == "vertical") {
            let lY = h;
            let hY = 0;
            display.moveTo(0, lY);
            display.lineTo(w / 2, lY);
            display.moveTo(w / 2, hY);
            display.lineTo(w, hY);
        }
        else {
            let lX = 0;
            let hX = w;
            display.moveTo(lX, 0);
            display.lineTo(lX, h / 2);
            display.moveTo(hX, h / 2);
            display.lineTo(hX, h);
        }
    }
}
Object.defineProperty(OHLC, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "OHLC"
});
Object.defineProperty(OHLC, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Candlestick__WEBPACK_IMPORTED_MODULE_0__["Candlestick"].classNames.concat([OHLC.className])
});
//# sourceMappingURL=OHLC.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/OHLCSeries.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/OHLCSeries.js ***!
  \***********************************************************************************/
/*! exports provided: OHLCSeries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OHLCSeries", function() { return OHLCSeries; });
/* harmony import */ var _CandlestickSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CandlestickSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/CandlestickSeries.js");
/* harmony import */ var _OHLC__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OHLC */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/OHLC.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");





/**
 * OHLC series.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/candlestick-series/} for more info
 * @important
 */
class OHLCSeries extends _CandlestickSeries__WEBPACK_IMPORTED_MODULE_0__["CandlestickSeries"] {
    constructor() {
        super(...arguments);
        /**
         * A list of OHLC bars in the series.
         *
         * `columns.template` can be used to configure OHLC bars.
         *
         * @default new ListTemplate<OHLC>
         */
        Object.defineProperty(this, "columns", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_3__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_2__["Template"].new({
                themeTags: ["autocolor"]
            }), () => _OHLC__WEBPACK_IMPORTED_MODULE_1__["OHLC"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__["mergeTags"](this.columns.template.get("themeTags", []), ["ohlc", "series", "column"])
            }, [this.columns.template]))
        });
    }
    /**
     * @ignore
     */
    makeColumn(dataItem, listTemplate) {
        const column = this.mainContainer.children.push(listTemplate.make());
        column._setDataItem(dataItem);
        listTemplate.push(column);
        return column;
    }
    _processAxisRange(axisRange) {
        super._processAxisRange(axisRange);
        axisRange.columns = new _core_util_List__WEBPACK_IMPORTED_MODULE_3__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_2__["Template"].new({}), () => _OHLC__WEBPACK_IMPORTED_MODULE_1__["OHLC"]._new(this._root, {
            themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_4__["mergeTags"](axisRange.columns.template.get("themeTags", []), ["ohlc", "series", "column"]),
        }, [this.columns.template, axisRange.columns.template]));
    }
}
Object.defineProperty(OHLCSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "OHLCSeries"
});
Object.defineProperty(OHLCSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _CandlestickSeries__WEBPACK_IMPORTED_MODULE_0__["CandlestickSeries"].classNames.concat([OHLCSeries.className])
});
//# sourceMappingURL=OHLCSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/SmoothedXLineSeries.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/SmoothedXLineSeries.js ***!
  \********************************************************************************************/
/*! exports provided: SmoothedXLineSeries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothedXLineSeries", function() { return SmoothedXLineSeries; });
/* harmony import */ var _LineSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js");
/* harmony import */ var _core_render_MonotoneXTension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/MonotoneXTension */ "./node_modules/@amcharts/amcharts5/.internal/core/render/MonotoneXTension.js");


/**
 * Smoothed line series suitable for horizontal plots.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/smoothed-series/} for more info
 */
class SmoothedXLineSeries extends _LineSeries__WEBPACK_IMPORTED_MODULE_0__["LineSeries"] {
    _afterNew() {
        this._setDefault("curveFactory", Object(_core_render_MonotoneXTension__WEBPACK_IMPORTED_MODULE_1__["curveMonotoneXTension"])(this.get("tension", 0.5)));
        super._afterNew();
    }
    _updateChildren() {
        if (this.isDirty("tension")) {
            this.set("curveFactory", Object(_core_render_MonotoneXTension__WEBPACK_IMPORTED_MODULE_1__["curveMonotoneXTension"])(this.get("tension", 0.5)));
            this._valuesDirty = true;
        }
        super._updateChildren();
    }
}
Object.defineProperty(SmoothedXLineSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "SmoothedXLineSeries"
});
Object.defineProperty(SmoothedXLineSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _LineSeries__WEBPACK_IMPORTED_MODULE_0__["LineSeries"].classNames.concat([SmoothedXLineSeries.className])
});
//# sourceMappingURL=SmoothedXLineSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/SmoothedXYLineSeries.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/SmoothedXYLineSeries.js ***!
  \*********************************************************************************************/
/*! exports provided: SmoothedXYLineSeries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothedXYLineSeries", function() { return SmoothedXYLineSeries; });
/* harmony import */ var _LineSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/index.js");


/**
 * Smoothed line series suitable for XY (scatter) charts
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/smoothed-series/} for more info
 */
class SmoothedXYLineSeries extends _LineSeries__WEBPACK_IMPORTED_MODULE_0__["LineSeries"] {
    _afterNew() {
        this._setDefault("curveFactory", d3_shape__WEBPACK_IMPORTED_MODULE_1__["curveCardinal"].tension(this.get("tension", 0.5)));
        super._afterNew();
    }
    _updateChildren() {
        if (this.isDirty("tension")) {
            this.set("curveFactory", d3_shape__WEBPACK_IMPORTED_MODULE_1__["curveCardinal"].tension(this.get("tension", 0.5)));
            this._valuesDirty = true;
        }
        super._updateChildren();
    }
}
Object.defineProperty(SmoothedXYLineSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "SmoothedXYLineSeries"
});
Object.defineProperty(SmoothedXYLineSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _LineSeries__WEBPACK_IMPORTED_MODULE_0__["LineSeries"].classNames.concat([SmoothedXYLineSeries.className])
});
//# sourceMappingURL=SmoothedXYLineSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/SmoothedYLineSeries.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/SmoothedYLineSeries.js ***!
  \********************************************************************************************/
/*! exports provided: SmoothedYLineSeries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothedYLineSeries", function() { return SmoothedYLineSeries; });
/* harmony import */ var _LineSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js");
/* harmony import */ var _core_render_MonotoneYTension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/MonotoneYTension */ "./node_modules/@amcharts/amcharts5/.internal/core/render/MonotoneYTension.js");


/**
 * Smoothed line series suitable for vertical plots.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/smoothed-series/} for more info
 */
class SmoothedYLineSeries extends _LineSeries__WEBPACK_IMPORTED_MODULE_0__["LineSeries"] {
    _afterNew() {
        this._setDefault("curveFactory", Object(_core_render_MonotoneYTension__WEBPACK_IMPORTED_MODULE_1__["curveMonotoneYTension"])(this.get("tension", 0.5)));
        super._afterNew();
    }
    _updateChildren() {
        if (this.isDirty("tension")) {
            this.set("curveFactory", Object(_core_render_MonotoneYTension__WEBPACK_IMPORTED_MODULE_1__["curveMonotoneYTension"])(this.get("tension", 0.5)));
            this._valuesDirty = true;
        }
        super._updateChildren();
    }
}
Object.defineProperty(SmoothedYLineSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "SmoothedYLineSeries"
});
Object.defineProperty(SmoothedYLineSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _LineSeries__WEBPACK_IMPORTED_MODULE_0__["LineSeries"].classNames.concat([SmoothedYLineSeries.className])
});
//# sourceMappingURL=SmoothedYLineSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/StepLineSeries.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/StepLineSeries.js ***!
  \***************************************************************************************/
/*! exports provided: StepLineSeries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StepLineSeries", function() { return StepLineSeries; });
/* harmony import */ var _LineSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/index.js");



class StepLineSeries extends _LineSeries__WEBPACK_IMPORTED_MODULE_0__["LineSeries"] {
    _afterNew() {
        this._setDefault("curveFactory", d3_shape__WEBPACK_IMPORTED_MODULE_2__["curveStepAfter"]);
        super._afterNew();
    }
    _getPoints(dataItem, o) {
        let points = o.points;
        let width = this.get("stepWidth", _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]).value / 2;
        let itemLocationX0 = dataItem.get("locationX", o.locationX);
        let itemLocationY0 = dataItem.get("locationY", o.locationY);
        let itemLocationX1 = itemLocationX0;
        let itemLocationY1 = itemLocationY0;
        if (o.baseAxis === o.xAxis) {
            itemLocationX0 -= width;
            itemLocationX1 += width;
        }
        else if (o.baseAxis === o.yAxis) {
            itemLocationY0 -= width;
            itemLocationY1 += width;
        }
        let xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX0, o.vcx);
        let yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY0, o.vcy);
        let xPos1 = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX1, o.vcx);
        let yPos1 = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY1, o.vcy);
        if (this._shouldInclude(xPos0)) {
            const iPoint0 = this.getPoint(xPos0, yPos0);
            const point0 = [iPoint0.x, iPoint0.y];
            const iPoint1 = this.getPoint(xPos1, yPos1);
            const point1 = [iPoint1.x, iPoint1.y];
            if (o.fillVisible) {
                let xOpenPos0 = xPos0;
                let yOpenPos0 = yPos0;
                let xOpenPos1 = xPos1;
                let yOpenPos1 = yPos1;
                if (o.baseAxis === o.xAxis) {
                    yOpenPos0 = o.basePosY;
                    yOpenPos1 = o.basePosY;
                }
                else if (o.baseAxis === o.yAxis) {
                    xOpenPos0 = o.basePosX;
                    xOpenPos1 = o.basePosX;
                }
                if (o.getOpen) {
                    let valueX = dataItem.get(o.xOpenField);
                    let valueY = dataItem.get(o.yOpenField);
                    if (valueX != null && valueY != null) {
                        itemLocationX0 = dataItem.get("openLocationX", o.openLocationX);
                        itemLocationY0 = dataItem.get("openLocationY", o.openLocationY);
                        itemLocationX1 = itemLocationX0;
                        itemLocationY1 = itemLocationY0;
                        if (o.baseAxis === o.xAxis) {
                            itemLocationX0 -= width;
                            itemLocationX1 += width;
                        }
                        else if (o.baseAxis === o.yAxis) {
                            itemLocationY0 -= width;
                            itemLocationY1 += width;
                        }
                        if (o.stacked) {
                            let stackToItemX = dataItem.get("stackToItemX");
                            let stackToItemY = dataItem.get("stackToItemY");
                            if (stackToItemX) {
                                xOpenPos0 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX0, stackToItemX.component.get("vcx"));
                                xOpenPos1 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX1, stackToItemX.component.get("vcx"));
                            }
                            else {
                                if (o.yAxis === o.baseAxis) {
                                    xOpenPos0 = o.basePosX;
                                    xOpenPos1 = o.basePosX;
                                }
                                else if (o.baseAxis === o.yAxis) {
                                    xOpenPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX0, o.vcx);
                                    xOpenPos1 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX1, o.vcx);
                                }
                            }
                            if (stackToItemY) {
                                yOpenPos0 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY0, stackToItemY.component.get("vcy"));
                                yOpenPos1 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY1, stackToItemY.component.get("vcy"));
                            }
                            else {
                                if (o.xAxis === o.baseAxis) {
                                    yOpenPos0 = o.basePosY;
                                    yOpenPos1 = o.basePosY;
                                }
                                else if (o.baseAxis === o.yAxis) {
                                    yOpenPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY0, o.vcy);
                                    yOpenPos1 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY1, o.vcy);
                                }
                            }
                        }
                        else {
                            xOpenPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX0, o.vcx);
                            yOpenPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY0, o.vcy);
                            xOpenPos1 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX1, o.vcx);
                            yOpenPos1 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY1, o.vcy);
                        }
                    }
                }
                let closeIPoint0 = this.getPoint(xOpenPos0, yOpenPos0);
                let closeIPoint1 = this.getPoint(xOpenPos1, yOpenPos1);
                point0[2] = closeIPoint0.x;
                point0[3] = closeIPoint0.y;
                point1[2] = closeIPoint1.x;
                point1[3] = closeIPoint1.y;
            }
            points.push(point0);
            points.push(point1);
            dataItem.set("point", { x: point0[0] + (point1[0] - point0[0]) / 2, y: point0[1] + (point1[1] - point0[1]) / 2 });
        }
        if (this.get("noRisers")) {
            o.points = [];
            o.segments.push(points);
        }
    }
}
Object.defineProperty(StepLineSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "StepLineSeries"
});
Object.defineProperty(StepLineSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _LineSeries__WEBPACK_IMPORTED_MODULE_0__["LineSeries"].classNames.concat([StepLineSeries.className])
});
//# sourceMappingURL=StepLineSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js ***!
  \*********************************************************************************/
/*! exports provided: XYSeries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XYSeries", function() { return XYSeries; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/@amcharts/amcharts5/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _core_render_Series__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../core/render/Series */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Object__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");










/**
 * @ignore
 */
function min(left, right) {
    if (left == null) {
        return right;
    }
    else if (right == null) {
        return left;
    }
    else if (right < left) {
        return right;
    }
    else {
        return left;
    }
}
/**
 * @ignore
 */
function max(left, right) {
    if (left == null) {
        return right;
    }
    else if (right == null) {
        return left;
    }
    else if (right > left) {
        return right;
    }
    else {
        return left;
    }
}
/**
 * A base class for all XY chart series.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/} for more info
 */
class XYSeries extends _core_render_Series__WEBPACK_IMPORTED_MODULE_2__["Series"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_xField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_yField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_xOpenField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_yOpenField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_xLowField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_xHighField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_yLowField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_yHighField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_axesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_stackDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_selectionProcessed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dataSets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_mainContainerMask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * A [[Container]] that us used to put series' elements in.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "mainContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_4__["Container"].new(this._root, {}))
        });
        /**
         * A list of axis ranges that affect the series.
         *
         * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
         */
        Object.defineProperty(this, "axisRanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_3__["List"]()
        });
        Object.defineProperty(this, "_skipped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_couldStackTo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_reallyStackedTo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_stackedSeries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_aLocationX0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_aLocationX1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_aLocationY0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_aLocationY1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_showBullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "valueXFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "valueX",
                "openValueX",
                "lowValueX",
                "highValueX"
            ]
        });
        Object.defineProperty(this, "valueYFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "valueY",
                "openValueY",
                "lowValueY",
                "highValueY"
            ]
        });
        Object.defineProperty(this, "_valueXFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_valueYFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // used for full min/max
        Object.defineProperty(this, "_valueXShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_valueYShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // used for selection (uses working)
        Object.defineProperty(this, "__valueXShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "__valueYShowFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_emptyDataItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_render_Component__WEBPACK_IMPORTED_MODULE_1__["DataItem"](this, undefined, {})
        });
        Object.defineProperty(this, "_dataSetId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipFieldX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipFieldY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        this.fields.push("categoryX", "categoryY", "openCategoryX", "openCategoryY");
        this.valueFields.push("valueX", "valueY", "openValueX", "openValueY", "lowValueX", "lowValueY", "highValueX", "highValueY");
        this._setRawDefault("vcx", 1);
        this._setRawDefault("vcy", 1);
        // this can't go to themes, as data might be parsed before theme
        this._setRawDefault("valueXShow", "valueXWorking");
        this._setRawDefault("valueYShow", "valueYWorking");
        this._setRawDefault("openValueXShow", "openValueXWorking");
        this._setRawDefault("openValueYShow", "openValueYWorking");
        this._setRawDefault("lowValueXShow", "lowValueXWorking");
        this._setRawDefault("lowValueYShow", "lowValueYWorking");
        this._setRawDefault("highValueXShow", "highValueXWorking");
        this._setRawDefault("highValueYShow", "highValueYWorking");
        this._setRawDefault("lowValueXGrouped", "low");
        this._setRawDefault("lowValueYGrouped", "low");
        this._setRawDefault("highValueXGrouped", "high");
        this._setRawDefault("highValueYGrouped", "high");
        super._afterNew();
        this._settings.xAxis.series.push(this);
        this._settings.yAxis.series.push(this);
        this.set("maskContent", true);
        this._disposers.push(this.axisRanges.events.onAll((change) => {
            if (change.type === "clear") {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](change.oldValues, (axisRange) => {
                    this._removeAxisRange(axisRange);
                });
            }
            else if (change.type === "push") {
                this._processAxisRange(change.newValue);
            }
            else if (change.type === "setIndex") {
                this._processAxisRange(change.newValue);
            }
            else if (change.type === "insertIndex") {
                this._processAxisRange(change.newValue);
            }
            else if (change.type === "removeIndex") {
                this._removeAxisRange(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                this._processAxisRange(change.value);
            }
            else {
                throw new Error("Unknown IStreamEvent type");
            }
        }));
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        this._disposers.push(xAxis.events.on("positionchanged", () => {
            this._fixPosition();
        }));
        this._disposers.push(yAxis.events.on("positionchanged", () => {
            this._fixPosition();
        }));
        if (!this.get("baseAxis")) {
            if (yAxis.isType("CategoryAxis") || yAxis.isType("DateAxis")) {
                this.set("baseAxis", yAxis);
            }
            else {
                this.set("baseAxis", xAxis);
            }
        }
        this.states.create("hidden", { opacity: 1, visible: false });
        this._makeFieldNames();
    }
    _processAxisRange(axisRange) {
        const container = _core_render_Container__WEBPACK_IMPORTED_MODULE_4__["Container"].new(this._root, {});
        axisRange.container = container;
        this.children.push(container);
        axisRange.series = this;
        const axisDataItem = axisRange.axisDataItem;
        axisDataItem.setRaw("isRange", true);
        const axis = axisDataItem.component;
        if (axis) {
            axis._processAxisRange(axisDataItem, ["range", "series"]);
            const bullet = axisDataItem.get("bullet");
            if (bullet) {
                const sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.setPrivate("visible", false);
                }
            }
            const axisFill = axisDataItem.get("axisFill");
            if (axisFill) {
                container.set("mask", axisFill);
            }
            axis._seriesAxisRanges.push(axisDataItem);
        }
    }
    _removeAxisRange(axisRange) {
        const axisDataItem = axisRange.axisDataItem;
        const axis = axisDataItem.component;
        axis.disposeDataItem(axisDataItem);
        _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["remove"](axis._seriesAxisRanges, axisDataItem);
        const container = axisRange.container;
        if (container) {
            container.dispose();
        }
    }
    _updateFields() {
        super._updateFields();
        this._valueXFields = [];
        this._valueYFields = [];
        this._valueXShowFields = [];
        this._valueYShowFields = [];
        this.__valueXShowFields = [];
        this.__valueYShowFields = [];
        if (this.valueXFields) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this.valueXFields, (key) => {
                const field = this.get((key + "Field"));
                if (field) {
                    this._valueXFields.push(key);
                    let field = this.get((key + "Show"));
                    this.__valueXShowFields.push(field);
                    if (field.indexOf("Working") != -1) {
                        this._valueXShowFields.push(field.split("Working")[0]);
                    }
                    else {
                        this._valueXShowFields.push(field);
                    }
                }
            });
        }
        if (this.valueYFields) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this.valueYFields, (key) => {
                const field = this.get((key + "Field"));
                if (field) {
                    this._valueYFields.push(key);
                    let field = this.get((key + "Show"));
                    this.__valueYShowFields.push(field);
                    if (field.indexOf("Working") != -1) {
                        this._valueYShowFields.push(field.split("Working")[0]);
                    }
                    else {
                        this._valueYShowFields.push(field);
                    }
                }
            });
        }
    }
    _dispose() {
        super._dispose();
        const chart = this.chart;
        if (chart) {
            chart.series.removeValue(this);
        }
        _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["removeFirst"](this.get("xAxis").series, this);
        _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["removeFirst"](this.get("yAxis").series, this);
    }
    // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
    _min(key, value) {
        let newValue = min(this.getPrivate(key), value);
        this.setPrivate(key, newValue);
    }
    // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
    _max(key, value) {
        let newValue = max(this.getPrivate(key), value);
        this.setPrivate(key, newValue);
    }
    _shouldMakeBullet(dataItem) {
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const baseAxis = this.get("baseAxis");
        if (!xAxis.inited || !yAxis.inited) {
            return false;
        }
        const minBulletDistance = this.get("minBulletDistance", 0);
        if (minBulletDistance > 0) {
            let startIndex = this.startIndex();
            let endIndex = this.endIndex();
            let count = endIndex - startIndex;
            if (xAxis == baseAxis) {
                if (xAxis.get("renderer").axisLength() / count < minBulletDistance / 5) {
                    return false;
                }
            }
            else if (yAxis == baseAxis) {
                if (yAxis.get("renderer").axisLength() / count < minBulletDistance / 5) {
                    return false;
                }
            }
        }
        if (dataItem.get(this._xField) != null && dataItem.get(this._yField) != null) {
            return true;
        }
        return false;
    }
    _makeFieldNames() {
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const xName = xAxis.getPrivate("name");
        const xCapName = _core_util_Utils__WEBPACK_IMPORTED_MODULE_9__["capitalizeFirst"](xName);
        const yName = yAxis.getPrivate("name");
        const yCapName = _core_util_Utils__WEBPACK_IMPORTED_MODULE_9__["capitalizeFirst"](yName);
        const xLetter = xAxis.get("renderer").getPrivate("letter");
        const yLetter = yAxis.get("renderer").getPrivate("letter");
        const open = "open";
        const low = "low";
        const high = "high";
        const show = "Show";
        if (xAxis.className === "ValueAxis") {
            this._xField = this.get((xName + xLetter + show));
            this._xOpenField = this.get((open + xCapName + xLetter + show));
            this._xLowField = this.get((low + xCapName + xLetter + show));
            this._xHighField = this.get((high + xCapName + xLetter + show));
        }
        else {
            this._xField = (xName + xLetter);
            this._xOpenField = (open + xCapName + xLetter);
            this._xLowField = (low + xCapName + xLetter);
            this._xHighField = (high + xCapName + xLetter);
        }
        if (yAxis.className === "ValueAxis") {
            this._yField = this.get((yName + yLetter + show));
            this._yOpenField = this.get((open + yCapName + yLetter + show));
            this._yLowField = this.get((low + yCapName + yLetter + show));
            this._yHighField = this.get((high + yCapName + yLetter + show));
        }
        else {
            this._yField = (yName + yLetter);
            this._yOpenField = (open + yCapName + yLetter);
            this._yLowField = (low + yCapName + yLetter);
            this._yHighField = (high + yCapName + yLetter);
        }
    }
    _fixVC() {
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const baseAxis = this.get("baseAxis");
        const hiddenState = this.states.lookup("hidden");
        const sequencedInterpolation = this.get("sequencedInterpolation");
        if (hiddenState) {
            let value = 0;
            if (sequencedInterpolation) {
                value = 0.999999999999; // makes animate, good for stacked
            }
            if (xAxis === baseAxis) {
                hiddenState.set("vcy", value);
            }
            else if (yAxis === baseAxis) {
                hiddenState.set("vcx", value);
            }
            else {
                hiddenState.set("vcy", value);
                hiddenState.set("vcx", value);
            }
        }
    }
    _handleMaskBullets() {
        if (this.isDirty("maskBullets")) {
            this.bulletsContainer.set("maskContent", this.get("maskBullets"));
        }
    }
    _fixPosition() {
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        this.set("x", xAxis.x() - _core_util_Utils__WEBPACK_IMPORTED_MODULE_9__["relativeToValue"](xAxis.get("centerX", 0), xAxis.width()) - xAxis.parent.get("paddingLeft", 0));
        this.set("y", yAxis.y() - _core_util_Utils__WEBPACK_IMPORTED_MODULE_9__["relativeToValue"](yAxis.get("centerY", 0), yAxis.height()) - yAxis.parent.get("paddingTop", 0));
        this.bulletsContainer.set("y", this.y());
        this.bulletsContainer.set("x", this.x());
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.isDirty("valueYShow") || this.isDirty("valueXShow" || false || false || false || false || false || false)) {
            this._updateFields();
            this._makeFieldNames();
            this._valuesDirty = true;
        }
        this.set("width", this.get("xAxis").width());
        this.set("height", this.get("yAxis").height());
        this._handleMaskBullets();
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        const baseAxis = this.get("baseAxis");
        const tooltipPositionX = this.get("tooltipPositionX");
        let tooltipFieldX;
        switch (tooltipPositionX) {
            case "open":
                tooltipFieldX = this._xOpenField;
                break;
            case "low":
                tooltipFieldX = this._xLowField;
                break;
            case "high":
                tooltipFieldX = this._xHighField;
                break;
            default:
                tooltipFieldX = this._xField;
        }
        this._tooltipFieldX = tooltipFieldX;
        const tooltipPositionY = this.get("tooltipPositionY");
        let tooltipFieldY;
        switch (tooltipPositionY) {
            case "open":
                tooltipFieldY = this._yOpenField;
                break;
            case "low":
                tooltipFieldY = this._yLowField;
                break;
            case "high":
                tooltipFieldY = this._yHighField;
                break;
            default:
                tooltipFieldY = this._yField;
        }
        this._tooltipFieldY = tooltipFieldY;
        if (this.isDirty("baseAxis")) {
            this._fixVC();
        }
        this._fixPosition();
        const stacked = this.get("stacked");
        if (this.isDirty("stacked")) {
            if (stacked) {
                if (this._valuesDirty && !this._dataProcessed) {
                }
                else {
                    this._stack();
                }
            }
            else {
                this._unstack();
            }
        }
        if (this._valuesDirty && !this._dataProcessed) {
            this._dataProcessed = true;
            if (stacked) {
                this._stack();
            }
            _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this.dataItems, (dataItem) => {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._valueXShowFields, (key) => {
                    let value = dataItem.get(key);
                    if (value != null) {
                        if (stacked) {
                            value += this.getStackedXValue(dataItem, key);
                        }
                        this._min("minX", value);
                        this._max("maxX", value);
                    }
                });
                _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._valueYShowFields, (key) => {
                    let value = dataItem.get(key);
                    if (value != null) {
                        if (stacked) {
                            value += this.getStackedYValue(dataItem, key);
                        }
                        this._min("minY", value);
                        this._max("maxY", value);
                    }
                });
                xAxis.processSeriesDataItem(dataItem, this._valueXFields);
                yAxis.processSeriesDataItem(dataItem, this._valueYFields);
            });
            xAxis._seriesValuesDirty = true;
            yAxis._seriesValuesDirty = true;
            if (!this.get("ignoreMinMax")) {
                if (this.isPrivateDirty("minX") || this.isPrivateDirty("maxX")) {
                    xAxis.markDirtyExtremes();
                }
                if (this.isPrivateDirty("minY") || this.isPrivateDirty("maxY")) {
                    yAxis.markDirtyExtremes();
                }
            }
            this._markStakedDirtyStack();
            //this.updateLegendMarker(undefined); // causes legend marker to change color instantly when on
            if (!this.get("tooltipDataItem")) {
                this.updateLegendValue(undefined);
            }
        }
        if (this.isDirty("vcx") || this.isDirty("vcy")) {
            this._markStakedDirtyStack();
        }
        if (!this._dataGrouped) {
            xAxis._groupSeriesData(this);
            yAxis._groupSeriesData(this);
            this._dataGrouped = true;
        }
        if (this._valuesDirty || this.isPrivateDirty("startIndex") || this.isPrivateDirty("endIndex") || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty) {
            let startIndex = this.startIndex();
            let endIndex = this.endIndex();
            let minBulletDistance = this.get("minBulletDistance", 0);
            if (minBulletDistance > 0 && baseAxis) {
                if (baseAxis.get("renderer").axisLength() / (endIndex - startIndex) > minBulletDistance) {
                    this._showBullets = true;
                }
                else {
                    this._showBullets = false;
                }
            }
            if ((this._psi != startIndex || this._pei != endIndex || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty || this._valuesDirty) && !this._selectionProcessed) {
                this._selectionProcessed = true;
                const vcx = this.get("vcx", 1);
                const vcy = this.get("vcy", 1);
                const stacked = this.get("stacked", false);
                const outOfSelection = this.getPrivate("outOfSelection");
                if (baseAxis === xAxis) {
                    yAxis._calculateTotals();
                    this.setPrivateRaw("selectionMinY", undefined);
                    this.setPrivateRaw("selectionMaxY", undefined);
                    if (!outOfSelection) {
                        for (let i = startIndex; i < endIndex; i++) {
                            this.processYSelectionDataItem(this.dataItems[i], vcy, stacked);
                        }
                    }
                    else {
                        yAxis.markDirtySelectionExtremes();
                    }
                }
                else if (baseAxis === yAxis) {
                    xAxis._calculateTotals();
                    this.setPrivateRaw("selectionMinX", undefined);
                    this.setPrivateRaw("selectionMaxX", undefined);
                    if (!outOfSelection) {
                        for (let i = startIndex; i < endIndex; i++) {
                            this.processXSelectionDataItem(this.dataItems[i], vcx, stacked);
                        }
                    }
                    else {
                        yAxis.markDirtySelectionExtremes();
                    }
                }
                if (baseAxis === xAxis) {
                    if (this.get("valueYShow") !== "valueYWorking") {
                        const selectionMinY = this.getPrivate("selectionMinY");
                        if (selectionMinY != null) {
                            this.setPrivateRaw("minY", selectionMinY);
                            yAxis.markDirtyExtremes();
                        }
                        const selectionMaxY = this.getPrivate("selectionMaxY");
                        if (selectionMaxY != null) {
                            this.setPrivateRaw("maxY", selectionMaxY);
                            yAxis.markDirtyExtremes();
                        }
                    }
                }
                else if (baseAxis === yAxis) {
                    if (this.get("valueXShow") !== "valueXWorking") {
                        const selectionMinX = this.getPrivate("selectionMinX");
                        if (selectionMinX != null) {
                            this.setPrivateRaw("minX", selectionMinX);
                            yAxis.markDirtyExtremes();
                        }
                        const selectionMaxX = this.getPrivate("selectionMaxX");
                        if (selectionMaxX != null) {
                            this.setPrivateRaw("maxX", selectionMaxX);
                            xAxis.markDirtyExtremes();
                        }
                    }
                }
                if (this.isPrivateDirty("selectionMinX") || this.isPrivateDirty("selectionMaxX")) {
                    xAxis.markDirtySelectionExtremes();
                }
                if (this.isPrivateDirty("selectionMinY") || this.isPrivateDirty("selectionMaxY")) {
                    yAxis.markDirtySelectionExtremes();
                }
                // this.updateLegendValue(undefined); flickers while panning
            }
        }
    }
    _makeRangeMask() {
        if (this.axisRanges.length > 0) {
            let mainContainerMask = this._mainContainerMask;
            if (mainContainerMask == null) {
                mainContainerMask = this.children.push(_core_render_Graphics__WEBPACK_IMPORTED_MODULE_5__["Graphics"].new(this._root, {}));
                this._mainContainerMask = mainContainerMask;
                mainContainerMask.set("draw", (display, target) => {
                    const parent = this.parent;
                    if (parent) {
                        const w = this._root.container.width();
                        const h = this._root.container.height();
                        display.moveTo(-w, -h);
                        display.lineTo(-w, h * 2);
                        display.lineTo(w * 2, h * 2);
                        display.lineTo(w * 2, -h);
                        display.lineTo(-w, -h);
                        this.axisRanges.each((axisRange) => {
                            const fill = axisRange.axisDataItem.get("axisFill");
                            if (parent) {
                                if (fill) {
                                    let draw = fill.get("draw");
                                    if (draw) {
                                        draw(display, target);
                                    }
                                }
                            }
                        });
                    }
                    this.mainContainer._display.mask = mainContainerMask._display;
                });
            }
            mainContainerMask.markDirty();
            mainContainerMask._markDirtyKey("fill");
        }
        else {
            this.mainContainer._display.mask = null;
        }
    }
    _updateChildren() {
        super._updateChildren();
        // save for performance
        this._x = this.x();
        this._y = this.y();
        this._makeRangeMask();
    }
    _stack() {
        const chart = this.chart;
        if (chart) {
            const seriesIndex = chart.series.indexOf(this);
            this._couldStackTo = [];
            if (seriesIndex > 0) {
                let series;
                for (let i = seriesIndex - 1; i >= 0; i--) {
                    series = chart.series.getIndex(i);
                    if (series.get("xAxis") === this.get("xAxis") && series.get("yAxis") === this.get("yAxis") && series.className === this.className) {
                        this._couldStackTo.push(series);
                        if (!series.get("stacked")) {
                            break;
                        }
                    }
                }
            }
            this._stackDataItems();
        }
    }
    _unstack() {
        _core_util_Object__WEBPACK_IMPORTED_MODULE_7__["each"](this._reallyStackedTo, (_key, value) => {
            delete (value._stackedSeries[this.uid]);
        });
        this._reallyStackedTo = {};
        _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this.dataItems, (dataItem) => {
            dataItem.setRaw("stackToItemY", undefined);
            dataItem.setRaw("stackToItemX", undefined);
        });
    }
    _stackDataItems() {
        // this works only with the same number of data @todo: search by date/category?
        const baseAxis = this.get("baseAxis");
        const xAxis = this.get("xAxis");
        const yAxis = this.get("yAxis");
        let field;
        let stackToItemKey;
        if (baseAxis === xAxis) {
            field = "valueY";
            stackToItemKey = "stackToItemY";
        }
        else if (baseAxis === yAxis) {
            field = "valueX";
            stackToItemKey = "stackToItemX";
        }
        let len = this._couldStackTo.length;
        let index = 0;
        const stackToNegative = this.get("stackToNegative");
        this._reallyStackedTo = {};
        _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this.dataItems, (dataItem) => {
            for (let s = 0; s < len; s++) {
                let stackToSeries = this._couldStackTo[s];
                let stackToItem = stackToSeries.dataItems[index];
                let value = dataItem.get(field);
                if (stackToItem) {
                    let stackValue = stackToItem.get(field);
                    if (stackToNegative) {
                        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](value)) {
                            if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](stackValue)) {
                                if (value >= 0 && stackValue >= 0) {
                                    dataItem.setRaw(stackToItemKey, stackToItem);
                                    this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                                    stackToSeries._stackedSeries[this.uid] = this;
                                    break;
                                }
                                if (value < 0 && stackValue < 0) {
                                    dataItem.setRaw(stackToItemKey, stackToItem);
                                    this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                                    stackToSeries._stackedSeries[this.uid] = this;
                                    break;
                                }
                            }
                        }
                        else {
                            break;
                        }
                    }
                    else {
                        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](value) && _core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](stackValue)) {
                            dataItem.setRaw(stackToItemKey, stackToItem);
                            this._reallyStackedTo[stackToSeries.uid] = stackToSeries;
                            stackToSeries._stackedSeries[this.uid] = this;
                            break;
                        }
                    }
                }
            }
            index++;
        });
    }
    processXSelectionDataItem(dataItem, vcx, stacked) {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this.__valueXShowFields, (key) => {
            let value = dataItem.get(key);
            if (value != null) {
                if (stacked) {
                    value += this.getStackedXValueWorking(dataItem, key);
                }
                this._min("selectionMinX", value);
                this._max("selectionMaxX", value * vcx);
            }
        });
    }
    processYSelectionDataItem(dataItem, vcy, stacked) {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this.__valueYShowFields, (key) => {
            let value = dataItem.get(key);
            if (value != null) {
                if (stacked) {
                    value += this.getStackedYValueWorking(dataItem, key);
                }
                this._min("selectionMinY", value);
                this._max("selectionMaxY", value * vcy);
            }
        });
    }
    /**
     * @ignore
     */
    getStackedYValueWorking(dataItem, key) {
        const stackToItem = dataItem.get("stackToItemY");
        if (stackToItem) {
            const stackedToSeries = stackToItem.component;
            return stackToItem.get(key, 0) * stackedToSeries.get("vcy", 1) + this.getStackedYValueWorking(stackToItem, key);
        }
        return 0;
    }
    /**
     * @ignore
     */
    getStackedXValueWorking(dataItem, key) {
        const stackToItem = dataItem.get("stackToItemX");
        if (stackToItem) {
            const stackedToSeries = stackToItem.component;
            return stackToItem.get(key, 0) * stackedToSeries.get("vcx", 1) + this.getStackedXValueWorking(stackToItem, key);
        }
        return 0;
    }
    /**
     * @ignore
     */
    getStackedYValue(dataItem, key) {
        const stackToItem = dataItem.get("stackToItemY");
        if (stackToItem) {
            return stackToItem.get(key, 0) + this.getStackedYValue(stackToItem, key);
        }
        return 0;
    }
    /**
     * @ignore
     */
    getStackedXValue(dataItem, key) {
        const stackToItem = dataItem.get("stackToItemX");
        if (stackToItem) {
            return stackToItem.get(key, 0) + this.getStackedXValue(stackToItem, key);
        }
        return 0;
    }
    /**
     * @ignore
     */
    createLegendMarker(_dataItem) {
        this.updateLegendMarker();
    }
    _markDirtyAxes() {
        this._axesDirty = true;
        this.markDirty();
    }
    _markDataSetDirty() {
        this._afterDataChange();
        this._valuesDirty = true;
        this._dataProcessed = false;
        this._aggregatesCalculated = false;
        this.markDirty();
    }
    _clearDirty() {
        super._clearDirty();
        this._axesDirty = false;
        this._selectionProcessed = false;
        this._stackDirty = false;
        this._dataProcessed = false;
    }
    _positionBullet(bullet) {
        let sprite = bullet.get("sprite");
        if (sprite) {
            let dataItem = sprite.dataItem;
            let locationX = bullet.get("locationX", dataItem.get("locationX", 0.5));
            let locationY = bullet.get("locationY", dataItem.get("locationY", 0.5));
            let xAxis = this.get("xAxis");
            let yAxis = this.get("yAxis");
            const positionX = xAxis.getDataItemPositionX(dataItem, this._xField, locationX, this.get("vcx", 1));
            const positionY = yAxis.getDataItemPositionY(dataItem, this._yField, locationY, this.get("vcy", 1));
            let point = this.getPoint(positionX, positionY);
            let left = dataItem.get("left", point.x);
            let right = dataItem.get("right", point.x);
            let top = dataItem.get("top", point.y);
            let bottom = dataItem.get("bottom", point.y);
            if (this._shouldShowBullet(positionX, positionY)) {
                if (!bullet.getPrivate("hidden")) {
                    sprite.setPrivate("visible", true);
                }
                else {
                    sprite.setPrivate("visible", false);
                }
                let w = right - left;
                let h = bottom - top;
                if (sprite.isType("Label")) {
                    sprite.setPrivate("maxWidth", Math.abs(w));
                    sprite.setPrivate("maxHeight", Math.abs(h));
                }
                let x = left + w * locationX;
                let y = bottom - h * locationY;
                sprite.set("x", x);
                sprite.set("y", y);
            }
            else {
                sprite.setPrivate("visible", false);
            }
        }
    }
    _shouldShowBullet(_positionX, _positionY) {
        return this._showBullets;
    }
    /**
     * @ignore
     */
    setDataSet(id) {
        if (this._dataSets[id]) {
            this._handleDataSetChange();
            this._dataItems = this._dataSets[id];
            this._markDataSetDirty();
            this._dataSetId = id;
            const type = "datasetchanged";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, { type: type, target: this, id: id });
            }
        }
    }
    _handleDataSetChange() {
        if (this.bullets.length > 0) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._dataItems, (dataItem) => {
                let bullets = dataItem.bullets;
                if (bullets) {
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](bullets, (bullet) => {
                        if (bullet) {
                            let sprite = bullet.get("sprite");
                            if (sprite) {
                                sprite.setPrivate("visible", false);
                            }
                        }
                    });
                }
            });
        }
        this._selectionProcessed = false; // for totals to be calculated
    }
    /**
     * Shows hidden series.
     *
     * @param   duration  Duration of animation in milliseconds
     * @return            Animation promise
     */
    show(duration) {
        const _super = Object.create(null, {
            show: { get: () => super.show }
        });
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            this._fixVC();
            let promises = [];
            promises.push(_super.show.call(this, duration).then(() => {
                this._isShowing = false;
                let xAxis = this.get("xAxis");
                let yAxis = this.get("yAxis");
                let baseAxis = this.get("baseAxis");
                if (yAxis !== baseAxis) {
                    yAxis.markDirtySelectionExtremes();
                }
                if (xAxis !== baseAxis) {
                    xAxis.markDirtySelectionExtremes();
                }
            }));
            promises.push(this.bulletsContainer.show(duration));
            promises.push(this._sequencedShowHide(true, duration));
            yield Promise.all(promises);
        });
    }
    /**
     * Hides series.
     *
     * @param   duration  Duration of animation in milliseconds
     * @return            Animation promise
     */
    hide(duration) {
        const _super = Object.create(null, {
            hide: { get: () => super.hide }
        });
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            this._fixVC();
            let promises = [];
            promises.push(_super.hide.call(this, duration).then(() => {
                this._isHiding = false;
            }));
            promises.push(this.bulletsContainer.hide(duration));
            promises.push(this._sequencedShowHide(false, duration));
            yield Promise.all(promises);
        });
    }
    /**
     * Shows series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    showDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            showDataItem: { get: () => super.showDataItem }
        });
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const promises = [_super.showDataItem.call(this, dataItem, duration)];
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](duration)) {
                duration = this.get("stateAnimationDuration", 0);
            }
            const easing = this.get("stateAnimationEasing");
            _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._valueFields, (key) => {
                promises.push(dataItem.animate({ key: key + "Working", to: dataItem.get(key), duration: duration, easing: easing }).waitForStop());
            });
            yield Promise.all(promises);
        });
    }
    /**
     * Hides series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    hideDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            hideDataItem: { get: () => super.hideDataItem }
        });
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const promises = [_super.hideDataItem.call(this, dataItem, duration)];
            const hiddenState = this.states.create("hidden", {});
            if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](duration)) {
                duration = hiddenState.get("stateAnimationDuration", this.get("stateAnimationDuration", 0));
            }
            const easing = hiddenState.get("stateAnimationEasing", this.get("stateAnimationEasing"));
            const xAxis = this.get("xAxis");
            const yAxis = this.get("yAxis");
            const baseAxis = this.get("baseAxis");
            const stacked = this.get("stacked");
            if (baseAxis === xAxis || !baseAxis) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._valueYFields, (key) => {
                    let min = yAxis.getPrivate("min");
                    let baseValue = yAxis.baseValue();
                    if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](min) && min > baseValue) {
                        baseValue = min;
                    }
                    if (stacked) {
                        baseValue = 0;
                    }
                    let value = dataItem.get(key);
                    if (value != null) {
                        promises.push(dataItem.animate({ key: key + "Working", to: baseValue, duration: duration, easing: easing }).waitForStop());
                    }
                });
            }
            if (baseAxis === yAxis || !baseAxis) {
                let min = xAxis.getPrivate("min");
                let baseValue = xAxis.baseValue();
                if (_core_util_Type__WEBPACK_IMPORTED_MODULE_6__["isNumber"](min) && min > baseValue) {
                    baseValue = min;
                }
                if (stacked) {
                    baseValue = 0;
                }
                _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._valueXFields, (key) => {
                    let value = dataItem.get(key);
                    if (value != null) {
                        promises.push(dataItem.animate({ key: key + "Working", to: baseValue, duration: duration, easing: easing }).waitForStop());
                    }
                });
            }
            yield Promise.all(promises);
        });
    }
    _markDirtyStack() {
        this._stackDirty = true;
        this.markDirty();
        this._markStakedDirtyStack();
    }
    _markStakedDirtyStack() {
        const stackedSeries = this._stackedSeries;
        if (stackedSeries) {
            _core_util_Object__WEBPACK_IMPORTED_MODULE_7__["each"](stackedSeries, (_key, value) => {
                if (!value._stackDirty) {
                    value._markDirtyStack();
                }
            });
        }
    }
    _afterChanged() {
        super._afterChanged();
        if (this._skipped) {
            this._markDirtyAxes();
            this._skipped = false;
        }
    }
    /**
     * Shows a tooltip for specific data item.
     *
     * @param  dataItem  Data item
     */
    showDataItemTooltip(dataItem) {
        this.updateLegendMarker(dataItem);
        this.updateLegendValue(dataItem);
        const tooltip = this.get("tooltip");
        if (tooltip) {
            if (!this.isHidden()) {
                tooltip._setDataItem(dataItem);
                if (dataItem) {
                    let locationX = this.get("locationX", 0);
                    let locationY = this.get("locationY", 1);
                    let itemLocationX = dataItem.get("locationX", locationX);
                    let itemLocationY = dataItem.get("locationY", locationY);
                    const xAxis = this.get("xAxis");
                    const yAxis = this.get("yAxis");
                    const vcx = this.get("vcx", 1);
                    const vcy = this.get("vcy", 1);
                    const xPos = xAxis.getDataItemPositionX(dataItem, this._tooltipFieldX, this._aLocationX0 + (this._aLocationX1 - this._aLocationX0) * itemLocationX, vcx);
                    const yPos = yAxis.getDataItemPositionY(dataItem, this._tooltipFieldY, this._aLocationY0 + (this._aLocationY1 - this._aLocationY0) * itemLocationY, vcy);
                    const point = this.getPoint(xPos, yPos);
                    let show = true;
                    _core_util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._valueFields, (field) => {
                        if (dataItem.get(field) == null) {
                            show = false;
                        }
                    });
                    if (show) {
                        const chart = this.chart;
                        if (chart && chart.inPlot(point)) {
                            tooltip.label.text.markDirtyText();
                            tooltip.set("tooltipTarget", this._getTooltipTarget(dataItem));
                            tooltip.set("pointTo", this._display.toGlobal({ x: point.x, y: point.y }));
                        }
                        else {
                            tooltip._setDataItem(undefined);
                        }
                    }
                    else {
                        tooltip._setDataItem(undefined);
                    }
                }
            }
            else {
                this.hideTooltip();
            }
        }
    }
    hideTooltip() {
        const tooltip = this.get("tooltip");
        if (tooltip) {
            tooltip.set("tooltipTarget", this);
        }
        return super.hideTooltip();
    }
    _getTooltipTarget(dataItem) {
        if (this.get("seriesTooltipTarget") == "bullet") {
            const bullets = dataItem.bullets;
            if (bullets && bullets.length > 0) {
                const bullet = bullets[0];
                const sprite = bullet.get("sprite");
                if (sprite) {
                    return sprite;
                }
            }
        }
        return this;
    }
    /**
     * @ignore
     */
    updateLegendValue(dataItem) {
        const legendDataItem = this.get("legendDataItem");
        if (legendDataItem) {
            const label = legendDataItem.get("label");
            if (label) {
                let txt = "";
                if (dataItem) {
                    label._setDataItem(dataItem);
                    txt = this.get("legendLabelText", label.get("text", this.get("name", "")));
                }
                else {
                    label._setDataItem(this._emptyDataItem);
                    txt = this.get("legendRangeLabelText", this.get("legendLabelText", label.get("text", this.get("name", ""))));
                }
                label.set("text", txt);
            }
            const valueLabel = legendDataItem.get("valueLabel");
            if (valueLabel) {
                let txt = "";
                if (dataItem) {
                    valueLabel._setDataItem(dataItem);
                    txt = this.get("legendValueText", valueLabel.get("text", ""));
                }
                else {
                    valueLabel._setDataItem(this._emptyDataItem);
                    txt = this.get("legendRangeValueText", valueLabel.get("text", ""));
                }
                valueLabel.set("text", txt);
            }
        }
    }
    _getItemReaderLabel() {
        let text = "X: {" + this._xField;
        if (this.get("xAxis").isType("DateAxis")) {
            text += ".formatDate()";
        }
        text += "}; Y: {" + this._yField;
        if (this.get("yAxis").isType("DateAxis")) {
            text += ".formatDate()";
        }
        text += "}";
        return text;
    }
    /**
     * @ignore
     */
    getPoint(positionX, positionY) {
        let x = this.get("xAxis").get("renderer").positionToCoordinate(positionX);
        let y = this.get("yAxis").get("renderer").positionToCoordinate(positionY);
        // if coordinate is super big, canvas fails to draw line, capping to some big number (won't make any visual difference)
        let max = 999999999;
        if (y < -max) {
            y = -max;
        }
        if (y > max) {
            y = max;
        }
        if (x < -max) {
            x = -max;
        }
        if (x > max) {
            x = max;
        }
        return { x: x, y: y };
    }
    _shouldInclude(_position) {
        return true;
    }
    /**
     * @ignore
     */
    handleCursorHide() {
        this.hideTooltip();
        this.updateLegendValue(undefined);
        this.updateLegendMarker(undefined);
    }
    _afterDataChange() {
        super._afterDataChange();
        this.get("xAxis")._markDirtyKey("start");
        this.get("yAxis")._markDirtyKey("start");
        this.resetExtremes();
    }
    // todo description
    resetExtremes() {
        this.setPrivate("selectionMinX", undefined);
        this.setPrivate("selectionMaxX", undefined);
        this.setPrivate("selectionMinY", undefined);
        this.setPrivate("selectionMaxY", undefined);
        this.setPrivate("minX", undefined);
        this.setPrivate("minY", undefined);
        this.setPrivate("maxX", undefined);
        this.setPrivate("maxY", undefined);
    }
    /**
     * Creates and returns an axis range object.
     *
     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
     * @param   axisDataItem  Axis data item
     * @return                Axis range
     */
    createAxisRange(axisDataItem) {
        return this.axisRanges.push({
            axisDataItem: axisDataItem
        });
    }
    /**
     * A list of series's main (ungrouped) data items.
     *
     * @return  Data items
     */
    get mainDataItems() {
        return this._mainDataItems;
    }
}
Object.defineProperty(XYSeries, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "XYSeries"
});
Object.defineProperty(XYSeries, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Series__WEBPACK_IMPORTED_MODULE_2__["Series"].classNames.concat([XYSeries.className])
});
//# sourceMappingURL=XYSeries.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/Registry.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/Registry.js ***!
  \*********************************************************************/
/*! exports provided: Registry, registry, addLicense, disposeAllRootElements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Registry", function() { return Registry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registry", function() { return registry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLicense", function() { return addLicense; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeAllRootElements", function() { return disposeAllRootElements; });
/**
 * @ignore
 */
class Registry {
    constructor() {
        /**
         * Currently running version of amCharts.
         */
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "5.3.11"
        });
        /**
         * List of applied licenses.
         * @ignore
         */
        Object.defineProperty(this, "licenses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * Entities that have their `id` setting set.
         */
        Object.defineProperty(this, "entitiesById", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        /**
         * All created [[Root]] elements.
         */
        Object.defineProperty(this, "rootElements", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
}
/**
    * @ignore
 */
const registry = new Registry();
/**
 * Adds a license, e.g.:
 *
 * ```TypeScript
 * am5.addLicense("xxxxxxxx");
 * ```
 * ```JavaScript
 * am5.addLicense("xxxxxxxx");
 * ```
 *
 * Multiple licenses can be added to cover for multiple products.
 *
 * @param  license  License key
 */
function addLicense(license) {
    registry.licenses.push(license);
}
/**
 * Disposes all [[Root]] elements.
 */
function disposeAllRootElements() {
    let root;
    while (root = registry.rootElements.pop()) {
        root.dispose();
    }
}
//# sourceMappingURL=Registry.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/Root.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/Root.js ***!
  \*****************************************************************/
/*! exports provided: Root */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Root", function() { return Root; });
/* harmony import */ var _render_Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _render_Text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./render/Text */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js");
/* harmony import */ var _render_HorizontalLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./render/HorizontalLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js");
/* harmony import */ var _render_VerticalLayout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./render/VerticalLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js");
/* harmony import */ var _render_GridLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./render/GridLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js");
/* harmony import */ var _util_Disposer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _util_ResizeSensor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/ResizeSensor */ "./node_modules/@amcharts/amcharts5/.internal/core/util/ResizeSensor.js");
/* harmony import */ var _util_InterfaceColors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/InterfaceColors */ "./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js");
/* harmony import */ var _render_Graphics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _render_Rectangle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _render_Tooltip__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./render/Tooltip */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js");
/* harmony import */ var _util_NumberFormatter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./util/NumberFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js");
/* harmony import */ var _util_DateFormatter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./util/DateFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js");
/* harmony import */ var _util_DurationFormatter__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./util/DurationFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js");
/* harmony import */ var _util_Language__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./util/Language */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Language.js");
/* harmony import */ var _util_EventDispatcher__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./util/EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../themes/DefaultTheme */ "./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js");
/* harmony import */ var _render_backend_CanvasRenderer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./render/backend/CanvasRenderer */ "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/CanvasRenderer.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _util_Color__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _util_PopulateString__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./util/PopulateString */ "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js");
/* harmony import */ var _Registry__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Registry */ "./node_modules/@amcharts/amcharts5/.internal/core/Registry.js");
/* harmony import */ var _util_Order__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./util/Order */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Object__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _locales_en__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../locales/en */ "./node_modules/@amcharts/amcharts5/locales/en.js");




























function rAF(fps, callback) {
    if (fps == null) {
        requestAnimationFrame(callback);
    }
    else {
        setTimeout(() => {
            requestAnimationFrame(callback);
        }, 1000 / fps);
    }
}
// TODO implement Disposer
/**
 * Root element of the chart.
 *
 * @see {@link https://www.amcharts.com/docs/v5/getting-started/#Root_element} for more info
 */
class Root {
    constructor(id, settings = {}, isReal) {
        /**
         * A reference to original chart container (div element).
         */
        Object.defineProperty(this, "dom", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_inner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_isDirtyParents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyParents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyPositions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_ticker", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_tickers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_updateTick", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        /**
         * Root's event dispatcher.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
         */
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_EventDispatcher__WEBPACK_IMPORTED_MODULE_15__["EventDispatcher"]()
        });
        /**
         * @ignore
         * @todo needs description
         */
        Object.defineProperty(this, "animationTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_animations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_renderer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rootContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Main content container.
         */
        Object.defineProperty(this, "container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A [[Container]] used to display tooltips in.
         */
        Object.defineProperty(this, "tooltipContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipContainerSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltip", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Locale-related
        /**
         * @ignore
         */
        Object.defineProperty(this, "language", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _util_Language__WEBPACK_IMPORTED_MODULE_14__["Language"].new(this, {})
        });
        /**
         * Locale used by the chart.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/}
         */
        Object.defineProperty(this, "locale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _locales_en__WEBPACK_IMPORTED_MODULE_27__["default"]
        });
        // Date-time related
        /**
         * Use UTC when formatting date/time.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#UTC_and_time_zones} for more info
         */
        Object.defineProperty(this, "utc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * If set, will format date/time in specific time zone.
         *
         * The value should be named time zone, e.g.:
         * `"America/Vancouver"`, `"Australia/Sydney"`, `"UTC"`.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Time_zone} for more info
         * @since 5.1.0
         */
        Object.defineProperty(this, "timezone", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The maximum FPS that the Root will run at.
         *
         * If `undefined` it will run at the highest FPS.
         *
         * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Performance} for more info
         */
        Object.defineProperty(this, "fps", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Number formatter.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info
         */
        Object.defineProperty(this, "numberFormatter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _util_NumberFormatter__WEBPACK_IMPORTED_MODULE_11__["NumberFormatter"].new(this, {})
        });
        /**
         * Date/time formatter.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info
         */
        Object.defineProperty(this, "dateFormatter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _util_DateFormatter__WEBPACK_IMPORTED_MODULE_12__["DateFormatter"].new(this, {})
        });
        /**
         * Duration formatter.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info
         */
        Object.defineProperty(this, "durationFormatter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _util_DurationFormatter__WEBPACK_IMPORTED_MODULE_13__["DurationFormatter"].new(this, {})
        });
        // Accessibility
        /**
         * Global tab index for using for the whole chart
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
         */
        Object.defineProperty(this, "tabindex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        //@todo maybe make this better
        Object.defineProperty(this, "_tabindexes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_a11yD", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_focusElementDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_focusElementContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_focusedSprite", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isShift", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_keyboardDragPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipElementContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_readerAlertElement", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_logo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipDiv", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Used for dynamically-created CSS and JavaScript with strict source policies.
         */
        Object.defineProperty(this, "nonce", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Special color set to be used for various controls.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Interface_colors} for more info
         */
        Object.defineProperty(this, "interfaceColors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * An instance of vertical layout object that can be used to set `layout` setting
         * of a [[Container]].
         *
         * @default VerticalLayout.new()
         */
        Object.defineProperty(this, "verticalLayout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _render_VerticalLayout__WEBPACK_IMPORTED_MODULE_3__["VerticalLayout"].new(this, {})
        });
        /**
         * An instance of horizontal layout object that can be used to set `layout` setting
         * of a [[Container]].
         *
         * @default HorizontalLayout.new()
         */
        Object.defineProperty(this, "horizontalLayout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _render_HorizontalLayout__WEBPACK_IMPORTED_MODULE_2__["HorizontalLayout"].new(this, {})
        });
        /**
         * An instance of grid layout object that can be used to set `layout` setting
         * of a [[Container]].
         *
         * @default VerticalLayout.new()
         */
        Object.defineProperty(this, "gridLayout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _render_GridLayout__WEBPACK_IMPORTED_MODULE_4__["GridLayout"].new(this, {})
        });
        Object.defineProperty(this, "_paused", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * Indicates whether chart should resized automatically when parent container
         * width and/or height changes.
         *
         * If disabled (`autoResize = false`) you can make the chart resize manually
         * by calling root element's `resize()` method.
         */
        Object.defineProperty(this, "autoResize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_fontHash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ""
        });
        Object.defineProperty(this, "_isDisposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_resizeSensorDisposer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltips", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_htmlElementContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_htmlEnabledContainers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        this._settings = settings;
        if (settings.accessible == false) {
            this._a11yD = true;
        }
        if (settings.useSafeResolution == null) {
            settings.useSafeResolution = true;
        }
        let resolution;
        if (settings.useSafeResolution) {
            resolution = _util_Utils__WEBPACK_IMPORTED_MODULE_25__["getSafeResolution"]();
        }
        this._renderer = new _render_backend_CanvasRenderer__WEBPACK_IMPORTED_MODULE_17__["CanvasRenderer"](resolution);
        let dom;
        if (id instanceof HTMLElement) {
            dom = id;
        }
        else {
            dom = document.getElementById(id);
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_23__["each"](_Registry__WEBPACK_IMPORTED_MODULE_21__["registry"].rootElements, (root) => {
            if (root.dom === dom) {
                throw new Error("You cannot have multiple Roots on the same DOM node");
            }
        });
        this.interfaceColors = _util_InterfaceColors__WEBPACK_IMPORTED_MODULE_7__["InterfaceColors"].new(this, {});
        if (dom === null) {
            throw new Error("Could not find HTML element with id `" + id + "`");
        }
        this.dom = dom;
        let inner = document.createElement("div");
        inner.style.position = "relative";
        inner.style.height = "100%";
        dom.appendChild(inner);
        const tooltipContainerBounds = settings.tooltipContainerBounds;
        if (tooltipContainerBounds) {
            this._tooltipContainerSettings = tooltipContainerBounds;
        }
        this._inner = inner;
        this._updateComputedStyles();
        _Registry__WEBPACK_IMPORTED_MODULE_21__["registry"].rootElements.push(this);
    }
    static new(id, settings) {
        const root = new Root(id, settings, true);
        root._init();
        return root;
    }
    moveDOM(id) {
        let dom;
        if (id instanceof HTMLElement) {
            dom = id;
        }
        else {
            dom = document.getElementById(id);
        }
        if (dom) {
            while (this.dom.childNodes.length > 0) {
                dom.appendChild(this.dom.childNodes[0]);
            }
            this.dom = dom;
            this._initResizeSensor();
            this.resize();
        }
    }
    _handleLogo() {
        if (this._logo) {
            const w = this.dom.offsetWidth;
            const h = this.dom.offsetHeight;
            if ((w <= 150) || (h <= 60)) {
                this._logo.hide();
            }
            else {
                this._logo.show();
            }
        }
    }
    _showBranding() {
        if (!this._logo) {
            const logo = this.tooltipContainer.children.push(_render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].new(this, {
                interactive: true,
                interactiveChildren: false,
                position: "absolute",
                setStateOnChildren: true,
                paddingTop: 9,
                paddingRight: 9,
                paddingBottom: 9,
                paddingLeft: 9,
                scale: .6,
                y: Object(_util_Percent__WEBPACK_IMPORTED_MODULE_18__["percent"])(100),
                centerY: _util_Percent__WEBPACK_IMPORTED_MODULE_18__["p100"],
                tooltipText: "Created using amCharts 5",
                tooltipX: _util_Percent__WEBPACK_IMPORTED_MODULE_18__["p100"],
                cursorOverStyle: "pointer",
                background: _render_Rectangle__WEBPACK_IMPORTED_MODULE_9__["Rectangle"].new(this, {
                    fill: Object(_util_Color__WEBPACK_IMPORTED_MODULE_19__["color"])(0x474758),
                    fillOpacity: 0,
                    tooltipY: 5
                })
            }));
            const tooltip = _render_Tooltip__WEBPACK_IMPORTED_MODULE_10__["Tooltip"].new(this, {
                pointerOrientation: "horizontal",
                paddingTop: 4,
                paddingRight: 7,
                paddingBottom: 4,
                paddingLeft: 7
            });
            tooltip.label.setAll({
                fontSize: 12
            });
            tooltip.get("background").setAll({
                fill: this.interfaceColors.get("background"),
                stroke: this.interfaceColors.get("grid"),
                strokeOpacity: 0.3
            });
            logo.set("tooltip", tooltip);
            logo.events.on("click", () => {
                window.open("https://www.amcharts.com/", "_blank");
            });
            logo.states.create("hover", {});
            const m = logo.children.push(_render_Graphics__WEBPACK_IMPORTED_MODULE_8__["Graphics"].new(this, {
                stroke: Object(_util_Color__WEBPACK_IMPORTED_MODULE_19__["color"])(0xcccccc),
                strokeWidth: 3,
                svgPath: "M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6"
            }));
            m.states.create("hover", { stroke: Object(_util_Color__WEBPACK_IMPORTED_MODULE_19__["color"])(0x3CABFF) });
            const a = logo.children.push(_render_Graphics__WEBPACK_IMPORTED_MODULE_8__["Graphics"].new(this, {
                stroke: Object(_util_Color__WEBPACK_IMPORTED_MODULE_19__["color"])(0x888888),
                strokeWidth: 3,
                svgPath: "M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0"
            }));
            a.states.create("hover", { stroke: Object(_util_Color__WEBPACK_IMPORTED_MODULE_19__["color"])(0x474758) });
            //logo.set("tooltip", this._tooltip);
            //logo.setPrivate("tooltipTarget", logo.get("background"));
            this._logo = logo;
            this._handleLogo();
        }
    }
    _getRealSize() {
        return this.dom.getBoundingClientRect();
    }
    _getCalculatedSize(rect) {
        if (this._settings.calculateSize) {
            return this._settings.calculateSize(rect);
        }
        else {
            return {
                width: rect.width,
                height: rect.height,
            };
        }
    }
    _init() {
        const renderer = this._renderer;
        const rect = this._getRealSize();
        const size = this._getCalculatedSize(rect);
        const width = Math.floor(size.width);
        const height = Math.floor(size.height);
        const realWidth = Math.floor(rect.width);
        const realHeight = Math.floor(rect.height);
        const rootContainer = _render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].new(this, {
            visible: true,
            width: realWidth,
            height: realHeight,
        });
        this._rootContainer = rootContainer;
        this._rootContainer._defaultThemes.push(_themes_DefaultTheme__WEBPACK_IMPORTED_MODULE_16__["DefaultTheme"].new(this));
        const container = rootContainer.children.push(_render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].new(this, { visible: true, width: _util_Percent__WEBPACK_IMPORTED_MODULE_18__["p100"], height: _util_Percent__WEBPACK_IMPORTED_MODULE_18__["p100"] }));
        this.container = container;
        renderer.resize(realWidth, realHeight, width, height);
        //@todo: better appendChild - refer
        this._inner.appendChild(renderer.view);
        // TODO: TMP TMP TMP for testing only, remove
        //renderer.debugGhostView = true;
        this._initResizeSensor();
        // HTML content holder
        const htmlElementContainer = document.createElement("div");
        this._htmlElementContainer = htmlElementContainer;
        htmlElementContainer.className = "am5-html-container";
        htmlElementContainer.style.position = "absolute";
        htmlElementContainer.style.pointerEvents = "none";
        if (!this._tooltipContainerSettings) {
            htmlElementContainer.style.overflow = "hidden";
        }
        this._inner.appendChild(htmlElementContainer);
        if (this._a11yD !== true) {
            // Create element which is used to make announcements to screen reader
            const readerAlertElement = document.createElement("div");
            readerAlertElement.className = "am5-reader-container";
            readerAlertElement.setAttribute("role", "alert");
            // readerAlertElement.style.zIndex = "-100000";
            // readerAlertElement.style.opacity = "0";
            // readerAlertElement.style.top = "0";
            readerAlertElement.style.position = "absolute";
            readerAlertElement.style.width = "1px";
            readerAlertElement.style.height = "1px";
            readerAlertElement.style.overflow = "hidden";
            readerAlertElement.style.clip = "rect(1px, 1px, 1px, 1px)";
            this._readerAlertElement = readerAlertElement;
            this._inner.appendChild(this._readerAlertElement);
            const focusElementContainer = document.createElement("div");
            focusElementContainer.className = "am5-focus-container";
            focusElementContainer.style.position = "absolute";
            focusElementContainer.style.pointerEvents = "none";
            focusElementContainer.style.top = "0px";
            focusElementContainer.style.left = "0px";
            focusElementContainer.style.overflow = "hidden";
            focusElementContainer.style.width = width + "px";
            focusElementContainer.style.height = height + "px";
            focusElementContainer.setAttribute("role", "application");
            _util_Utils__WEBPACK_IMPORTED_MODULE_25__["setInteractive"](focusElementContainer, false);
            this._focusElementContainer = focusElementContainer;
            this._inner.appendChild(this._focusElementContainer);
            const tooltipElementContainer = document.createElement("div");
            this._tooltipElementContainer = tooltipElementContainer;
            tooltipElementContainer.className = "am5-tooltip-container";
            this._inner.appendChild(tooltipElementContainer);
            // Add keyboard events for accessibility, e.g. simulating drag with arrow
            // keys and click with ENTER
            if (_util_Utils__WEBPACK_IMPORTED_MODULE_25__["supports"]("keyboardevents")) {
                this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_25__["addEventListener"](window, "keydown", (ev) => {
                    if (ev.keyCode == 16) {
                        this._isShift = true;
                    }
                    else if (ev.keyCode == 9) {
                        this._isShift = ev.shiftKey;
                    }
                }));
                this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_25__["addEventListener"](window, "keyup", (ev) => {
                    if (ev.keyCode == 16) {
                        this._isShift = false;
                    }
                }));
                this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_25__["addEventListener"](focusElementContainer, "keydown", (ev) => {
                    const focusedSprite = this._focusedSprite;
                    if (focusedSprite) {
                        if (ev.keyCode == 27) {
                            // ESC pressed - lose current focus
                            _util_Utils__WEBPACK_IMPORTED_MODULE_25__["blur"]();
                            this._focusedSprite = undefined;
                        }
                        let dragOffsetX = 0;
                        let dragOffsetY = 0;
                        // TODO: figure out if using bogus MouseEvent is fine, or it will
                        // fail on some platforms
                        switch (ev.keyCode) {
                            case 13:
                                ev.preventDefault();
                                const downEvent = renderer.getEvent(new MouseEvent("click"));
                                focusedSprite.events.dispatch("click", {
                                    type: "click",
                                    originalEvent: downEvent.event,
                                    point: downEvent.point,
                                    simulated: true,
                                    target: focusedSprite
                                });
                                return;
                            case 37:
                                dragOffsetX = -6;
                                break;
                            case 39:
                                dragOffsetX = 6;
                                break;
                            case 38:
                                dragOffsetY = -6;
                                break;
                            case 40:
                                dragOffsetY = 6;
                                break;
                            default:
                                return;
                        }
                        if (dragOffsetX != 0 || dragOffsetY != 0) {
                            ev.preventDefault();
                            if (!focusedSprite.isDragging()) {
                                // Start dragging
                                this._keyboardDragPoint = {
                                    x: 0,
                                    y: 0
                                };
                                const downEvent = renderer.getEvent(new MouseEvent("mousedown", {
                                    clientX: 0,
                                    clientY: 0
                                }));
                                if (focusedSprite.events.isEnabled("pointerdown")) {
                                    focusedSprite.events.dispatch("pointerdown", {
                                        type: "pointerdown",
                                        originalEvent: downEvent.event,
                                        point: downEvent.point,
                                        simulated: true,
                                        target: focusedSprite
                                    });
                                }
                            }
                            else {
                                // Move focus marker
                                //this._positionFocusElement(focusedSprite);
                            }
                            // Move incrementally
                            const dragPoint = this._keyboardDragPoint;
                            dragPoint.x += dragOffsetX;
                            dragPoint.y += dragOffsetY;
                            const moveEvent = renderer.getEvent(new MouseEvent("mousemove", {
                                clientX: dragPoint.x,
                                clientY: dragPoint.y
                            }), false);
                            if (focusedSprite.events.isEnabled("globalpointermove")) {
                                focusedSprite.events.dispatch("globalpointermove", {
                                    type: "globalpointermove",
                                    originalEvent: moveEvent.event,
                                    point: moveEvent.point,
                                    simulated: true,
                                    target: focusedSprite
                                });
                            }
                        }
                    }
                }));
                this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_25__["addEventListener"](focusElementContainer, "keyup", (ev) => {
                    if (this._focusedSprite) {
                        const focusedSprite = this._focusedSprite;
                        const keyCode = ev.keyCode;
                        switch (keyCode) {
                            case 37:
                            case 39:
                            case 38:
                            case 40:
                                if (focusedSprite.isDragging()) {
                                    // Simulate drag stop
                                    const dragPoint = this._keyboardDragPoint;
                                    const upEvent = renderer.getEvent(new MouseEvent("mouseup", {
                                        clientX: dragPoint.x,
                                        clientY: dragPoint.y
                                    }));
                                    if (focusedSprite.events.isEnabled("globalpointerup")) {
                                        focusedSprite.events.dispatch("globalpointerup", {
                                            type: "globalpointerup",
                                            originalEvent: upEvent.event,
                                            point: upEvent.point,
                                            simulated: true,
                                            target: focusedSprite
                                        });
                                    }
                                    //this._positionFocusElement(focusedSprite);
                                    this._keyboardDragPoint = undefined;
                                    // @todo dispatch mouseup event instead of calling dragStop?
                                    // this._dispatchEvent("globalpointerup", target, upEvent);
                                    return;
                                }
                                else if (focusedSprite.get("focusableGroup")) {
                                    // Find next item in focusable group
                                    const group = focusedSprite.get("focusableGroup");
                                    const items = this._tabindexes.filter(item => item.get("focusableGroup") == group);
                                    let index = items.indexOf(focusedSprite);
                                    const lastIndex = items.length - 1;
                                    index += (keyCode == 39 || keyCode == 40) ? 1 : -1;
                                    if (index < 0) {
                                        index = lastIndex;
                                    }
                                    else if (index > lastIndex) {
                                        index = 0;
                                    }
                                    _util_Utils__WEBPACK_IMPORTED_MODULE_25__["focus"](items[index].getPrivate("focusElement").dom);
                                }
                                break;
                        }
                    }
                }));
            }
        }
        this._startTicker();
        this.setThemes([]);
        this._addTooltip();
        if (!this._hasLicense()) {
            this._showBranding();
        }
    }
    _initResizeSensor() {
        if (this._resizeSensorDisposer) {
            this._resizeSensorDisposer.dispose();
        }
        this._resizeSensorDisposer = new _util_ResizeSensor__WEBPACK_IMPORTED_MODULE_6__["ResizeSensor"](this.dom, () => {
            if (this.autoResize) {
                this.resize();
            }
        });
        this._disposers.push(this._resizeSensorDisposer);
    }
    /**
     * If automatic resizing of char is disabled (`root.autoResize = false`), it
     * can be resized manually by calling this method.
     */
    resize() {
        const rect = this._getRealSize();
        const size = this._getCalculatedSize(rect);
        const w = Math.floor(size.width);
        const h = Math.floor(size.height);
        if (w > 0 && h > 0) {
            const realWidth = Math.floor(rect.width);
            const realHeight = Math.floor(rect.height);
            const htmlElementContainer = this._htmlElementContainer;
            htmlElementContainer.style.width = w + "px";
            htmlElementContainer.style.height = h + "px";
            if (this._a11yD !== true) {
                const focusElementContainer = this._focusElementContainer;
                focusElementContainer.style.width = w + "px";
                focusElementContainer.style.height = h + "px";
            }
            this._renderer.resize(realWidth, realHeight, w, h);
            const rootContainer = this._rootContainer;
            rootContainer.setPrivate("width", realWidth);
            rootContainer.setPrivate("height", realHeight);
            this._render();
            this._handleLogo();
        }
    }
    _render() {
        this._renderer.render(this._rootContainer._display);
        if (this._focusElementDirty) {
            this._updateCurrentFocus();
            this._focusElementDirty = false;
        }
    }
    _runTickers(currentTime) {
        _util_Array__WEBPACK_IMPORTED_MODULE_23__["each"](this._tickers, (f) => {
            f(currentTime);
        });
    }
    _runAnimations(currentTime) {
        _util_Array__WEBPACK_IMPORTED_MODULE_23__["keepIf"](this._animations, (animation) => {
            return animation._runAnimation(currentTime);
        });
    }
    _runDirties() {
        //console.log("tick **************************************************************");
        let allParents = {};
        while (this._isDirtyParents) {
            // This must be before calling _prepareChildren
            this._isDirtyParents = false;
            _util_Object__WEBPACK_IMPORTED_MODULE_24__["keys"](this._dirtyParents).forEach((key) => {
                const parent = this._dirtyParents[key];
                delete this._dirtyParents[key];
                if (!parent.isDisposed()) {
                    allParents[parent.uid] = parent;
                    parent._prepareChildren();
                }
            });
        }
        _util_Object__WEBPACK_IMPORTED_MODULE_24__["keys"](allParents).forEach((key) => {
            allParents[key]._updateChildren();
        });
        const objects = [];
        //		console.log("_beforeChanged")
        _util_Object__WEBPACK_IMPORTED_MODULE_24__["keys"](this._dirty).forEach((key) => {
            const entity = this._dirty[key];
            if (entity.isDisposed()) {
                delete this._dirty[entity.uid];
            }
            else {
                objects.push(entity);
                entity._beforeChanged();
            }
        });
        //		console.log("_changed")
        objects.forEach((entity) => {
            entity._changed();
            delete this._dirty[entity.uid];
            entity._clearDirty();
        });
        this._isDirty = false;
        const depths = {};
        const bounds = [];
        _util_Object__WEBPACK_IMPORTED_MODULE_24__["keys"](this._dirtyBounds).forEach((key) => {
            const entity = this._dirtyBounds[key];
            delete this._dirtyBounds[key];
            if (!entity.isDisposed()) {
                depths[entity.uid] = entity.depth();
                bounds.push(entity);
            }
        });
        this._positionHTMLElements();
        // High depth -> low depth
        bounds.sort((x, y) => {
            return _util_Order__WEBPACK_IMPORTED_MODULE_22__["compare"](depths[y.uid], depths[x.uid]);
        });
        //		console.log("_updateBounds")
        bounds.forEach((entity) => {
            entity._updateBounds();
        });
        //		console.log("_updatePosition")
        const dirtyPositions = this._dirtyPositions;
        _util_Object__WEBPACK_IMPORTED_MODULE_24__["keys"](dirtyPositions).forEach((key) => {
            const sprite = dirtyPositions[key];
            delete dirtyPositions[key];
            if (!sprite.isDisposed()) {
                sprite._updatePosition();
            }
        });
        //		console.log("_afterChanged")
        objects.forEach((entity) => {
            entity._afterChanged();
        });
    }
    _renderFrame(currentTime) {
        if (this._updateTick) {
            if (this.events.isEnabled("framestarted")) {
                this.events.dispatch("framestarted", {
                    type: "framestarted",
                    target: this,
                    timestamp: currentTime,
                });
            }
            this._checkComputedStyles();
            this._runTickers(currentTime);
            this._runAnimations(currentTime);
            this._runDirties();
            this._render();
            this._positionHTMLElements();
            if (this.events.isEnabled("frameended")) {
                this.events.dispatch("frameended", {
                    type: "frameended",
                    target: this,
                    timestamp: currentTime,
                });
            }
            return this._tickers.length === 0 &&
                this._animations.length === 0 &&
                !this._isDirty;
        }
        else {
            return true;
        }
    }
    _runTicker(currentTime, now) {
        if (!this.isDisposed()) {
            this.animationTime = currentTime;
            const done = this._renderFrame(currentTime);
            // No more work to do
            if (done) {
                this._ticker = null;
                this.animationTime = null;
            }
            else {
                if (!this._paused) {
                    if (now) {
                        this._ticker;
                    }
                    else {
                        rAF(this.fps, this._ticker);
                    }
                }
            }
        }
    }
    _runTickerNow() {
        if (!this.isDisposed()) {
            for (;;) {
                const currentTime = performance.now();
                this.animationTime = currentTime;
                const done = this._renderFrame(currentTime);
                if (done) {
                    this.animationTime = null;
                    break;
                }
            }
        }
    }
    _startTicker() {
        if (this._ticker === null) {
            this.animationTime = null;
            this._ticker = (currentTime) => {
                this._runTicker(currentTime);
            };
            rAF(this.fps, this._ticker);
        }
    }
    /**
     * Returns whether the root is updating or not.
     */
    get updateTick() {
        return this._updateTick;
    }
    /**
     * Enables or disables the root updating.
     */
    set updateTick(value) {
        this._updateTick = value;
        if (value) {
            this._startTicker();
        }
    }
    _addDirtyEntity(entity) {
        if (this._dirty[entity.uid] === undefined) {
            this._isDirty = true;
            this._dirty[entity.uid] = entity;
            this._startTicker();
        }
    }
    _addDirtyParent(parent) {
        if (this._dirtyParents[parent.uid] === undefined) {
            this._isDirty = true;
            this._isDirtyParents = true;
            this._dirtyParents[parent.uid] = parent;
            this._startTicker();
        }
    }
    _addDirtyBounds(entity) {
        if (this._dirtyBounds[entity.uid] === undefined) {
            this._isDirty = true;
            this._dirtyBounds[entity.uid] = entity;
            this._startTicker();
        }
    }
    _addDirtyPosition(sprite) {
        if (this._dirtyPositions[sprite.uid] === undefined) {
            this._isDirty = true;
            this._dirtyPositions[sprite.uid] = sprite;
            this._startTicker();
        }
    }
    _addAnimation(animation) {
        // TODO use numeric id instead
        if (this._animations.indexOf(animation) === -1) {
            this._animations.push(animation);
            this._startTicker();
        }
    }
    _markDirty() {
        this._isDirty = true;
    }
    _markDirtyRedraw() {
        this.events.once("frameended", () => {
            this._isDirty = true;
            this._startTicker();
        });
    }
    eachFrame(f) {
        this._tickers.push(f);
        this._startTicker();
        return new _util_Disposer__WEBPACK_IMPORTED_MODULE_5__["Disposer"](() => {
            _util_Array__WEBPACK_IMPORTED_MODULE_23__["removeFirst"](this._tickers, f);
        });
    }
    markDirtyGlobal(container) {
        if (!container) {
            container = this.container;
        }
        container.walkChildren((child) => {
            if (child instanceof _render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"]) {
                this.markDirtyGlobal(child);
            }
            child.markDirty();
            child.markDirtyBounds();
        });
    }
    /**
     * Returns width of the target container, in pixels.
     *
     * @return Width
     */
    width() {
        // TODO make this more efficient, maybe just return the renderer's width ?
        return Math.floor(this._getCalculatedSize(this._getRealSize()).width);
    }
    /**
     * Returns height of the target container, in pixels.
     *
     * @return Height
     */
    height() {
        // TODO make this more efficient, maybe just return the renderer's height ?
        return Math.floor(this._getCalculatedSize(this._getRealSize()).height);
    }
    /**
     * Disposes root and all the content in it.
     */
    dispose() {
        if (!this._isDisposed) {
            this._isDisposed = true;
            this._rootContainer.dispose();
            this._renderer.dispose();
            this.horizontalLayout.dispose();
            this.verticalLayout.dispose();
            this.interfaceColors.dispose();
            _util_Array__WEBPACK_IMPORTED_MODULE_23__["each"](this._disposers, (x) => {
                x.dispose();
            });
            if (this._inner) {
                _util_Utils__WEBPACK_IMPORTED_MODULE_25__["removeElement"](this._inner);
            }
            _util_Array__WEBPACK_IMPORTED_MODULE_23__["remove"](_Registry__WEBPACK_IMPORTED_MODULE_21__["registry"].rootElements, this);
        }
    }
    /**
     * Returns `true` if root element is disposed.
     *
     * @return Disposed?
     */
    isDisposed() {
        return this._isDisposed;
    }
    /**
     * Triggers screen reader read out a message.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
     * @param  text  Alert text
     */
    readerAlert(text) {
        if (this._a11yD !== true) {
            this._readerAlertElement.innerHTML = _util_Utils__WEBPACK_IMPORTED_MODULE_25__["stripTags"](text);
        }
    }
    /**
     * Sets themes to be used for the chart.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
     * @param  themes  A list of themes
     */
    setThemes(themes) {
        this._rootContainer.set("themes", themes);
        // otherwise new themes are not applied
        const tooltipContainer = this.tooltipContainer;
        if (tooltipContainer) {
            tooltipContainer._applyThemes();
        }
        // @todo review this
        const interfaceColors = this.interfaceColors;
        if (interfaceColors) {
            interfaceColors._applyThemes();
        }
    }
    _addTooltip() {
        if (!this.tooltipContainer) {
            const tooltipContainerSettings = this._tooltipContainerSettings;
            const tooltipContainer = this._rootContainer.children.push(_render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].new(this, {
                position: "absolute",
                isMeasured: false,
                width: _util_Percent__WEBPACK_IMPORTED_MODULE_18__["p100"],
                height: _util_Percent__WEBPACK_IMPORTED_MODULE_18__["p100"],
                layer: tooltipContainerSettings ? 35 : 30,
                layerMargin: tooltipContainerSettings ? tooltipContainerSettings : undefined
            }));
            this.tooltipContainer = tooltipContainer;
            const tooltip = _render_Tooltip__WEBPACK_IMPORTED_MODULE_10__["Tooltip"].new(this, {});
            this.container.set("tooltip", tooltip);
            tooltip.hide(0);
            this._tooltip = tooltip;
        }
    }
    /**
     * Accesibility
     */
    _registerTabindexOrder(target) {
        if (this._a11yD == true) {
            return;
        }
        if (target.get("focusable")) {
            _util_Array__WEBPACK_IMPORTED_MODULE_23__["pushOne"](this._tabindexes, target);
        }
        else {
            _util_Array__WEBPACK_IMPORTED_MODULE_23__["remove"](this._tabindexes, target);
        }
        this._invalidateTabindexes();
    }
    _unregisterTabindexOrder(target) {
        if (this._a11yD == true) {
            return;
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_23__["remove"](this._tabindexes, target);
        this._invalidateTabindexes();
    }
    _invalidateTabindexes() {
        if (this._a11yD == true) {
            return;
        }
        this._tabindexes.sort((a, b) => {
            const aindex = a.get("tabindexOrder", 0);
            const bindex = b.get("tabindexOrder", 0);
            if (aindex == bindex) {
                return 0;
            }
            else if (aindex > bindex) {
                return 1;
            }
            else {
                return -1;
            }
        });
        const groups = [];
        _util_Array__WEBPACK_IMPORTED_MODULE_23__["each"](this._tabindexes, (item, index) => {
            if (!item.getPrivate("focusElement")) {
                this._makeFocusElement(index, item);
            }
            else {
                this._moveFocusElement(index, item);
            }
            const group = item.get("focusableGroup");
            if (group) {
                if (groups.indexOf(group) !== -1) {
                    // Non-first element in the group, make it not directly focusable
                    item.getPrivate("focusElement").dom.setAttribute("tabindex", "-1");
                }
                else {
                    groups.push(group);
                }
            }
        });
    }
    _updateCurrentFocus() {
        if (this._a11yD == true) {
            return;
        }
        if (this._focusedSprite) {
            this._decorateFocusElement(this._focusedSprite);
            this._positionFocusElement(this._focusedSprite);
        }
    }
    _decorateFocusElement(target, focusElement) {
        if (this._a11yD == true) {
            return;
        }
        // Decorate with proper accessibility attributes
        if (!focusElement) {
            focusElement = target.getPrivate("focusElement").dom;
        }
        if (!focusElement) {
            return;
        }
        if (target.get("visible") && target.get("role") != "tooltip" && !target.isHidden()) {
            if (focusElement.getAttribute("tabindex") != "-1") {
                focusElement.setAttribute("tabindex", "" + this.tabindex);
            }
        }
        else {
            focusElement.removeAttribute("tabindex");
        }
        const role = target.get("role");
        if (role) {
            focusElement.setAttribute("role", role);
        }
        else {
            focusElement.removeAttribute("role");
        }
        const ariaLabel = target.get("ariaLabel");
        if (ariaLabel) {
            const label = Object(_util_PopulateString__WEBPACK_IMPORTED_MODULE_20__["populateString"])(target, ariaLabel);
            focusElement.setAttribute("aria-label", label);
        }
        else {
            focusElement.removeAttribute("aria-label");
        }
        const ariaLive = target.get("ariaLive");
        if (ariaLive) {
            focusElement.setAttribute("aria-live", ariaLive);
        }
        else {
            focusElement.removeAttribute("aria-live");
        }
        const ariaChecked = target.get("ariaChecked");
        if (ariaChecked != null) {
            focusElement.setAttribute("aria-checked", ariaChecked ? "true" : "false");
        }
        else {
            focusElement.removeAttribute("aria-checked");
        }
        if (target.get("ariaHidden")) {
            focusElement.setAttribute("aria-hidden", "hidden");
        }
        else {
            focusElement.removeAttribute("aria-hidden");
        }
        const ariaOrientation = target.get("ariaOrientation");
        if (ariaOrientation) {
            focusElement.setAttribute("aria-orientation", ariaOrientation);
        }
        else {
            focusElement.removeAttribute("aria-orientation");
        }
        const ariaValueNow = target.get("ariaValueNow");
        if (ariaValueNow) {
            focusElement.setAttribute("aria-valuenow", ariaValueNow);
        }
        else {
            focusElement.removeAttribute("aria-valuenow");
        }
        const ariaValueMin = target.get("ariaValueMin");
        if (ariaValueMin) {
            focusElement.setAttribute("aria-valuemin", ariaValueMin);
        }
        else {
            focusElement.removeAttribute("aria-valuemin");
        }
        const ariaValueMax = target.get("ariaValueMax");
        if (ariaValueMax) {
            focusElement.setAttribute("aria-valuemax", ariaValueMax);
        }
        else {
            focusElement.removeAttribute("aria-valuemax");
        }
        const ariaValueText = target.get("ariaValueText");
        if (ariaValueText) {
            focusElement.setAttribute("aria-valuetext", ariaValueText);
        }
        else {
            focusElement.removeAttribute("aria-valuetext");
        }
        const ariaControls = target.get("ariaControls");
        if (ariaControls) {
            focusElement.setAttribute("aria-controls", ariaControls);
        }
        else {
            focusElement.removeAttribute("aria-controls");
        }
    }
    _makeFocusElement(index, target) {
        if (target.getPrivate("focusElement") || this._a11yD == true) {
            return;
        }
        // Init
        const focusElement = document.createElement("div");
        if (target.get("role") != "tooltip") {
            focusElement.tabIndex = this.tabindex;
        }
        focusElement.style.position = "absolute";
        _util_Utils__WEBPACK_IMPORTED_MODULE_25__["setInteractive"](focusElement, false);
        const disposers = [];
        target.setPrivate("focusElement", {
            dom: focusElement,
            disposers,
        });
        this._decorateFocusElement(target);
        disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_25__["addEventListener"](focusElement, "focus", (ev) => {
            this._handleFocus(ev, index);
        }));
        disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_25__["addEventListener"](focusElement, "blur", (ev) => {
            this._handleBlur(ev, index);
        }));
        this._moveFocusElement(index, target);
    }
    _removeFocusElement(target) {
        if (this._a11yD == true) {
            return;
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_23__["remove"](this._tabindexes, target);
        const focusElement = target.getPrivate("focusElement");
        if (focusElement) {
            const container = this._focusElementContainer;
            container.removeChild(focusElement.dom);
            _util_Array__WEBPACK_IMPORTED_MODULE_23__["each"](focusElement.disposers, (x) => {
                x.dispose();
            });
        }
    }
    _hideFocusElement(target) {
        if (this._a11yD == true) {
            return;
        }
        const focusElement = target.getPrivate("focusElement");
        focusElement.dom.style.display = "none";
    }
    _moveFocusElement(index, target) {
        if (this._a11yD == true) {
            return;
        }
        // Get container
        const container = this._focusElementContainer;
        const focusElement = target.getPrivate("focusElement").dom;
        if (focusElement === this._focusElementContainer.children[index]) {
            // Nothing to do
            return;
        }
        const next = this._focusElementContainer.children[index + 1];
        if (next) {
            container.insertBefore(focusElement, next);
        }
        else {
            container.append(focusElement);
        }
    }
    _positionFocusElement(target) {
        if (this._a11yD == true) {
            return;
        }
        const bounds = target.globalBounds();
        let width = bounds.right == bounds.left ? target.width() : bounds.right - bounds.left;
        let height = bounds.top == bounds.bottom ? target.height() : bounds.bottom - bounds.top;
        let x = bounds.left - 2;
        let y = bounds.top - 2;
        if (width < 0) {
            x += width;
            width = Math.abs(width);
        }
        if (height < 0) {
            y += height;
            height = Math.abs(height);
        }
        const focusElement = target.getPrivate("focusElement").dom;
        focusElement.style.top = y + "px";
        focusElement.style.left = x + "px";
        focusElement.style.width = (width + 4) + "px";
        focusElement.style.height = (height + 4) + "px";
    }
    _handleFocus(ev, index) {
        if (this._a11yD == true) {
            return;
        }
        // Get element
        const focused = this._tabindexes[index];
        // Jump over hidden elements
        if (!focused.isVisibleDeep()) {
            this._focusNext(ev.target, this._isShift ? -1 : 1);
            return;
        }
        // Size and position
        this._positionFocusElement(focused);
        //this._decorateFocusElement(focused);
        this._focusedSprite = focused;
        if (focused.events.isEnabled("focus")) {
            focused.events.dispatch("focus", {
                type: "focus",
                originalEvent: ev,
                target: focused
            });
        }
    }
    _focusNext(el, direction) {
        if (this._a11yD == true) {
            return;
        }
        var focusableElements = Array.from(document.querySelectorAll([
            'a[href]',
            'area[href]',
            'button:not([disabled])',
            'details',
            'input:not([disabled])',
            'iframe:not([disabled])',
            'select:not([disabled])',
            'textarea:not([disabled])',
            '[contentEditable=""]',
            '[contentEditable="true"]',
            '[contentEditable="TRUE"]',
            '[tabindex]:not([tabindex^="-"])',
            //':not([disabled])'
        ].join(',')));
        let index = focusableElements.indexOf(el) + direction;
        if (index < 0) {
            index = focusableElements.length - 1;
        }
        else if (index >= focusableElements.length) {
            index = 0;
        }
        focusableElements[index].focus();
    }
    _handleBlur(ev, _index) {
        if (this._a11yD == true) {
            return;
        }
        const focused = this._focusedSprite;
        if (focused && focused.events.isEnabled("blur")) {
            focused.events.dispatch("blur", {
                type: "blur",
                originalEvent: ev,
                target: focused
            });
        }
        this._focusedSprite = undefined;
    }
    /**
     * @ignore
     */
    updateTooltip(target) {
        if (this._a11yD == true) {
            return;
        }
        const text = _util_Utils__WEBPACK_IMPORTED_MODULE_25__["stripTags"](target._getText());
        let tooltipElement = target.getPrivate("tooltipElement");
        if (target.get("role") == "tooltip" && text != "") {
            if (!tooltipElement) {
                tooltipElement = this._makeTooltipElement(target);
            }
            if (tooltipElement.innerHTML != text) {
                tooltipElement.innerHTML = text;
            }
        }
        else if (tooltipElement) {
            tooltipElement.remove();
            target.removePrivate("tooltipElement");
        }
    }
    _makeTooltipElement(target) {
        const container = this._tooltipElementContainer;
        const tooltipElement = document.createElement("div");
        tooltipElement.style.position = "absolute";
        tooltipElement.style.width = "1px";
        tooltipElement.style.height = "1px";
        tooltipElement.style.overflow = "hidden";
        tooltipElement.style.clip = "rect(1px, 1px, 1px, 1px)";
        _util_Utils__WEBPACK_IMPORTED_MODULE_25__["setInteractive"](tooltipElement, false);
        this._decorateFocusElement(target, tooltipElement);
        container.append(tooltipElement);
        target.setPrivate("tooltipElement", tooltipElement);
        return tooltipElement;
    }
    _removeTooltipElement(target) {
        if (this._a11yD == true) {
            return;
        }
        const tooltipElement = target.getPrivate("tooltipElement");
        if (tooltipElement) {
            const parent = tooltipElement.parentElement;
            if (parent) {
                parent.removeChild(tooltipElement);
            }
        }
    }
    _invalidateAccessibility(target) {
        if (this._a11yD == true) {
            return;
        }
        this._focusElementDirty = true;
        const focusElement = target.getPrivate("focusElement");
        if (target.get("focusable")) {
            if (focusElement) {
                this._decorateFocusElement(target);
                this._positionFocusElement(target);
            }
            // else {
            // 	this._renderer._makeFocusElement(0, this);
            // }
        }
        else if (focusElement) {
            this._removeFocusElement(target);
        }
        //this.updateCurrentFocus();
    }
    /**
     * Returns `true` if `target` is currently focused.
     *
     * @param   target  Target
     * @return          Focused?
     */
    focused(target) {
        return this._focusedSprite === target;
    }
    /**
     * Converts document coordinates to coordinates withing root element.
     *
     * @param   point  Document point
     * @return         Root point
     */
    documentPointToRoot(point) {
        const bbox = this.dom.getBoundingClientRect();
        return {
            x: point.x - bbox.left,
            y: point.y - bbox.top
        };
    }
    /**
     * Converts root coordinates to document
     *
     * @param   point  Document point
     * @return         Root point
     */
    rootPointToDocument(point) {
        const bbox = this.dom.getBoundingClientRect();
        return {
            x: point.x + bbox.left,
            y: point.y + bbox.top
        };
    }
    /**
     * @ignore
     */
    addDisposer(disposer) {
        this._disposers.push(disposer);
        return disposer;
    }
    _updateComputedStyles() {
        const styles = window.getComputedStyle(this.dom);
        let fontHash = "";
        _util_Object__WEBPACK_IMPORTED_MODULE_24__["each"](styles, (key, val) => {
            if (_util_Type__WEBPACK_IMPORTED_MODULE_26__["isString"](key) && key.match(/^font/)) {
                fontHash += val;
            }
        });
        const changed = fontHash != this._fontHash;
        if (changed) {
            this._fontHash = fontHash;
        }
        return changed;
    }
    _checkComputedStyles() {
        if (this._updateComputedStyles()) {
            this._invalidateLabelBounds(this.container);
        }
    }
    _invalidateLabelBounds(target) {
        if (target instanceof _render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"]) {
            target.children.each((child) => {
                this._invalidateLabelBounds(child);
            });
        }
        else if (target instanceof _render_Text__WEBPACK_IMPORTED_MODULE_1__["Text"]) {
            target.markDirtyBounds();
        }
    }
    /**
     * To all the clever heads out there. Yes, we did not make any attempts to
     * scramble this.
     *
     * This is a part of a tool meant for our users to manage their commercial
     * licenses for removal of amCharts branding from charts.
     *
     * The only legit way to do so is to purchase a commercial license for amCharts:
     * https://www.amcharts.com/online-store/
     *
     * Removing or altering this code, or disabling amCharts branding in any other
     * way is against the license and thus illegal.
     */
    _hasLicense() {
        for (let i = 0; i < _Registry__WEBPACK_IMPORTED_MODULE_21__["registry"].licenses.length; i++) {
            if (_Registry__WEBPACK_IMPORTED_MODULE_21__["registry"].licenses[i].match(/^AM5C.{5,}/i)) {
                return true;
            }
        }
        return false;
    }
    _licenseApplied() {
        if (this._logo) {
            this._logo.set("forceHidden", true);
        }
    }
    /**
     * @ignore
     */
    get debugGhostView() {
        return this._renderer.debugGhostView;
    }
    /**
     * @ignore
     */
    set debugGhostView(value) {
        this._renderer.debugGhostView = value;
    }
    /**
     * Set this to `true` if you need chart to require first a tap onto it before
     * touch gesture related functionality like zoom/pan is turned on.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
     * @default false
     * @since 5.2.9
     * @param  value  Needs a tap to activate touch functions
     */
    set tapToActivate(value) {
        this._renderer.tapToActivate = value;
    }
    /**
     * @return Needs a tap to activate touch functions
     */
    get tapToActivate() {
        return this._renderer.tapToActivate;
    }
    /**
     * If `tapToActivate` is set to `true`, this setting will determine number
     * of milliseconds the chart will stay "active", before releasing the
     * controls back to the page.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
     * @default 3000
     * @since 5.2.9
     * @param  value  Timeout
     */
    set tapToActivateTimeout(value) {
        this._renderer.tapToActivateTimeout = value;
    }
    /**
     * @return Timeout
     */
    get tapToActivateTimeout() {
        return this._renderer.tapToActivateTimeout;
    }
    _makeHTMLElement(target) {
        // Get container
        const container = this._htmlElementContainer;
        // Init
        const htmlElement = document.createElement("div");
        target.setPrivate("htmlElement", htmlElement);
        //htmlElement.tabIndex = this.tabindex;
        htmlElement.style.position = "absolute";
        htmlElement.style.overflow = "auto";
        htmlElement.style.boxSizing = "border-box";
        _util_Utils__WEBPACK_IMPORTED_MODULE_25__["setInteractive"](htmlElement, target.get("interactive", false));
        // Translate events
        if (target.events.isEnabled("click")) {
            _util_Utils__WEBPACK_IMPORTED_MODULE_25__["setInteractive"](htmlElement, true);
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_25__["addEventListener"](htmlElement, "click", (ev) => {
                const downEvent = this._renderer.getEvent(ev);
                target.events.dispatch("click", {
                    type: "click",
                    originalEvent: downEvent.event,
                    point: downEvent.point,
                    simulated: false,
                    target: target
                });
            }));
        }
        this._positionHTMLElement(target);
        container.append(htmlElement);
        _util_Array__WEBPACK_IMPORTED_MODULE_23__["pushOne"](this._htmlEnabledContainers, target);
        return htmlElement;
    }
    _positionHTMLElements() {
        _util_Array__WEBPACK_IMPORTED_MODULE_23__["each"](this._htmlEnabledContainers, (target) => {
            this._positionHTMLElement(target);
        });
    }
    _positionHTMLElement(target) {
        const htmlElement = target.getPrivate("htmlElement");
        if (htmlElement) {
            // Translate settings
            const visualSettings = ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "minWidth", "minHeight", "maxWidth", "maxHeight"];
            _util_Array__WEBPACK_IMPORTED_MODULE_23__["each"](visualSettings, (setting) => {
                const value = target.get(setting);
                if (value) {
                    htmlElement.style[setting] = value + "px";
                }
                else {
                    htmlElement.style[setting] = "";
                }
            });
            // Deal with opacity
            const opacity = target.compositeOpacity();
            setTimeout(() => {
                htmlElement.style.opacity = opacity + "";
            }, 10);
            const visible = target.isVisibleDeep();
            if (visible) {
                htmlElement.style.display = "block";
            }
            // Deal with position
            const bounds = target.globalBounds();
            htmlElement.style.top = (bounds.top) + "px";
            htmlElement.style.left = (bounds.left) + "px";
            // Use width/height if those are set
            const width = target.get("width");
            const height = target.get("height");
            let w = 0;
            let h = 0;
            if (width) {
                w = target.width();
            }
            if (height) {
                h = target.height();
            }
            if (!width || !height) {
                htmlElement.style.position = "fixed";
                htmlElement.style.width = "";
                htmlElement.style.height = "";
                const bbox = htmlElement.getBoundingClientRect();
                htmlElement.style.position = "absolute";
                w = bbox.width;
                h = bbox.height;
                target._adjustedLocalBounds = { left: 0, right: 0, top: 0, bottom: 0 };
                target.setPrivate("minWidth", w);
                target.setPrivate("minHeight", h);
            }
            else {
                target.removePrivate("minWidth");
                target.removePrivate("minHeight");
            }
            if (w > 0) {
                htmlElement.style.minWidth = (w) + "px";
            }
            if (h > 0) {
                htmlElement.style.minHeight = (h) + "px";
            }
            // Hide or show
            if (!visible || opacity == 0) {
                htmlElement.style.display = "none";
            }
        }
    }
    _setHTMLContent(target, html) {
        let htmlElement = target.getPrivate("htmlElement");
        if (!htmlElement) {
            htmlElement = this._makeHTMLElement(target);
        }
        if (htmlElement.innerHTML != html) {
            htmlElement.innerHTML = html;
        }
    }
    _removeHTMLContent(target) {
        let htmlElement = target.getPrivate("htmlElement");
        if (htmlElement) {
            this._htmlElementContainer.removeChild(htmlElement);
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_23__["remove"](this._htmlEnabledContainers, target);
    }
}
//# sourceMappingURL=Root.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js":
/*!******************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/Theme.js ***!
  \******************************************************************/
/*! exports provided: Theme */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Theme", function() { return Theme; });
/* harmony import */ var _util_Template__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _util_Order__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/Order */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");



/**
 * A base class for an amCharts theme.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
 * @important
 */
class Theme {
    constructor(root, isReal) {
        Object.defineProperty(this, "_root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rules", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._root = root;
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   root      Root element
     * @param   settings  Settings
     * @param   template  Template
     * @return            Instantiated object
     */
    static new(root) {
        const x = (new this(root, true));
        x.setupDefaultRules();
        return x;
    }
    setupDefaultRules() { }
    /**
     * Looks up the rules for a specific theme class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
     * @param   themeClass Theme class
     * @return             Array<IRule<A>>
     */
    _lookupRules(themeClass) {
        return this._rules[themeClass];
    }
    /**
     * Creates a [[Template]] for specific theme class and tags.
     *
     * NOTE: the difference from `rule()` is that `ruleRaw()` does not do any
     * type checks.
     *
     * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
     * @param   themeClass Theme class
     * @param   themeTags  Theme tags
     * @return             Template
     */
    ruleRaw(themeClass, themeTags = []) {
        let rules = this._rules[themeClass];
        if (!rules) {
            rules = this._rules[themeClass] = [];
        }
        themeTags.sort(_util_Order__WEBPACK_IMPORTED_MODULE_1__["compare"]);
        const { index, found } = _util_Array__WEBPACK_IMPORTED_MODULE_2__["getSortedIndex"](rules, (x) => {
            const order = _util_Order__WEBPACK_IMPORTED_MODULE_1__["compare"](x.tags.length, themeTags.length);
            if (order === 0) {
                return _util_Order__WEBPACK_IMPORTED_MODULE_1__["compareArray"](x.tags, themeTags, _util_Order__WEBPACK_IMPORTED_MODULE_1__["compare"]);
            }
            else {
                return order;
            }
        });
        if (found) {
            return rules[index].template;
        }
        else {
            const template = _util_Template__WEBPACK_IMPORTED_MODULE_0__["Template"].new({});
            rules.splice(index, 0, {
                tags: themeTags,
                template,
            });
            return template;
        }
    }
    /**
     * Creates a [[Template]] for specific theme class and tags.
     *
     * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
     * @param   themeClass Theme class
     * @param   themeTags  Theme tags
     * @return             Template
     */
    rule(themeClass, themeTags = []) {
        return this.ruleRaw(themeClass, themeTags);
    }
}
//# sourceMappingURL=Theme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Bullet.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Bullet.js ***!
  \**************************************************************************/
/*! exports provided: Bullet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bullet", function() { return Bullet; });
/* harmony import */ var _core_util_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");

/**
 * A universal placeholder for bullet elements.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/} for more info
 */
class Bullet extends _core_util_Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    constructor() {
        super(...arguments);
        // used by MapPolygons where one data item can have multiple bullets of the same kind
        Object.defineProperty(this, "_index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Target series object if it's a bullet for series.
         */
        Object.defineProperty(this, "series", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        // Applying themes because bullet will not have parent
        super._afterNewApplyThemes();
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("sprite")) {
            const sprite = this.get("sprite");
            if (sprite) {
                sprite.setAll({ position: "absolute", role: "figure" });
                this._disposers.push(sprite);
            }
        }
        if (this.isDirty("locationX") || this.isDirty("locationY")) {
            if (this.series) {
                this.series._positionBullet(this);
            }
        }
    }
}
Object.defineProperty(Bullet, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Bullet"
});
Object.defineProperty(Bullet, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_util_Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"].classNames.concat([Bullet.className])
});
//# sourceMappingURL=Bullet.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js ***!
  \**************************************************************************/
/*! exports provided: Button */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Button", function() { return Button; });
/* harmony import */ var _render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");



/**
 * Draws an interactive button.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/buttons/} for more info
 * @important
 */
class Button extends _Container__WEBPACK_IMPORTED_MODULE_1__["Container"] {
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_2__["mergeTags"](this._settings.themeTags, ["button"]);
        super._afterNew();
        if (!this._settings.background) {
            this.set("background", _render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__["RoundedRectangle"].new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_2__["mergeTags"](this._settings.themeTags, ["background"])
            }));
        }
    }
    _prepareChildren() {
        super._prepareChildren();
        if (this.isDirty("icon")) {
            const previous = this._prevSettings.icon;
            const icon = this.get("icon");
            if (icon !== previous) {
                this._disposeProperty("icon");
                if (previous) {
                    previous.dispose();
                }
                if (icon) {
                    this.children.push(icon);
                }
                this._prevSettings.icon = icon;
            }
        }
        if (this.isDirty("label")) {
            const previous = this._prevSettings.label;
            const label = this.get("label");
            if (label !== previous) {
                this._disposeProperty("label");
                if (previous) {
                    previous.dispose();
                }
                if (label) {
                    this.children.push(label);
                }
                this._prevSettings.label = label;
            }
        }
    }
}
Object.defineProperty(Button, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Button"
});
Object.defineProperty(Button, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_1__["Container"].classNames.concat([Button.className])
});
//# sourceMappingURL=Button.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js ***!
  \*************************************************************************/
/*! exports provided: Chart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Chart", function() { return Chart; });
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");


/**
 * A base class for all charts.
 */
class Chart extends _core_render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"] {
    constructor() {
        super(...arguments);
        /**
         * A [[Container]] chart places its elements in.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "chartContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_core_render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"], interactiveChildren: false }))
        });
        /**
         * A [[Container]] chart places its bullets in.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "bulletsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].new(this._root, { interactiveChildren: false, isMeasured: false, position: "absolute", width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"] })
        });
    }
}
Object.defineProperty(Chart, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Chart"
});
Object.defineProperty(Chart, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].classNames.concat([Chart.className])
});
//# sourceMappingURL=Chart.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Circle.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Circle.js ***!
  \**************************************************************************/
/*! exports provided: Circle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");

/**
 * Draws a circle.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Circle extends _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("radius")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            this._display.drawCircle(0, 0, this.get("radius", 10));
        }
    }
}
Object.defineProperty(Circle, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Circle"
});
Object.defineProperty(Circle, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"].classNames.concat([Circle.className])
});
//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js ***!
  \*****************************************************************************/
/*! exports provided: DataItem, Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataItem", function() { return DataItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/@amcharts/amcharts5/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _util_Data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Data */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");






/**
 * A base element that holds data bit (data item) for any [[Component]].
 */
class DataItem extends _util_Entity__WEBPACK_IMPORTED_MODULE_1__["Settings"] {
    constructor(component, dataContext, settings) {
        super(settings);
        /**
         * A data item's owener [[Component]].
         */
        Object.defineProperty(this, "component", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A reference to actual item in source data this item is based on.
         */
        Object.defineProperty(this, "dataContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * @todo requires description
         */
        Object.defineProperty(this, "bullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A set of "open" values.
         */
        Object.defineProperty(this, "open", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A set of "close" values.
         */
        Object.defineProperty(this, "close", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dataContext = dataContext;
        this.component = component;
        this._settings.visible = true;
        this._checkDirty();
    }
    /**
     * @ignore
     */
    markDirty() {
        this.component.markDirtyValues(this);
    }
    _startAnimation() {
        this.component._root._addAnimation(this);
    }
    _animationTime() {
        return this.component._root.animationTime;
    }
    _dispose() {
        if (this.component) {
            this.component.disposeDataItem(this);
        }
        super._dispose();
    }
    /**
     * Shows a data item that's currently hidden.
     */
    show(duration) {
        this.setRaw("visible", true);
        if (this.component) {
            this.component.showDataItem(this, duration);
        }
    }
    /**
     * Hides a data item that's currently visible.
     */
    hide(duration) {
        this.setRaw("visible", false);
        if (this.component) {
            this.component.hideDataItem(this, duration);
        }
    }
    isHidden() {
        return !this.get("visible");
    }
}
/**
 * A base class for elements that make use of data.
 */
class Component extends _Container__WEBPACK_IMPORTED_MODULE_2__["Container"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_Data__WEBPACK_IMPORTED_MODULE_3__["ListData"]()
        });
        Object.defineProperty(this, "_dataItems", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_mainDataItems", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._dataItems
        });
        Object.defineProperty(this, "valueFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "fields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ["id"]
        });
        Object.defineProperty(this, "_valueFields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_valueFieldsF", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_fields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_fieldsF", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_valuesDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dataChanged", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dataGrouped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * Indicates if the component has already been initialized.
         */
        Object.defineProperty(this, "inited", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    /**
     * Component's data.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
     */
    set data(data) {
        data.incrementRef();
        this._data.decrementRef();
        this._data = data;
    }
    /**
     * @return  Data
     */
    get data() {
        return this._data;
    }
    _dispose() {
        super._dispose();
        this._data.decrementRef();
    }
    _onDataClear() {
    }
    _afterNew() {
        super._afterNew();
        this._data.incrementRef();
        this._updateFields();
        this._disposers.push(this.data.events.onAll((change) => {
            const dataItems = this._mainDataItems;
            this.markDirtyValues();
            this._markDirtyGroup();
            this._dataChanged = true;
            if (change.type === "clear") {
                _util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](dataItems, (dataItem) => {
                    dataItem.dispose();
                });
                dataItems.length = 0;
                this._onDataClear();
            }
            else if (change.type === "push") {
                const dataItem = new DataItem(this, change.newValue, this._makeDataItem(change.newValue));
                dataItems.push(dataItem);
                this.processDataItem(dataItem);
            }
            else if (change.type === "setIndex") {
                const dataItem = dataItems[change.index];
                const properties = this._makeDataItem(change.newValue);
                if (dataItem.bullets && dataItem.bullets.length == 0) {
                    dataItem.bullets = undefined;
                }
                _util_Object__WEBPACK_IMPORTED_MODULE_5__["keys"](properties).forEach((key) => {
                    dataItem.animate({
                        key: key,
                        to: properties[key],
                        duration: this.get("interpolationDuration", 0),
                        easing: this.get("interpolationEasing"),
                    });
                });
                dataItem.dataContext = change.newValue;
            }
            else if (change.type === "insertIndex") {
                const dataItem = new DataItem(this, change.newValue, this._makeDataItem(change.newValue));
                dataItems.splice(change.index, 0, dataItem);
                this.processDataItem(dataItem);
            }
            else if (change.type === "removeIndex") {
                const dataItem = dataItems[change.index];
                dataItem.dispose();
                dataItems.splice(change.index, 1);
            }
            else if (change.type === "moveIndex") {
                const dataItem = dataItems[change.oldIndex];
                dataItems.splice(change.oldIndex, 1);
                dataItems.splice(change.newIndex, 0, dataItem);
            }
            else {
                throw new Error("Unknown IStreamEvent type");
            }
            this._afterDataChange();
        }));
    }
    _updateFields() {
        if (this.valueFields) {
            this._valueFields = [];
            this._valueFieldsF = {};
            _util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.valueFields, (key) => {
                const field = this.get((key + "Field"));
                if (field) {
                    this._valueFields.push(key);
                    this._valueFieldsF[key] = { fieldKey: key + "Field", workingKey: key + "Working" };
                }
            });
        }
        if (this.fields) {
            this._fields = [];
            this._fieldsF = {};
            _util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.fields, (key) => {
                const field = this.get((key + "Field"));
                if (field) {
                    this._fields.push(key);
                    this._fieldsF[key] = key + "Field";
                }
            });
        }
    }
    /**
     * A list of component's data items.
     *
     * @return  Data items
     */
    get dataItems() {
        return this._dataItems;
    }
    processDataItem(_dataItem) { }
    _makeDataItem(data) {
        //const output: this["_dataItemSettings"] = {};
        const output = {}; // temporary to solve error
        if (this._valueFields) {
            _util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this._valueFields, (key) => {
                const field = this.get((this._valueFieldsF[key].fieldKey));
                output[key] = data[field];
                output[this._valueFieldsF[key].workingKey] = output[key];
            });
        }
        if (this._fields) {
            _util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](this._fields, (key) => {
                const field = this.get((this._fieldsF[key]));
                output[key] = data[field];
            });
        }
        return output;
    }
    /**
     * @ignore
     */
    makeDataItem(data) {
        let dataItem = new DataItem(this, undefined, data);
        this.processDataItem(dataItem);
        return dataItem;
    }
    /**
     * @ignore
     */
    pushDataItem(data) {
        const dataItem = this.makeDataItem(data);
        this._mainDataItems.push(dataItem);
        return dataItem;
    }
    /**
     * @ignore
     */
    disposeDataItem(_dataItem) {
    }
    /**
     * Shows component's data item.
     *
     * @param   dataItem   Data item
     * @param   _duration  Animation duration in milliseconds
     * @return             Promise
     */
    showDataItem(dataItem, _duration) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            dataItem.set("visible", true);
        });
    }
    /**
     * Hides component's data item.
     *
     * @param   dataItem   Data item
     * @param   _duration  Animation duration in milliseconds
     * @return             Promise
     */
    hideDataItem(dataItem, _duration) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            dataItem.set("visible", false);
        });
    }
    _clearDirty() {
        super._clearDirty();
        this._valuesDirty = false;
    }
    _afterDataChange() {
    }
    _afterChanged() {
        super._afterChanged();
        if (this._dataChanged) {
            const type = "datavalidated";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, { type: type, target: this });
            }
            this._dataChanged = false;
        }
        this.inited = true;
    }
    /**
     * Forces a repaint of the element which relies on data.
     *
     * @since 5.0.21
     */
    markDirtyValues(_dataItem) {
        this.markDirty();
        this._valuesDirty = true;
    }
    _markDirtyGroup() {
        this._dataGrouped = false;
    }
    /**
     * @ignore
     */
    markDirtySize() {
        this._sizeDirty = true;
        this.markDirty();
    }
}
Object.defineProperty(Component, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Component"
});
Object.defineProperty(Component, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_2__["Container"].classNames.concat([Component.className])
});
//# sourceMappingURL=Component.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js ***!
  \*****************************************************************************/
/*! exports provided: Container */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Container", function() { return Container; });
/* harmony import */ var _util_Children__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Children */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Children.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Sprite */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js");
/* harmony import */ var _Rectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _HorizontalLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HorizontalLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js");
/* harmony import */ var _VerticalLayout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VerticalLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js");
/* harmony import */ var _GridLayout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GridLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js");
/* harmony import */ var _util_PopulateString__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/PopulateString */ "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");











/**
 * A basic element that can have child elements, maintain their layout, and
 * have a background.
 *
 * It can have any [[Sprite]] element as a child, from very basic shapes, to
 * full-fledged charts.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info
 * @important
 */
class Container extends _Sprite__WEBPACK_IMPORTED_MODULE_2__["Sprite"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeContainer()
        });
        Object.defineProperty(this, "_childrenDisplay", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeContainer()
        });
        /**
         * List of Container's child elements.
         */
        Object.defineProperty(this, "children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_Children__WEBPACK_IMPORTED_MODULE_0__["Children"](this)
        });
        Object.defineProperty(this, "_percentageSizeChildren", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_percentagePositionChildren", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_prevWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_prevHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_contentWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_contentHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_contentMask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_vsbd0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_vsbd1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        super._afterNew();
        this._display.addChild(this._childrenDisplay);
    }
    _dispose() {
        _util_Array__WEBPACK_IMPORTED_MODULE_8__["eachReverse"](this.allChildren(), (child) => {
            child.dispose();
        });
        if (this.getPrivate("htmlElement")) {
            this._root._removeHTMLContent(this);
        }
        super._dispose();
    }
    _changed() {
        super._changed();
        if (this.isDirty("interactiveChildren")) {
            this._display.interactiveChildren = this.get("interactiveChildren", false);
        }
        if (this.isDirty("layout")) {
            this._prevWidth = 0;
            this._prevHeight = 0;
            this.markDirtyBounds();
            if (this._prevSettings.layout) {
                this.children.each((child) => {
                    child.removePrivate("x");
                    child.removePrivate("y");
                });
            }
        }
        if (this.isDirty("paddingTop") || this.isDirty("paddingBottom") || this.isDirty("paddingLeft") || this.isDirty("paddingRight")) {
            this.children.each((child) => {
                child.markDirtyPosition();
            });
        }
        if (this.isDirty("maskContent")) {
            const childrenDisplay = this._childrenDisplay;
            let contentMask = this._contentMask;
            if (this.get("maskContent")) {
                if (!contentMask) {
                    contentMask = _Rectangle__WEBPACK_IMPORTED_MODULE_3__["Rectangle"].new(this._root, {
                        x: -.5,
                        y: -.5,
                        width: this.width() + 1,
                        height: this.height() + 1
                    });
                    this._contentMask = contentMask;
                    childrenDisplay.addChildAt(contentMask._display, 0);
                    childrenDisplay.mask = contentMask._display;
                }
            }
            else {
                if (contentMask) {
                    childrenDisplay.removeChild(contentMask._display);
                    childrenDisplay.mask = null;
                    contentMask.dispose();
                    this._contentMask = undefined;
                }
            }
        }
    }
    _updateSize() {
        super._updateSize();
        _util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._percentageSizeChildren, (child) => {
            child._updateSize();
        });
        _util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._percentagePositionChildren, (child) => {
            child.markDirtyPosition();
            child._updateSize();
        });
        this.updateBackground();
    }
    updateBackground() {
        const background = this.get("background");
        let bounds = this._localBounds;
        if (bounds && !this.isHidden()) {
            let x = bounds.left;
            let y = bounds.top;
            let w = bounds.right - x;
            let h = bounds.bottom - y;
            let maxWidth = this.get("maxWidth");
            let maxHeight = this.get("maxHeight");
            if (maxHeight) {
                if (h > maxHeight) {
                    h = maxHeight;
                }
            }
            if (maxWidth) {
                if (w > maxWidth) {
                    w = maxWidth;
                }
            }
            let width = this.width();
            let height = this.height();
            if (background) {
                background.setAll({ width: w, height: h, x: x, y: y });
                if (this._display.interactive) {
                    background._display.interactive = true;
                }
            }
            const contentMask = this._contentMask;
            if (contentMask) {
                contentMask.setAll({ width: width + 1, height: height + 1 });
            }
            const verticalScrollbar = this.get("verticalScrollbar");
            if (verticalScrollbar) {
                verticalScrollbar.set("height", height);
                verticalScrollbar.set("x", width - verticalScrollbar.width() - verticalScrollbar.get("marginRight", 0));
                verticalScrollbar.set("end", verticalScrollbar.get("start", 0) + height / this._contentHeight);
                const bg = verticalScrollbar.get("background");
                if (bg) {
                    bg.setAll({ width: verticalScrollbar.width(), height: height });
                }
                let visible = true;
                if (this._contentHeight <= height) {
                    visible = false;
                }
                verticalScrollbar.setPrivate("visible", visible);
            }
        }
    }
    _applyThemes() {
        if (super._applyThemes()) {
            this.eachChildren((child) => {
                child._applyThemes();
            });
            return true;
        }
        else {
            return false;
        }
    }
    _applyState(name) {
        super._applyState(name);
        if (this.get("setStateOnChildren")) {
            this.eachChildren((child) => {
                child.states.apply(name);
            });
        }
    }
    _applyStateAnimated(name, duration) {
        super._applyStateAnimated(name, duration);
        if (this.get("setStateOnChildren")) {
            this.eachChildren((child) => {
                child.states.applyAnimate(name, duration);
            });
        }
    }
    /**
     * Returns container's inner width (width without padding) in pixels.
     *
     * @return Inner width (px)
     */
    innerWidth() {
        return this.width() - this.get("paddingRight", 0) - this.get("paddingLeft", 0);
    }
    /**
     * Returns container's inner height (height without padding) in pixels.
     *
     * @return Inner height (px)
     */
    innerHeight() {
        return this.height() - this.get("paddingTop", 0) - this.get("paddingBottom", 0);
    }
    _getBounds() {
        let width = this.get("width");
        let height = this.get("height");
        let pWidth = this.getPrivate("width");
        let pHeight = this.getPrivate("height");
        let bounds = {
            left: 0,
            top: 0,
            right: this.width(),
            bottom: this.height(),
        };
        let layout = this.get("layout");
        let horizontal = false;
        let vertical = false;
        if (layout instanceof _HorizontalLayout__WEBPACK_IMPORTED_MODULE_4__["HorizontalLayout"] || layout instanceof _GridLayout__WEBPACK_IMPORTED_MODULE_6__["GridLayout"]) {
            horizontal = true;
        }
        if (layout instanceof _VerticalLayout__WEBPACK_IMPORTED_MODULE_5__["VerticalLayout"]) {
            vertical = true;
        }
        if ((width != null || pWidth != null) && (height != null || pHeight != null) && !this.get("verticalScrollbar")) {
            // void
        }
        else {
            let m = Number.MAX_VALUE;
            let l = m;
            let r = -m;
            let t = m;
            let b = -m;
            const paddingLeft = this.get("paddingLeft", 0);
            const paddingTop = this.get("paddingTop", 0);
            const paddingRight = this.get("paddingRight", 0);
            const paddingBottom = this.get("paddingBottom", 0);
            this.children.each((child) => {
                if (child.get("position") != "absolute" && child.get("isMeasured")) {
                    let childBounds = child.adjustedLocalBounds();
                    let childX = child.x();
                    let childY = child.y();
                    let cl = childX + childBounds.left;
                    let cr = childX + childBounds.right;
                    let ct = childY + childBounds.top;
                    let cb = childY + childBounds.bottom;
                    if (horizontal) {
                        cl -= child.get("marginLeft", 0);
                        cr += child.get("marginRight", 0);
                    }
                    if (vertical) {
                        ct -= child.get("marginTop", 0);
                        cb += child.get("marginBottom", 0);
                    }
                    if (cl < l) {
                        l = cl;
                    }
                    if (cr > r) {
                        r = cr;
                    }
                    if (ct < t) {
                        t = ct;
                    }
                    if (cb > b) {
                        b = cb;
                    }
                }
            });
            if (l == m) {
                l = 0;
            }
            if (r == -m) {
                r = 0;
            }
            if (t == m) {
                t = 0;
            }
            if (b == -m) {
                b = 0;
            }
            bounds.left = l - paddingLeft;
            bounds.top = t - paddingTop;
            bounds.right = r + paddingRight;
            bounds.bottom = b + paddingBottom;
        }
        this._contentWidth = bounds.right - bounds.left;
        this._contentHeight = bounds.bottom - bounds.top;
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](width)) {
            bounds.left = 0;
            bounds.right = width;
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](pWidth)) {
            bounds.left = 0;
            bounds.right = pWidth;
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](height)) {
            bounds.top = 0;
            bounds.bottom = height;
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](pHeight)) {
            bounds.top = 0;
            bounds.bottom = pHeight;
        }
        this._localBounds = bounds;
    }
    _updateBounds() {
        const layout = this.get("layout");
        if (layout) {
            layout.updateContainer(this);
        }
        super._updateBounds();
        this.updateBackground();
    }
    /**
     * @ignore
     */
    markDirty() {
        super.markDirty();
        this._root._addDirtyParent(this);
    }
    _prepareChildren() {
        const innerWidth = this.innerWidth();
        const innerHeight = this.innerHeight();
        if (innerWidth != this._prevWidth || innerHeight != this._prevHeight) {
            let layout = this.get("layout");
            let horizontal = false;
            let vertical = false;
            if (layout) {
                if (layout instanceof _HorizontalLayout__WEBPACK_IMPORTED_MODULE_4__["HorizontalLayout"] || layout instanceof _GridLayout__WEBPACK_IMPORTED_MODULE_6__["GridLayout"]) {
                    horizontal = true;
                }
                if (layout instanceof _VerticalLayout__WEBPACK_IMPORTED_MODULE_5__["VerticalLayout"]) {
                    vertical = true;
                }
            }
            _util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._percentageSizeChildren, (child) => {
                if (!horizontal) {
                    let width = child.get("width");
                    if (width instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_1__["Percent"]) {
                        child.setPrivate("width", width.value * innerWidth);
                    }
                }
                if (!vertical) {
                    let height = child.get("height");
                    if (height instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_1__["Percent"]) {
                        child.setPrivate("height", height.value * innerHeight);
                    }
                }
            });
            _util_Array__WEBPACK_IMPORTED_MODULE_8__["each"](this._percentagePositionChildren, (child) => {
                child.markDirtyPosition();
                child.markDirtyBounds();
            });
            this._prevWidth = innerWidth;
            this._prevHeight = innerHeight;
            this._sizeDirty = true;
            this.updateBackground();
        }
        this._handleStates();
    }
    _updateChildren() {
        if (this.isDirty("html")) {
            const html = this.get("html");
            if (html && html !== "") {
                this._root._setHTMLContent(this, Object(_util_PopulateString__WEBPACK_IMPORTED_MODULE_7__["populateString"])(this, this.get("html", "")));
            }
            else {
                this._root._removeHTMLContent(this);
            }
            this._root._positionHTMLElement(this);
        }
        if (this.isDirty("verticalScrollbar")) {
            const verticalScrollbar = this.get("verticalScrollbar");
            if (verticalScrollbar) {
                verticalScrollbar._setParent(this);
                verticalScrollbar.children.removeValue(verticalScrollbar.startGrip);
                verticalScrollbar.children.removeValue(verticalScrollbar.endGrip);
                this.set("maskContent", true);
                this.set("paddingRight", verticalScrollbar.width() + verticalScrollbar.get("marginRight", 0) + verticalScrollbar.get("marginLeft", 0));
                let background = this.get("background");
                if (!background) {
                    background = this.set("background", _Rectangle__WEBPACK_IMPORTED_MODULE_3__["Rectangle"].new(this._root, {
                        themeTags: ["background"],
                        fillOpacity: 0,
                        fill: this._root.interfaceColors.get("alternativeBackground")
                    }));
                }
                this._vsbd0 = this.events.on("wheel", (event) => {
                    const wheelEvent = event.originalEvent;
                    // Ignore wheel event if it is happening on a non-chart element, e.g. if
                    // some page element is over the chart.
                    if (_util_Utils__WEBPACK_IMPORTED_MODULE_10__["isLocalEvent"](wheelEvent, this)) {
                        wheelEvent.preventDefault();
                    }
                    else {
                        return;
                    }
                    let shiftY = wheelEvent.deltaY / 5000;
                    const start = verticalScrollbar.get("start", 0);
                    const end = verticalScrollbar.get("end", 1);
                    if (start + shiftY <= 0) {
                        shiftY = -start;
                    }
                    if (end + shiftY >= 1) {
                        shiftY = 1 - end;
                    }
                    if (start + shiftY >= 0 && end + shiftY <= 1) {
                        verticalScrollbar.set("start", start + shiftY);
                        verticalScrollbar.set("end", end + shiftY);
                    }
                });
                this._disposers.push(this._vsbd0);
                this._vsbd1 = verticalScrollbar.events.on("rangechanged", () => {
                    let h = this._contentHeight;
                    const childrenDisplay = this._childrenDisplay;
                    const contentMask = this._contentMask;
                    childrenDisplay.y = -verticalScrollbar.get("start") * h;
                    childrenDisplay.markDirtyLayer();
                    if (contentMask) {
                        contentMask._display.y = -childrenDisplay.y;
                        childrenDisplay.mask = contentMask._display;
                    }
                });
                this._disposers.push(this._vsbd1);
                this._display.addChild(verticalScrollbar._display);
            }
            else {
                const previous = this._prevSettings.verticalScrollbar;
                if (previous) {
                    this._display.removeChild(previous._display);
                    if (this._vsbd0) {
                        this._vsbd0.dispose();
                    }
                    if (this._vsbd1) {
                        this._vsbd1.dispose();
                    }
                    const childrenDisplay = this._childrenDisplay;
                    childrenDisplay.y = 0;
                    this.setPrivate("height", undefined);
                    this.set("maskContent", false);
                    this.set("paddingRight", undefined);
                }
            }
        }
        if (this.isDirty("background")) {
            // TODO maybe this should dispose ?
            const previous = this._prevSettings["background"];
            if (previous) {
                this._display.removeChild(previous._display);
            }
            const background = this.get("background");
            if (background instanceof _Sprite__WEBPACK_IMPORTED_MODULE_2__["Sprite"]) {
                background.set("isMeasured", false);
                background._setParent(this);
                this._display.addChildAt(background._display, 0);
            }
        }
        if (this.isDirty("mask")) {
            const mask = this.get("mask");
            const previous = this._prevSettings["mask"];
            if (previous) {
                this._display.removeChild(previous._display);
                if (previous != mask) {
                    previous.dispose();
                }
            }
            if (mask) {
                var parent = mask.parent;
                if (parent) {
                    parent.children.removeValue(mask);
                }
                mask._setParent(this);
                this._display.addChildAt(mask._display, 0);
                this._childrenDisplay.mask = mask._display;
            }
        }
    }
    _processTemplateField() {
        super._processTemplateField();
        this.children.each((child) => {
            child._processTemplateField();
        });
    }
    /**
     * @ignore
     */
    walkChildren(f) {
        this.children.each((child) => {
            if (child instanceof Container) {
                child.walkChildren(f);
            }
            f(child);
        });
    }
    eachChildren(f) {
        const background = this.get("background");
        if (background) {
            f(background);
        }
        const verticalScrollbar = this.get("verticalScrollbar");
        if (verticalScrollbar) {
            f(verticalScrollbar);
        }
        const mask = this.get("mask");
        if (mask) {
            f(mask);
        }
        this.children.values.forEach((child) => {
            f(child);
        });
    }
    allChildren() {
        const output = [];
        this.eachChildren((x) => {
            output.push(x);
        });
        return output;
    }
    _setDataItem(dataItem) {
        const updated = (dataItem !== this._dataItem);
        super._setDataItem(dataItem);
        const html = this.get("html", "");
        if (html && html !== "" && updated) {
            this._root._setHTMLContent(this, Object(_util_PopulateString__WEBPACK_IMPORTED_MODULE_7__["populateString"])(this, html));
        }
    }
}
Object.defineProperty(Container, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Container"
});
Object.defineProperty(Container, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Sprite__WEBPACK_IMPORTED_MODULE_2__["Sprite"].classNames.concat([Container.className])
});
//# sourceMappingURL=Container.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Ellipse.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Ellipse.js ***!
  \***************************************************************************/
/*! exports provided: Ellipse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ellipse", function() { return Ellipse; });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");

/**
 * Draws a Ellipse.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Ellipse extends _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("radiusX") || this.isDirty("radiusY") || this.isDirty("rotation")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            this._display.drawEllipse(0, 0, Math.abs(this.get("radiusX")), Math.abs(this.get("radiusY")));
        }
    }
}
Object.defineProperty(Ellipse, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Ellipse"
});
Object.defineProperty(Ellipse, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"].classNames.concat([Ellipse.className])
});
//# sourceMappingURL=Ellipse.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js ***!
  \****************************************************************************/
/*! exports provided: visualSettings, Graphics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visualSettings", function() { return visualSettings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Graphics", function() { return Graphics; });
/* harmony import */ var _render_patterns_PicturePattern__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/patterns/PicturePattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PicturePattern.js");
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sprite */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js");
/* harmony import */ var _backend_Renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./backend/Renderer */ "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");





const visualSettings = ["fill", "fillOpacity", "stroke", "strokeWidth", "strokeOpacity", "fillPattern", "strokePattern", "fillGradient", "strokeGradient", "strokeDasharray", "strokeDashoffset"];
/**
 * Base class used for drawing shapes.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Graphics extends _Sprite__WEBPACK_IMPORTED_MODULE_1__["Sprite"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeGraphics()
        });
        Object.defineProperty(this, "_clear", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("draw") || this.isDirty("svgPath")) {
            this.markDirtyBounds();
        }
        if (this.isDirty("fill") || this.isDirty("stroke") || this.isDirty("visible") || this.isDirty("forceHidden") || this.isDirty("scale") || this.isDirty("fillGradient") || this.isDirty("strokeGradient") || this.isDirty("fillPattern") || this.isDirty("strokePattern") || this.isDirty("fillOpacity") || this.isDirty("strokeOpacity") || this.isDirty("strokeWidth") || this.isDirty("draw") || this.isDirty("blendMode") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("svgPath") || this.isDirty("lineJoin") || this.isDirty("shadowColor") || this.isDirty("shadowBlur") || this.isDirty("shadowOffsetX") || this.isDirty("shadowOffsetY")) {
            this._clear = true;
        }
        this._display.crisp = this.get("crisp", false);
        if (this.isDirty("fillGradient")) {
            const gradient = this.get("fillGradient");
            if (gradient) {
                this._display.isMeasured = true;
                const gradientTarget = gradient.get("target");
                if (gradientTarget) {
                    this._disposers.push(gradientTarget.events.on("boundschanged", () => {
                        this._markDirtyKey("fill");
                    }));
                    this._disposers.push(gradientTarget.events.on("positionchanged", () => {
                        this._markDirtyKey("fill");
                    }));
                }
            }
        }
        if (this.isDirty("strokeGradient")) {
            const gradient = this.get("strokeGradient");
            if (gradient) {
                this._display.isMeasured = true;
                const gradientTarget = gradient.get("target");
                if (gradientTarget) {
                    this._disposers.push(gradientTarget.events.on("boundschanged", () => {
                        this._markDirtyKey("stroke");
                    }));
                    this._disposers.push(gradientTarget.events.on("positionchanged", () => {
                        this._markDirtyKey("stroke");
                    }));
                }
            }
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            this.markDirtyBounds();
            this.markDirtyLayer();
            this._display.clear();
            let strokeDasharray = this.get("strokeDasharray");
            if (_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](strokeDasharray)) {
                if (strokeDasharray < 0.5) {
                    strokeDasharray = [0];
                }
                else {
                    strokeDasharray = [strokeDasharray];
                }
            }
            this._display.setLineDash(strokeDasharray);
            const strokeDashoffset = this.get("strokeDashoffset");
            if (strokeDashoffset) {
                this._display.setLineDashOffset(strokeDashoffset);
            }
            const blendMode = this.get("blendMode", _backend_Renderer__WEBPACK_IMPORTED_MODULE_2__["BlendMode"].NORMAL);
            this._display.blendMode = blendMode;
            const draw = this.get("draw");
            if (draw) {
                draw(this._display, this);
            }
            const svgPath = this.get("svgPath");
            if (svgPath != null) {
                this._display.svgPath(svgPath);
            }
        }
    }
    _afterChanged() {
        super._afterChanged();
        if (this._clear) {
            const fill = this.get("fill");
            const fillGradient = this.get("fillGradient");
            const fillPattern = this.get("fillPattern");
            const fillOpacity = this.get("fillOpacity");
            const stroke = this.get("stroke");
            const strokeGradient = this.get("strokeGradient");
            const strokePattern = this.get("strokePattern");
            const shadowColor = this.get("shadowColor");
            const shadowBlur = this.get("shadowBlur");
            const shadowOffsetX = this.get("shadowOffsetX");
            const shadowOffsetY = this.get("shadowOffsetY");
            const shadowOpacity = this.get("shadowOpacity");
            //const bounds = this._display.getLocalBounds();
            if (shadowColor && (shadowBlur || shadowOffsetX || shadowOffsetY)) {
                this._display.shadow(shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY, shadowOpacity);
            }
            if (fillPattern) {
                let changed = false;
                if (fill && (!fillPattern.get("fill") || fillPattern.get("fillInherited"))) {
                    fillPattern.set("fill", fill);
                    fillPattern.set("fillInherited", true);
                    changed = true;
                }
                if (stroke && (!fillPattern.get("color") || fillPattern.get("colorInherited"))) {
                    fillPattern.set("color", stroke);
                    fillPattern.set("colorInherited", true);
                    changed = true;
                }
                if (changed) {
                    // @todo: is this OK?
                    fillPattern._changed();
                }
                const pattern = fillPattern.pattern;
                if (pattern) {
                    this._display.beginFill(pattern, fillOpacity);
                    this._display.endFill();
                    if (fillPattern instanceof _render_patterns_PicturePattern__WEBPACK_IMPORTED_MODULE_0__["PicturePattern"]) {
                        fillPattern.events.once("loaded", () => {
                            this._clear = true;
                            this.markDirty();
                        });
                    }
                }
            }
            else if (fillGradient) {
                if (fill) {
                    const stops = fillGradient.get("stops", []);
                    if (stops.length) {
                        _util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](stops, (stop) => {
                            if ((!stop.color || stop.colorInherited) && fill) {
                                stop.color = fill;
                                stop.colorInherited = true;
                            }
                            if (stop.opacity == null || stop.opacityInherited) {
                                stop.opacity = fillOpacity;
                                stop.opacityInherited = true;
                            }
                        });
                    }
                }
                const gradient = fillGradient.getFill(this);
                if (gradient) {
                    this._display.beginFill(gradient, fillOpacity);
                    this._display.endFill();
                }
            }
            else if (fill) {
                this._display.beginFill(fill, fillOpacity);
                this._display.endFill();
            }
            if (stroke || strokeGradient || strokePattern) {
                const strokeOpacity = this.get("strokeOpacity");
                let strokeWidth = this.get("strokeWidth", 1);
                if (this.get("nonScalingStroke")) {
                    strokeWidth = strokeWidth / this.get("scale", 1);
                }
                if (this.get("crisp")) {
                    strokeWidth /= this._root._renderer.resolution;
                }
                const lineJoin = this.get("lineJoin");
                if (strokePattern) {
                    let changed = false;
                    if (stroke && (!strokePattern.get("color") || strokePattern.get("colorInherited"))) {
                        strokePattern.set("color", stroke);
                        strokePattern.set("colorInherited", true);
                        changed = true;
                    }
                    if (changed) {
                        // @todo: is this OK?
                        strokePattern._changed();
                    }
                    const pattern = strokePattern.pattern;
                    if (pattern) {
                        this._display.lineStyle(strokeWidth, pattern, strokeOpacity, lineJoin);
                        this._display.endStroke();
                        if (strokePattern instanceof _render_patterns_PicturePattern__WEBPACK_IMPORTED_MODULE_0__["PicturePattern"]) {
                            strokePattern.events.once("loaded", () => {
                                this._clear = true;
                                this.markDirty();
                            });
                        }
                    }
                }
                else if (strokeGradient) {
                    const stops = strokeGradient.get("stops", []);
                    if (stops.length) {
                        _util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](stops, (stop) => {
                            if ((!stop.color || stop.colorInherited) && stroke) {
                                stop.color = stroke;
                                stop.colorInherited = true;
                            }
                            if (stop.opacity == null || stop.opacityInherited) {
                                stop.opacity = strokeOpacity;
                                stop.opacityInherited = true;
                            }
                        });
                    }
                    const gradient = strokeGradient.getFill(this);
                    if (gradient) {
                        this._display.lineStyle(strokeWidth, gradient, strokeOpacity, lineJoin);
                        this._display.endStroke();
                    }
                }
                else if (stroke) {
                    this._display.lineStyle(strokeWidth, stroke, strokeOpacity, lineJoin);
                    this._display.endStroke();
                }
            }
            if (this.getPrivate("showingTooltip")) {
                this.showTooltip();
            }
        }
        this._clear = false;
    }
}
Object.defineProperty(Graphics, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Graphics"
});
Object.defineProperty(Graphics, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Sprite__WEBPACK_IMPORTED_MODULE_1__["Sprite"].classNames.concat([Graphics.className])
});
//# sourceMappingURL=Graphics.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js ***!
  \******************************************************************************/
/*! exports provided: GridLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridLayout", function() { return GridLayout; });
/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");



/**
 * A grid children layout for [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
 */
class GridLayout extends _Layout__WEBPACK_IMPORTED_MODULE_0__["Layout"] {
    _afterNew() {
        this._setRawDefault("maxColumns", Number.MAX_VALUE);
        super._afterNew();
    }
    /**
     * @ignore
     */
    updateContainer(container) {
        let paddingLeft = container.get("paddingLeft", 0);
        let paddingRight = container.get("paddingRight", 0);
        let paddingTop = container.get("paddingTop", 0);
        let availableWidth = container.maxWidth() - paddingLeft - paddingRight;
        let minCellWidth = availableWidth;
        let maxCellWidth = 1;
        Object(_Layout__WEBPACK_IMPORTED_MODULE_0__["eachChildren"])(container, (child) => {
            if (child.get("visible") && child.getPrivate("visible") && !child.get("forceHidden")) {
                if (child.get("position") != "absolute") {
                    let childWidth = child.width();
                    if (childWidth < minCellWidth) {
                        minCellWidth = childWidth;
                    }
                    if (childWidth > maxCellWidth) {
                        maxCellWidth = childWidth;
                    }
                }
            }
        });
        minCellWidth = _util_Math__WEBPACK_IMPORTED_MODULE_2__["fitToRange"](minCellWidth, 1, availableWidth);
        maxCellWidth = _util_Math__WEBPACK_IMPORTED_MODULE_2__["fitToRange"](maxCellWidth, 1, availableWidth);
        let columnCount = 1;
        if (this.get("fixedWidthGrid")) {
            columnCount = availableWidth / maxCellWidth;
        }
        else {
            columnCount = availableWidth / minCellWidth;
        }
        columnCount = Math.max(1, Math.floor(columnCount));
        columnCount = Math.min(this.get("maxColumns", Number.MAX_VALUE), columnCount);
        let columnWidths = this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);
        let prevY = paddingTop;
        let column = 0;
        let maxColumnHeight = 0;
        columnCount = columnWidths.length;
        let prevX = paddingLeft;
        Object(_Layout__WEBPACK_IMPORTED_MODULE_0__["eachChildren"])(container, (child) => {
            if (child.get("position") == "relative" && child.isVisible()) {
                const marginTop = child.get("marginTop", 0);
                const marginBottom = child.get("marginBottom", 0);
                let bounds = child.adjustedLocalBounds();
                let marginLeft = child.get("marginLeft", 0);
                let marginRight = child.get("marginRight", 0);
                let x = prevX + marginLeft - bounds.left;
                let y = prevY + marginTop - bounds.top;
                child.setPrivate("x", x);
                child.setPrivate("y", y);
                prevX += columnWidths[column] + marginRight;
                maxColumnHeight = Math.max(maxColumnHeight, child.height() + marginTop + marginBottom);
                column++;
                if (column >= columnCount) {
                    column = 0;
                    prevX = paddingLeft;
                    prevY += maxColumnHeight;
                }
            }
        });
    }
    /**
     * @ignore
     */
    getColumnWidths(container, columnCount, maxCellWidth, availableWidth) {
        let totalWidth = 0;
        let columnWidths = [];
        let column = 0;
        Object(_Layout__WEBPACK_IMPORTED_MODULE_0__["eachChildren"])(container, (child) => {
            let bounds = child.adjustedLocalBounds();
            if (child.get("position") != "absolute" && child.isVisible()) {
                if (this.get("fixedWidthGrid")) {
                    columnWidths[column] = maxCellWidth;
                }
                else {
                    columnWidths[column] = Math.max(columnWidths[column] | 0, bounds.right - bounds.left + child.get("marginLeft", 0) + child.get("marginRight", 0));
                }
                if (column < container.children.length - 1) {
                    column++;
                    if (column == columnCount) {
                        column = 0;
                    }
                }
            }
        });
        _util_Array__WEBPACK_IMPORTED_MODULE_1__["each"](columnWidths, (w) => {
            totalWidth += w;
        });
        if (totalWidth > availableWidth) {
            if (columnCount > 2) {
                columnCount -= 1;
                return this.getColumnWidths(container, columnCount, maxCellWidth, availableWidth);
            }
            else {
                return [availableWidth];
            }
        }
        return columnWidths;
    }
}
Object.defineProperty(GridLayout, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "GridLayout"
});
Object.defineProperty(GridLayout, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Layout__WEBPACK_IMPORTED_MODULE_0__["Layout"].classNames.concat([GridLayout.className])
});
//# sourceMappingURL=GridLayout.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/HeatLegend.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/HeatLegend.js ***!
  \******************************************************************************/
/*! exports provided: HeatLegend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HeatLegend", function() { return HeatLegend; });
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_render_Label__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/render/Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_render_Tooltip__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/render/Tooltip */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js");
/* harmony import */ var _core_render_gradients_LinearGradient__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/render/gradients/LinearGradient */ "./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/LinearGradient.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");











/**
 * Heat legend.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/legend/heat-legend/} for more info
 */
class HeatLegend extends _Container__WEBPACK_IMPORTED_MODULE_0__["Container"] {
    constructor() {
        super(...arguments);
        /**
         * A [[Container]] that all labels are placed in.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "labelContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].new(this._root, {}))
        });
        /**
         * A [[Container]] that all markers are placed in.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "markerContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].new(this._root, {}))
        });
        /**
         * A start [[Label]].
         *
         * @default Label.new()
         */
        Object.defineProperty(this, "startLabel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.labelContainer.children.push(_core_render_Label__WEBPACK_IMPORTED_MODULE_1__["Label"].new(this._root, { themeTags: ["start"] }))
        });
        /**
         * An end [[Label]].
         *
         * @default Label.new()
         */
        Object.defineProperty(this, "endLabel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.labelContainer.children.push(_core_render_Label__WEBPACK_IMPORTED_MODULE_1__["Label"].new(this._root, { themeTags: ["end"] }))
        });
        /**
         * List of rectangle elements used for default legend markers.
         *
         * @default new ListTemplate<RoundedRectangle>
         */
        Object.defineProperty(this, "markers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_5__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_4__["Template"].new({}), () => _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__["RoundedRectangle"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_9__["mergeTags"](this.markers.template.get("themeTags", []), [this.get("orientation"), "heatlegend", "marker"])
            }, [this.markers.template]))
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_9__["mergeTags"](this._settings.themeTags, ["heatlegend", this._settings.orientation]);
        super._afterNew();
        this.set("tooltip", _core_render_Tooltip__WEBPACK_IMPORTED_MODULE_7__["Tooltip"].new(this._root, {
            themeTags: ["heatlegend"]
        }));
    }
    /**
     * @ignore
     */
    makeMarker() {
        const marker = this.markers.make();
        marker.states.create("disabled", {});
        return marker;
    }
    /**
     * Moves and shows tooltip at specific value.
     *
     * Can also specify optional text to show in tooltip, as well as the color.
     *
     * @param  value  Value
     * @param  text   Text
     * @param  color  Color
     */
    showValue(value, text, color) {
        const tooltip = this.getTooltip();
        if (tooltip && _core_util_Type__WEBPACK_IMPORTED_MODULE_10__["isNumber"](value)) {
            const startValue = this.get("startValue", 0);
            const endValue = this.get("endValue", 1);
            const c = (value - startValue) / (endValue - startValue);
            const startColor = this.get("startColor");
            const endColor = this.get("endColor");
            if (!text) {
                text = this.getNumberFormatter().format(value);
            }
            if (!color) {
                color = _core_util_Color__WEBPACK_IMPORTED_MODULE_6__["Color"].interpolate(c, startColor, endColor);
            }
            tooltip.label.set("text", text);
            let p;
            if (this.get("orientation") == "vertical") {
                p = this.markerContainer.toGlobal({ x: 0, y: this.innerHeight() * (1 - c) });
            }
            else {
                p = this.markerContainer.toGlobal({ x: this.innerWidth() * c, y: 0 });
            }
            let background = tooltip.get("background");
            if (background) {
                background.set("fill", _core_util_Color__WEBPACK_IMPORTED_MODULE_6__["Color"].interpolate(c, startColor, endColor));
            }
            tooltip.set("pointTo", p);
            tooltip.show();
        }
    }
    _prepareChildren() {
        super._prepareChildren();
        const labelContainer = this.labelContainer;
        const orientation = this.get("orientation");
        const startLabel = this.startLabel;
        const endLabel = this.endLabel;
        const tooltip = this.getTooltip();
        if (this.isDirty("orientation")) {
            if (orientation == "vertical") {
                this.markerContainer.setAll({ layout: this._root.verticalLayout, height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"] });
                this.set("layout", this._root.horizontalLayout);
                startLabel.setAll({ y: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"], x: undefined, centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"], centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"] });
                endLabel.setAll({ y: 0, x: undefined, centerY: 0, centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"] });
                labelContainer.setAll({ height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"], width: undefined });
                if (tooltip) {
                    tooltip.set("pointerOrientation", "horizontal");
                }
            }
            else {
                this.markerContainer.setAll({ layout: this._root.horizontalLayout, width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"] });
                this.set("layout", this._root.verticalLayout);
                startLabel.setAll({ x: 0, y: undefined, centerX: 0, centerY: 0 });
                endLabel.setAll({ x: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"], y: undefined, centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"], centerY: 0 });
                labelContainer.setAll({ width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_2__["p100"], height: undefined });
                if (tooltip) {
                    tooltip.set("pointerOrientation", "vertical");
                }
            }
        }
        if (this.isDirty("stepCount")) {
            const stepCount = this.get("stepCount", 1);
            const startColor = this.get("startColor");
            const endColor = this.get("endColor");
            this.markerContainer.children.clear();
            if (stepCount > 1) {
                for (let i = 0; i < stepCount; i++) {
                    const marker = this.makeMarker();
                    if (orientation == "vertical") {
                        this.markerContainer.children.moveValue(marker, 0);
                    }
                    else {
                        this.markerContainer.children.push(marker);
                    }
                    if (startColor && endColor) {
                        marker.set("fill", _core_util_Color__WEBPACK_IMPORTED_MODULE_6__["Color"].interpolate(i / stepCount, startColor, endColor));
                    }
                }
            }
            else if (stepCount == 1) {
                const marker = this.makeMarker();
                this.markerContainer.children.push(marker);
                const gradient = _core_render_gradients_LinearGradient__WEBPACK_IMPORTED_MODULE_8__["LinearGradient"].new(this._root, { stops: [{ color: startColor }, { color: endColor }] });
                if (orientation == "vertical") {
                    gradient.set("rotation", 90);
                    let stops = gradient.get("stops");
                    if (stops) {
                        stops.reverse();
                    }
                }
                else {
                    gradient.set("rotation", 0);
                }
                if (startColor && endColor) {
                    marker.set("fillGradient", gradient);
                }
            }
        }
        if (this.isDirty("startText") || this.isDirty("startValue")) {
            startLabel.set("text", this.get("startText", this.getNumberFormatter().format(this.get("startValue", 0))));
        }
        if (this.isDirty("endText") || this.isDirty("endValue")) {
            endLabel.set("text", this.get("endText", this.getNumberFormatter().format(this.get("endValue", 1))));
        }
    }
}
Object.defineProperty(HeatLegend, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "HeatLegend"
});
Object.defineProperty(HeatLegend, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_0__["Container"].classNames.concat([HeatLegend.className])
});
//# sourceMappingURL=HeatLegend.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js ***!
  \************************************************************************************/
/*! exports provided: HorizontalLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HorizontalLayout", function() { return HorizontalLayout; });
/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");



/**
 * A horizontal children layout for [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
 */
class HorizontalLayout extends _Layout__WEBPACK_IMPORTED_MODULE_0__["Layout"] {
    /**
     * @ignore
     */
    updateContainer(container) {
        let paddingLeft = container.get("paddingLeft", 0);
        let availableWidth = container.innerWidth();
        let totalPercent = 0;
        Object(_Layout__WEBPACK_IMPORTED_MODULE_0__["eachChildren"])(container, (child) => {
            if (child.isVisible()) {
                if (child.get("position") == "relative") {
                    let childWidth = child.get("width");
                    if (childWidth instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_2__["Percent"]) {
                        totalPercent += childWidth.value;
                        let w = availableWidth * childWidth.value;
                        let minWidth = child.get("minWidth", child.getPrivate("minWidth", -Infinity));
                        if (minWidth > w) {
                            availableWidth -= minWidth;
                            totalPercent -= childWidth.value;
                        }
                        let maxWidth = child.get("maxWidth", child.getPrivate("maxWidth", Infinity));
                        if (w > maxWidth) {
                            availableWidth -= maxWidth;
                            totalPercent -= childWidth.value;
                        }
                    }
                    else {
                        if (!_util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](childWidth)) {
                            childWidth = child.width();
                        }
                        availableWidth -= childWidth + child.get("marginLeft", 0) + child.get("marginRight", 0);
                    }
                }
            }
        });
        if (availableWidth <= 0 || availableWidth == Infinity) {
            availableWidth = .1;
        }
        //if (availableWidth > 0) {
        Object(_Layout__WEBPACK_IMPORTED_MODULE_0__["eachChildren"])(container, (child) => {
            if (child.isVisible()) {
                if (child.get("position") == "relative") {
                    let childWidth = child.get("width");
                    if (childWidth instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_2__["Percent"]) {
                        let privateWidth = availableWidth * childWidth.value / totalPercent - child.get("marginLeft", 0) - child.get("marginRight", 0);
                        let minWidth = child.get("minWidth", child.getPrivate("minWidth", -Infinity));
                        let maxWidth = child.get("maxWidth", child.getPrivate("maxWidth", Infinity));
                        privateWidth = Math.min(Math.max(minWidth, privateWidth), maxWidth);
                        child.setPrivate("width", privateWidth);
                    }
                }
            }
        });
        //}
        let prevX = paddingLeft;
        Object(_Layout__WEBPACK_IMPORTED_MODULE_0__["eachChildren"])(container, (child) => {
            if (child.get("position") == "relative") {
                if (child.isVisible()) {
                    let bounds = child.adjustedLocalBounds();
                    let marginLeft = child.get("marginLeft", 0);
                    let marginRight = child.get("marginRight", 0);
                    let maxWidth = child.get("maxWidth");
                    let left = bounds.left;
                    let right = bounds.right;
                    if (maxWidth) {
                        if (right - left > maxWidth) {
                            right = left + maxWidth;
                        }
                    }
                    let x = prevX + marginLeft - left;
                    child.setPrivate("x", x);
                    prevX = x + right + marginRight;
                }
                else {
                    child.setPrivate("x", undefined);
                }
            }
        });
    }
}
Object.defineProperty(HorizontalLayout, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "HorizontalLayout"
});
Object.defineProperty(HorizontalLayout, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Layout__WEBPACK_IMPORTED_MODULE_0__["Layout"].classNames.concat([HorizontalLayout.className])
});
//# sourceMappingURL=HorizontalLayout.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js ***!
  \*************************************************************************/
/*! exports provided: Label */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Label", function() { return Label; });
/* harmony import */ var _render_Text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/Text */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");





/**
 * Creates a label with support for in-line styling and data bindings.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/labels/} for more info
 */
class Label extends _Container__WEBPACK_IMPORTED_MODULE_2__["Container"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_text", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_textKeys", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "text",
                "fill",
                "fillOpacity",
                "textAlign",
                "fontFamily",
                "fontSize",
                "fontStyle",
                "fontWeight",
                "fontStyle",
                "fontVariant",
                "textDecoration",
                "shadowColor",
                "shadowBlur",
                "shadowOffsetX",
                "shadowOffsetY",
                "shadowOpacity",
                // "leading",
                // "letterSpacing",
                "lineHeight",
                "baselineRatio",
                //"padding",
                // "stroke",
                // "strokeThickness",
                // "trim",
                // "wordWrap",
                "direction",
                "textBaseline",
                "oversizedBehavior",
                "breakWords",
                "ellipsis",
                "minScale",
                "populateText",
                "role",
                "ignoreFormatting"
            ]
        });
    }
    /**
     * @ignore Text is not to be used directly
     */
    get text() {
        return this._text;
    }
    _afterNew() {
        super._afterNew();
        this._makeText();
        _core_util_Array__WEBPACK_IMPORTED_MODULE_3__["each"](this._textKeys, (property) => {
            const propValue = this.get(property);
            if (propValue != undefined) {
                this._text.set(property, propValue);
            }
        });
        if (this.get("html", "") !== "") {
            this._text.set("text", "");
        }
        this.onPrivate("maxWidth", () => {
            this._setMaxDimentions();
        });
        this.onPrivate("maxHeight", () => {
            this._setMaxDimentions();
        });
    }
    _makeText() {
        this._text = this.children.push(_render_Text__WEBPACK_IMPORTED_MODULE_0__["Text"].new(this._root, {}));
    }
    _updateChildren() {
        super._updateChildren();
        _core_util_Array__WEBPACK_IMPORTED_MODULE_3__["each"](this._textKeys, (property) => {
            this._text.set(property, this.get(property));
        });
        if (this.isDirty("maxWidth")) {
            this._setMaxDimentions();
        }
        if (this.isDirty("maxHeight")) {
            this._setMaxDimentions();
        }
        if (this.isDirty("rotation")) {
            this._setMaxDimentions();
        }
        // Do not show regular text if HTML is used
        if (this.get("html", "") !== "") {
            this._text.set("text", "");
        }
        else {
            this._text.set("text", this.get("text"));
        }
        if (this.isDirty("textAlign") || this.isDirty("width")) {
            const textAlign = this.get("textAlign");
            let x;
            if (this.get("width") != null) {
                if (textAlign == "right") {
                    x = _util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"];
                }
                else if (textAlign == "center") {
                    x = _util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"];
                }
                else {
                    x = 0;
                }
            }
            else {
                if (textAlign == "left" || textAlign == "start") {
                    x = this.get("paddingLeft");
                }
                else if (textAlign == "right" || textAlign == "end") {
                    x = -this.get("paddingRight");
                }
            }
            this.text.set("x", x);
        }
    }
    _setMaxDimentions() {
        const rotation = this.get("rotation");
        const vertical = rotation == 90 || rotation == 270 || rotation == -90;
        const maxWidth = this.get("maxWidth", this.getPrivate("maxWidth", Infinity));
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__["isNumber"](maxWidth)) {
            this.text.set(vertical ? "maxHeight" : "maxWidth", maxWidth - this.get("paddingLeft", 0) - this.get("paddingRight", 0));
        }
        else {
            this.text.set(vertical ? "maxHeight" : "maxWidth", undefined);
        }
        const maxHeight = this.get("maxHeight", this.getPrivate("maxHeight", Infinity));
        if (_core_util_Type__WEBPACK_IMPORTED_MODULE_4__["isNumber"](maxHeight)) {
            this.text.set(vertical ? "maxWidth" : "maxHeight", maxHeight - this.get("paddingTop", 0) - this.get("paddingBottom", 0));
        }
        else {
            this.text.set(vertical ? "maxWidth" : "maxHeight", undefined);
        }
    }
    _setDataItem(dataItem) {
        super._setDataItem(dataItem);
        this._markDirtyKey("text");
        if (this.text.get("populateText")) {
            this.text.markDirtyText();
        }
    }
    /**
     * Returns text with populated placeholders and formatting if `populateText` is
     * set to `true`.
     *
     * @return Populated text
     */
    getText() {
        return this._text._getText();
    }
}
Object.defineProperty(Label, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Label"
});
Object.defineProperty(Label, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_2__["Container"].classNames.concat([Label.className])
});
//# sourceMappingURL=Label.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js ***!
  \**************************************************************************/
/*! exports provided: eachChildren, Layout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eachChildren", function() { return eachChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layout", function() { return Layout; });
/* harmony import */ var _util_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");

function eachChildren(container, f) {
    if (container.get("reverseChildren", false)) {
        container.children.eachReverse(f);
    }
    else {
        container.children.each(f);
    }
}
/**
 * Base class for [[Container]] layouts.
 */
class Layout extends _util_Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
}
Object.defineProperty(Layout, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Layout"
});
Object.defineProperty(Layout, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _util_Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"].classNames.concat([Layout.className])
});
//# sourceMappingURL=Layout.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Legend.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Legend.js ***!
  \**************************************************************************/
/*! exports provided: Legend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Legend", function() { return Legend; });
/* harmony import */ var _Series__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Series */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_render_Label__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/render/Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");
/* harmony import */ var _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony import */ var _core_util_Template__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");







/**
 * A universal legend control.
 *
 * @important
 * @see {@link https://www.amcharts.com/docs/v5/concepts/legend/} for more info
 */
class Legend extends _Series__WEBPACK_IMPORTED_MODULE_0__["Series"] {
    constructor() {
        super(...arguments);
        /**
         * List of all [[Container]] elements for legend items.
         *
         * @default new ListTemplate<Container>
         */
        Object.defineProperty(this, "itemContainers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_5__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_4__["Template"].new({}), () => _core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.itemContainers.template.get("themeTags", []), ["legend", "item"]),
                themeTagsSelf: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"]),
                background: _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__["RoundedRectangle"].new(this._root, {
                    themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.itemContainers.template.get("themeTags", []), ["legend", "item", "background"]),
                    themeTagsSelf: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"])
                })
            }, [this.itemContainers.template]))
        });
        /**
         * List of legend marker elements.
         *
         * @default new ListTemplate<Container>
         */
        Object.defineProperty(this, "markers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_5__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_4__["Template"].new({}), () => _core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.markers.template.get("themeTags", []), ["legend", "marker"])
            }, [this.markers.template]))
        });
        /**
         * List of legend label elements.
         *
         * @default new ListTemplate<Label>
         */
        Object.defineProperty(this, "labels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_5__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_4__["Template"].new({}), () => _core_render_Label__WEBPACK_IMPORTED_MODULE_2__["Label"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.labels.template.get("themeTags", []), ["legend", "label"])
            }, [this.labels.template]))
        });
        /**
         * List of legend value label elements.
         *
         * @default new ListTemplate<label>
         */
        Object.defineProperty(this, "valueLabels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_5__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_4__["Template"].new({}), () => _core_render_Label__WEBPACK_IMPORTED_MODULE_2__["Label"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.valueLabels.template.get("themeTags", []), ["legend", "label", "value"])
            }, [this.valueLabels.template]))
        });
        /**
         * List of rectangle elements used for default legend markers.
         *
         * @default new ListTemplate<RoundedRectangle>
         */
        Object.defineProperty(this, "markerRectangles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_5__["ListTemplate"](_core_util_Template__WEBPACK_IMPORTED_MODULE_4__["Template"].new({}), () => _core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_3__["RoundedRectangle"]._new(this._root, {
                themeTags: _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this.markerRectangles.template.get("themeTags", []), ["legend", "marker", "rectangle"])
            }, [this.markerRectangles.template]))
        });
    }
    _afterNew() {
        this._settings.themeTags = _core_util_Utils__WEBPACK_IMPORTED_MODULE_6__["mergeTags"](this._settings.themeTags, ["legend"]);
        this.fields.push("name", "stroke", "fill");
        super._afterNew();
    }
    /**
     * @ignore
     */
    makeItemContainer(dataItem) {
        const itemContainer = this.children.push(this.itemContainers.make());
        itemContainer._setDataItem(dataItem);
        this.itemContainers.push(itemContainer);
        itemContainer.states.create("disabled", {});
        return itemContainer;
    }
    /**
     * @ignore
     */
    makeMarker() {
        const marker = this.markers.make();
        this.markers.push(marker);
        marker.states.create("disabled", {});
        return marker;
    }
    /**
     * @ignore
     */
    makeLabel() {
        const label = this.labels.make();
        label.states.create("disabled", {});
        return label;
    }
    /**
     * @ignore
     */
    makeValueLabel() {
        const valueLabel = this.valueLabels.make();
        valueLabel.states.create("disabled", {});
        return valueLabel;
    }
    /**
     * @ignore
     */
    makeMarkerRectangle() {
        const markerRectangle = this.markerRectangles.make();
        markerRectangle.states.create("disabled", {});
        return markerRectangle;
    }
    processDataItem(dataItem) {
        super.processDataItem(dataItem);
        const itemContainer = this.makeItemContainer(dataItem);
        const nameField = this.get("nameField");
        const fillField = this.get("fillField");
        const strokeField = this.get("strokeField");
        if (itemContainer) {
            const clickTarget = this.get("clickTarget", "itemContainer");
            const item = dataItem.dataContext;
            if (item && item.set) {
                item.set("legendDataItem", dataItem);
            }
            itemContainer._setDataItem(dataItem);
            dataItem.set("itemContainer", itemContainer);
            const marker = this.makeMarker();
            if (marker) {
                itemContainer.children.push(marker);
                marker._setDataItem(dataItem);
                dataItem.set("marker", marker);
                const useDefaultMarker = this.get("useDefaultMarker");
                const markerRectangle = marker.children.push(this.makeMarkerRectangle());
                let fill = dataItem.get("fill");
                let stroke = dataItem.get("stroke");
                dataItem.set("markerRectangle", markerRectangle);
                if (item && item.get) {
                    fill = item.get(fillField, fill);
                    stroke = item.get(strokeField, stroke);
                }
                if (!stroke) {
                    stroke = fill;
                }
                if (!useDefaultMarker) {
                    if (item && item.createLegendMarker) {
                        item.createLegendMarker();
                    }
                }
                else {
                    if (item.on) {
                        item.on(fillField, () => {
                            markerRectangle.set("fill", item.get(fillField));
                        });
                        item.on(strokeField, () => {
                            markerRectangle.set("stroke", item.get(strokeField));
                        });
                    }
                }
                markerRectangle.setAll({ fill, stroke });
                // this solves if template field is set on slice
                const component = item.component;
                if (component && component.updateLegendMarker) {
                    component.updateLegendMarker(item);
                }
            }
            const label = this.makeLabel();
            if (label) {
                itemContainer.children.push(label);
                label._setDataItem(dataItem);
                dataItem.set("label", label);
                label.text.on("text", () => {
                    itemContainer.set("ariaLabel", label.text._getText() + (this.get("clickTarget") !== "none" ? "; " + this._t("Press ENTER to toggle") : ""));
                });
                if (item && item.get) {
                    dataItem.set("name", item.get(nameField));
                }
                let name = dataItem.get("name");
                if (name) {
                    label.set("text", name);
                }
            }
            const valueLabel = this.makeValueLabel();
            if (valueLabel) {
                itemContainer.children.push(valueLabel);
                valueLabel._setDataItem(dataItem);
                dataItem.set("valueLabel", valueLabel);
            }
            if (item && item.show) {
                this._disposers.push(item.on("visible", (visible) => {
                    itemContainer.set("disabled", !visible);
                }));
                if (!item.get("visible")) {
                    itemContainer.set("disabled", true);
                }
                if (clickTarget != "none") {
                    var clickContainer = itemContainer;
                    if (clickTarget == "marker") {
                        clickContainer = marker;
                    }
                    this._addClickEvents(clickContainer, item, dataItem);
                }
            }
            // Sort children
            this.children.values.sort((a, b) => {
                var targetA = a.dataItem.dataContext;
                var targetB = b.dataItem.dataContext;
                if (targetA && targetB) {
                    var indexA = this.data.indexOf(targetA);
                    var indexB = this.data.indexOf(targetB);
                    if (indexA > indexB) {
                        return 1;
                    }
                    else if (indexA < indexB) {
                        return -1;
                    }
                }
                return 0;
            });
            if (item && item.updateLegendValue) {
                item.updateLegendValue();
            }
        }
    }
    _addClickEvents(container, item, dataItem) {
        container.set("cursorOverStyle", "pointer");
        container.events.on("pointerover", () => {
            const component = item.component;
            if (component && component.hoverDataItem) {
                component.hoverDataItem(item);
            }
        });
        container.events.on("pointerout", () => {
            const component = item.component;
            if (component && component.hoverDataItem) {
                component.unhoverDataItem(item);
            }
        });
        container.events.on("click", () => {
            const labelText = dataItem.get("label").text._getText();
            if (item.show && item.isHidden && (item.isHidden() || item.get("visible") === false)) {
                item.show();
                container.set("disabled", false);
                this._root.readerAlert(this._t("%1 shown", this._root.locale, labelText));
            }
            else if (item.hide) {
                item.hide();
                container.set("disabled", true);
                this._root.readerAlert(this._t("%1 hidden", this._root.locale, labelText));
            }
        });
    }
    /**
     * @ignore
     */
    disposeDataItem(dataItem) {
        super.disposeDataItem(dataItem);
        const dataContext = dataItem.dataContext;
        if (dataContext && dataContext.get) {
            const di = dataContext.get("legendDataItem");
            if (di == dataItem) {
                dataContext.set("legendDataItem", undefined);
            }
        }
        let itemContainer = dataItem.get("itemContainer");
        if (itemContainer) {
            this.itemContainers.removeValue(itemContainer);
            itemContainer.dispose();
        }
        let marker = dataItem.get("marker");
        if (marker) {
            this.markers.removeValue(marker);
            marker.dispose();
        }
        let markerRectangle = dataItem.get("markerRectangle");
        if (markerRectangle) {
            this.markerRectangles.removeValue(markerRectangle);
            markerRectangle.dispose();
        }
        let label = dataItem.get("label");
        if (label) {
            this.labels.removeValue(label);
            label.dispose();
        }
        let valueLabel = dataItem.get("valueLabel");
        if (valueLabel) {
            this.valueLabels.removeValue(valueLabel);
            valueLabel.dispose();
        }
    }
}
Object.defineProperty(Legend, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Legend"
});
Object.defineProperty(Legend, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Series__WEBPACK_IMPORTED_MODULE_0__["Series"].classNames.concat([Legend.className])
});
//# sourceMappingURL=Legend.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js ***!
  \************************************************************************/
/*! exports provided: Line */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _util_Draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Draw */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Draw.js");


/**
 * Draws a line.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Line extends _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("points") || this.isDirty("segments") || this._sizeDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            const points = this.get("points");
            const segments = this.get("segments");
            if (points && points.length > 0) {
                let point = points[0];
                this._display.moveTo(point.x, point.y);
                _util_Draw__WEBPACK_IMPORTED_MODULE_1__["segmentedLine"](this._display, [[points]]);
            }
            else if (segments) {
                _util_Draw__WEBPACK_IMPORTED_MODULE_1__["segmentedLine"](this._display, segments);
            }
            else if (!this.get("draw")) {
                let w = this.width();
                let h = this.height();
                this._display.moveTo(0, 0);
                this._display.lineTo(w, h);
            }
        }
    }
}
Object.defineProperty(Line, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Line"
});
Object.defineProperty(Line, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"].classNames.concat([Line.className])
});
//# sourceMappingURL=Line.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/MonotoneXTension.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/MonotoneXTension.js ***!
  \************************************************************************************/
/*! exports provided: MonotoneXTension, curveMonotoneXTension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MonotoneXTension", function() { return MonotoneXTension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneXTension", function() { return curveMonotoneXTension; });
/**
 * @ignore
 */
class MonotoneXTension {
    constructor(context, tension) {
        Object.defineProperty(this, "_line", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_point", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_x0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_x1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_y0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_y1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_t0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_tension", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        this._context = context;
        this._tension = tension;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x0 = this._x1 =
            this._y0 = this._y1 =
                this._t0 = NaN;
        this._point = 0;
    }
    lineEnd() {
        switch (this._point) {
            case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
            case 3:
                point(this, this._t0, slope2(this, this._t0));
                break;
        }
        if (this._line || (this._line !== 0 && this._point === 1))
            this._context.closePath();
        this._line = 1 - this._line;
    }
    point(x, y) {
        let t1 = NaN;
        x = +x, y = +y;
        if (x === this._x1 && y === this._y1)
            return; // Ignore coincident points.
        switch (this._point) {
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                point(this, slope2(this, t1 = slope3(this, x, y)), t1);
                break;
            default:
                point(this, this._t0, t1 = slope3(this, x, y));
                break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
    }
}
/**
 * @ignore
 */
function curveMonotoneXTension(tension) {
    function monotoneXTension(context) {
        return new MonotoneXTension(context, tension);
    }
    return monotoneXTension;
}
/**
 * @ignore
 */
function sign(x) {
    return x < 0 ? -1 : 1;
}
/**
 * @ignore
 */
function slope3(that, x2, y2) {
    let h0 = (that._x1 - that._x0);
    let h1 = (x2 - that._x1);
    let s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0);
    let s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0);
    let p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
/**
 * @ignore
 */
function slope2(that, t) {
    let h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
/**
 * @ignore
 */
function point(that, t0, t1) {
    let x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 1.5 * (1 - that._tension);
    that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}
//# sourceMappingURL=MonotoneXTension.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/MonotoneYTension.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/MonotoneYTension.js ***!
  \************************************************************************************/
/*! exports provided: MonotoneYTension, curveMonotoneYTension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MonotoneYTension", function() { return MonotoneYTension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneYTension", function() { return curveMonotoneYTension; });
/**
 * @ignore
 */
class MonotoneYTension {
    constructor(context, tension) {
        Object.defineProperty(this, "_line", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_point", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_x0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_x1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_y0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_y1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_t0", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_tension", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        this._context = context;
        this._tension = tension;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x0 = this._x1 =
            this._y0 = this._y1 =
                this._t0 = NaN;
        this._point = 0;
    }
    lineEnd() {
        switch (this._point) {
            case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
            case 3:
                point(this, this._t0, slope2(this, this._t0));
                break;
        }
        if (this._line || (this._line !== 0 && this._point === 1))
            this._context.closePath();
        this._line = 1 - this._line;
    }
    point(x, y) {
        [x, y] = [y, x];
        let t1 = NaN;
        x = +x, y = +y;
        if (x === this._x1 && y === this._y1)
            return; // Ignore coincident points.
        switch (this._point) {
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(y, x) : this._context.moveTo(y, x);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                point(this, slope2(this, t1 = slope3(this, x, y)), t1);
                break;
            default:
                point(this, this._t0, t1 = slope3(this, x, y));
                break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
    }
}
/**
 * @ignore
 */
function curveMonotoneYTension(tension) {
    function monotoneYTension(context) {
        return new MonotoneYTension(context, tension);
    }
    monotoneYTension.tension = function (tension) {
        return curveMonotoneYTension(+tension);
    };
    return monotoneYTension;
}
/**
 * @ignore
 */
function sign(x) {
    return x < 0 ? -1 : 1;
}
/**
 * @ignore
 */
function slope3(that, x2, y2) {
    let h0 = (that._x1 - that._x0);
    let h1 = (x2 - that._x1);
    let s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0);
    let s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0);
    let p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
/**
 * @ignore
 */
function slope2(that, t) {
    let h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
/**
 * @ignore
 */
function point(that, t0, t1) {
    let x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 1.5 * (1 - that._tension);
    that._context.bezierCurveTo(y0 + dx * t0, x0 + dx, y1 - dx * t1, x1 - dx, y1, x1);
}
//# sourceMappingURL=MonotoneYTension.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Picture.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Picture.js ***!
  \***************************************************************************/
/*! exports provided: Picture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Picture", function() { return Picture; });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");


/**
 * Displays an image.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/images/} for more info
 * @important
 */
class Picture extends _Sprite__WEBPACK_IMPORTED_MODULE_0__["Sprite"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makePicture(undefined)
        });
    }
    _changed() {
        super._changed();
        if (this.isDirty("width")) {
            const width = this.get("width");
            this._display.width = _util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](width) ? width : undefined;
        }
        if (this.isDirty("height")) {
            const height = this.get("height");
            this._display.height = _util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](height) ? height : undefined;
        }
        if (this.isDirty("shadowColor")) {
            this._display.clear();
            const shadowColor = this.get("shadowColor");
            this._display.shadowColor = shadowColor == null ? undefined : shadowColor;
        }
        if (this.isDirty("shadowBlur")) {
            this._display.clear();
            this._display.shadowBlur = this.get("shadowBlur");
        }
        if (this.isDirty("shadowOffsetX")) {
            this._display.clear();
            this._display.shadowOffsetX = this.get("shadowOffsetX");
        }
        if (this.isDirty("shadowOffsetY")) {
            this._display.clear();
            this._display.shadowOffsetY = this.get("shadowOffsetY");
        }
        if (this.isDirty("shadowOpacity")) {
            this._display.clear();
            this._display.shadowOpacity = this.get("shadowOpacity");
        }
        if (this.isDirty("src") || this.isDirty("cors")) {
            this._display.clear();
            this._load();
        }
    }
    _load() {
        const src = this.get("src");
        if (src) {
            const image = new Image();
            image.crossOrigin = this.get("cors", "anonymous");
            image.src = src;
            image.decode().then(() => {
                this._display.image = image;
                this._updateSize();
            }).catch((_error) => {
                // TODO: maybe raise error?
            });
        }
    }
    _updateSize() {
        super._updateSize();
        const image = this._display.image;
        if (image) {
            let w = this.getPrivate("width", this.get("width"));
            let h = this.getPrivate("height", this.get("height"));
            const r = image.width && image.height ? image.width / image.height : 0;
            if (_util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](w) && _util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](h)) {
                this._display.width = w;
                this._display.height = h;
            }
            else if (_util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](w) && r) {
                h = w / r;
            }
            else if (_util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](h) && r) {
                w = h * r;
            }
            else {
                w = image.width;
                h = image.height;
            }
            if (_util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](w)) {
                this._display.width = w;
            }
            if (_util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](h)) {
                this._display.height = h;
            }
            this.markDirtyBounds();
            this.markDirty();
        }
    }
}
Object.defineProperty(Picture, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Picture"
});
Object.defineProperty(Picture, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Sprite__WEBPACK_IMPORTED_MODULE_0__["Sprite"].classNames.concat([Picture.className])
});
//# sourceMappingURL=Picture.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js ***!
  \************************************************************************************/
/*! exports provided: PointedRectangle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointedRectangle", function() { return PointedRectangle; });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");


/**
 * Draws a rectangle with a pointer.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class PointedRectangle extends _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("pointerBaseWidth") || this.isDirty("cornerRadius") || this.isDirty("pointerLength") || this.isDirty("pointerX") || this.isDirty("pointerY") || this.isDirty("width") || this.isDirty("height")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            this.markDirtyBounds();
            let w = this.width();
            let h = this.height();
            if (w > 0 && h > 0) {
                let cr = this.get("cornerRadius", 8);
                cr = _util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](cr, 0, Math.min(w / 2, h / 2));
                let x = this.get("pointerX", 0);
                let y = this.get("pointerY", 0);
                let bwh = this.get("pointerBaseWidth", 15) / 2;
                // corner coordinates
                // top left
                let xtl = 0;
                let ytl = 0;
                // top right
                let xtr = w;
                let ytr = 0;
                // bottom right
                let xbr = w;
                let ybr = h;
                // bottom left
                let xbl = 0;
                let ybl = h;
                // find stem base side: http://$math.stackexchange.com/questions/274712/calculate-on-which-side-of-straign-line-is-dot-located
                // d=(x−x1)(y2−y1)−(y−y1)(x2−x1)
                let d1 = (x - xtl) * (ybr - ytl) - (y - ytl) * (xbr - xtl);
                let d2 = (x - xbl) * (ytr - ybl) - (y - ybl) * (xtr - xbl);
                const display = this._display;
                // top
                display.moveTo(cr, 0);
                if (d1 > 0 && d2 > 0) {
                    let stemX = Math.round(_util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](x, cr + bwh, w - bwh - cr));
                    y = _util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](y, -Infinity, 0);
                    display.lineTo(stemX - bwh, 0);
                    display.lineTo(x, y);
                    display.lineTo(stemX + bwh, 0);
                }
                display.lineTo(w - cr, 0);
                display.arcTo(w, 0, w, cr, cr);
                // right
                if (d1 > 0 && d2 < 0) {
                    let stemY = Math.round(_util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](y, cr + bwh, h - bwh - cr));
                    x = _util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](x, w, Infinity);
                    display.lineTo(w, cr);
                    display.lineTo(w, Math.max(stemY - bwh, cr));
                    display.lineTo(x, y);
                    display.lineTo(w, stemY + bwh);
                }
                display.lineTo(w, h - cr);
                display.arcTo(w, h, w - cr, h, cr);
                // bottom
                if (d1 < 0 && d2 < 0) {
                    let stemX = Math.round(_util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](x, cr + bwh, w - bwh - cr));
                    y = _util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](y, h, Infinity);
                    display.lineTo(w - cr, h);
                    display.lineTo(stemX + bwh, h);
                    display.lineTo(x, y);
                    display.lineTo(stemX - bwh, h);
                }
                display.lineTo(cr, h);
                display.arcTo(0, h, 0, h - cr, cr);
                // left
                if (d1 < 0 && d2 > 0) {
                    let stemY = Math.round(_util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](y, cr + bwh, h - cr - bwh));
                    x = _util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](x, -Infinity, 0);
                    display.lineTo(0, h - cr);
                    display.lineTo(0, stemY + bwh);
                    display.lineTo(x, y);
                    display.lineTo(0, Math.max(stemY - bwh, cr));
                }
                display.lineTo(0, cr);
                display.arcTo(0, 0, cr, 0, cr);
                display.closePath();
            }
        }
    }
}
Object.defineProperty(PointedRectangle, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "PointedRectangle"
});
Object.defineProperty(PointedRectangle, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"].classNames.concat([PointedRectangle.className])
});
//# sourceMappingURL=PointedRectangle.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/RadialLabel.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/RadialLabel.js ***!
  \*******************************************************************************/
/*! exports provided: RadialLabel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RadialLabel", function() { return RadialLabel; });
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _Label__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");
/* harmony import */ var _RadialText__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RadialText */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RadialText.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
// import * as $object from "../util/Object";





class RadialLabel extends _Label__WEBPACK_IMPORTED_MODULE_1__["Label"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_flipped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _afterNew() {
        this._textKeys.push("textType", "kerning");
        super._afterNew();
    }
    _makeText() {
        this._text = this.children.push(_RadialText__WEBPACK_IMPORTED_MODULE_2__["RadialText"].new(this._root, {}));
    }
    /**
     * Returns base radius in pixels.
     *
     * @return Base radius
     */
    baseRadius() {
        const radiusPrivate = this.getPrivate("radius", 0);
        const innerRadiusPrivate = this.getPrivate("innerRadius", 0);
        const baseRadius = this.get("baseRadius", 0);
        return innerRadiusPrivate + _util_Utils__WEBPACK_IMPORTED_MODULE_4__["relativeToValue"](baseRadius, radiusPrivate - innerRadiusPrivate);
    }
    /**
     * Returns radius adjustment in pixels.
     *
     * @return Radius
     */
    radius() {
        const inside = this.get("inside", false);
        return this.baseRadius() + this.get("radius", 0) * (inside ? -1 : 1);
    }
    _updateChildren() {
        super._updateChildren();
        if (this.isDirty("baseRadius") || this.isPrivateDirty("radius") || this.isPrivateDirty("innerRadius") || this.isDirty("labelAngle") || this.isDirty("radius") || this.isDirty("inside") || this.isDirty("orientation") || this.isDirty("textType")) {
            const textType = this.get("textType", "adjusted");
            const inside = this.get("inside", false);
            const orientation = this.get("orientation");
            let labelAngle = _util_Math__WEBPACK_IMPORTED_MODULE_3__["normalizeAngle"](this.get("labelAngle", 0));
            this._text.set("startAngle", this.get("labelAngle", 0));
            this._text.set("inside", inside);
            const sin = _util_Math__WEBPACK_IMPORTED_MODULE_3__["sin"](labelAngle);
            const cos = _util_Math__WEBPACK_IMPORTED_MODULE_3__["cos"](labelAngle);
            let baseRadius = this.baseRadius();
            let radius = this.radius();
            this._display.angle = 0;
            if (textType == "circular") {
                this.setAll({
                    paddingTop: 0,
                    paddingBottom: 0,
                    paddingLeft: 0,
                    paddingRight: 0
                });
                // Circular labels are handled and positioned differently
                this._text.set("orientation", orientation);
                this._text.set("radius", radius);
            }
            else {
                if (baseRadius == 0) {
                    labelAngle = 0;
                    radius = 0;
                }
                // Positioning of radial/regular labels are teh same
                let x = radius * cos;
                let y = radius * sin;
                if (textType == "radial") {
                    this.setRaw("x", x);
                    this.setRaw("y", y);
                    if ((labelAngle < 90) || (labelAngle > 270) || orientation != "auto") {
                        this._display.angle = labelAngle; // + 90;
                        this._flipped = false;
                    }
                    else {
                        this._display.angle = labelAngle + 180;
                        this._flipped = true;
                    }
                    this._dirty.rotation = false;
                }
                else if (textType == "adjusted") {
                    this.setRaw("centerX", _util_Percent__WEBPACK_IMPORTED_MODULE_0__["p50"]);
                    this.setRaw("centerY", _util_Percent__WEBPACK_IMPORTED_MODULE_0__["p50"]);
                    this.setRaw("x", x);
                    this.setRaw("y", y);
                }
                else if (textType == "regular") {
                    this.setRaw("x", x);
                    this.setRaw("y", y);
                }
            }
            this.markDirtyPosition();
            this.markDirtyBounds();
        }
    }
    _updatePosition() {
        const textType = this.get("textType", "regular");
        const inside = this.get("inside", false);
        let dx = 0;
        let dy = 0;
        let labelAngle = this.get("labelAngle", 0);
        let bounds = this.localBounds();
        let w = bounds.right - bounds.left;
        let h = bounds.bottom - bounds.top;
        if (textType == "radial") {
            if (this._flipped) {
                let centerX = this.get("centerX");
                if (centerX instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_0__["Percent"]) {
                    w = w * (1 - centerX.value * 2);
                }
                dx = w * _util_Math__WEBPACK_IMPORTED_MODULE_3__["cos"](labelAngle);
                dy = w * _util_Math__WEBPACK_IMPORTED_MODULE_3__["sin"](labelAngle);
            }
        }
        else if (!inside && textType == "adjusted") {
            dx = w / 2 * _util_Math__WEBPACK_IMPORTED_MODULE_3__["cos"](labelAngle);
            dy = h / 2 * _util_Math__WEBPACK_IMPORTED_MODULE_3__["sin"](labelAngle);
        }
        this.setRaw("dx", dx);
        this.setRaw("dy", dy);
        super._updatePosition();
    }
    /**
     * @ignore
     */
    get text() {
        return this._text;
    }
}
Object.defineProperty(RadialLabel, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "RadialLabel"
});
Object.defineProperty(RadialLabel, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Label__WEBPACK_IMPORTED_MODULE_1__["Label"].classNames.concat([RadialLabel.className])
});
//# sourceMappingURL=RadialLabel.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/RadialText.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/RadialText.js ***!
  \******************************************************************************/
/*! exports provided: RadialText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RadialText", function() { return RadialText; });
/* harmony import */ var _Text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Text */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");


/**
 * @ignore
 */
class RadialText extends _Text__WEBPACK_IMPORTED_MODULE_0__["Text"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeRadialText("", this.textStyle)
        });
    }
    _afterNew() {
        super._afterNew();
    }
    _beforeChanged() {
        super._beforeChanged();
        this._display.clear();
        if (this.isDirty("textType")) {
            this._display.textType = this.get("textType");
            this.markDirtyBounds();
        }
        if (this.isDirty("radius")) {
            this._display.radius = this.get("radius");
            this.markDirtyBounds();
        }
        if (this.isDirty("startAngle")) {
            this._display.startAngle = (this.get("startAngle", 0) + 90) * _util_Math__WEBPACK_IMPORTED_MODULE_1__["RADIANS"];
            this.markDirtyBounds();
        }
        if (this.isDirty("inside")) {
            this._display.inside = this.get("inside");
            this.markDirtyBounds();
        }
        if (this.isDirty("orientation")) {
            this._display.orientation = this.get("orientation");
            this.markDirtyBounds();
        }
        if (this.isDirty("kerning")) {
            this._display.kerning = this.get("kerning");
            this.markDirtyBounds();
        }
    }
}
Object.defineProperty(RadialText, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "RadialText"
});
Object.defineProperty(RadialText, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Text__WEBPACK_IMPORTED_MODULE_0__["Text"].classNames.concat([RadialText.className])
});
//# sourceMappingURL=RadialText.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js ***!
  \*****************************************************************************/
/*! exports provided: Rectangle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rectangle", function() { return Rectangle; });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");

/**
 * Draws a rectangle.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Rectangle extends _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear && !this.get("draw")) {
            this._draw();
        }
    }
    _draw() {
        this._display.drawRect(0, 0, this.width(), this.height());
    }
    _updateSize() {
        this.markDirty();
        this._clear = true;
    }
}
Object.defineProperty(Rectangle, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Rectangle"
});
Object.defineProperty(Rectangle, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"].classNames.concat([Rectangle.className])
});
//# sourceMappingURL=Rectangle.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js ***!
  \************************************************************************************/
/*! exports provided: RoundedRectangle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RoundedRectangle", function() { return RoundedRectangle; });
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _Rectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");




/**
 * Draws a rectangle with rounded corners.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class RoundedRectangle extends _Rectangle__WEBPACK_IMPORTED_MODULE_3__["Rectangle"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("cornerRadiusTL") || this.isDirty("cornerRadiusTR") || this.isDirty("cornerRadiusBR") || this.isDirty("cornerRadiusBL")) {
            this._clear = true;
        }
    }
    _draw() {
        let width = this.width();
        let height = this.height();
        let w = width;
        let h = height;
        let wSign = w / Math.abs(width);
        let hSign = h / Math.abs(height);
        if (_util_Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"](w) && _util_Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"](h)) {
            let minSide = Math.min(w, h) / 2;
            let crtl = _util_Utils__WEBPACK_IMPORTED_MODULE_2__["relativeToValue"](this.get("cornerRadiusTL", 8), minSide);
            let crtr = _util_Utils__WEBPACK_IMPORTED_MODULE_2__["relativeToValue"](this.get("cornerRadiusTR", 8), minSide);
            let crbr = _util_Utils__WEBPACK_IMPORTED_MODULE_2__["relativeToValue"](this.get("cornerRadiusBR", 8), minSide);
            let crbl = _util_Utils__WEBPACK_IMPORTED_MODULE_2__["relativeToValue"](this.get("cornerRadiusBL", 8), minSide);
            let maxcr = Math.min(Math.abs(w / 2), Math.abs(h / 2));
            crtl = _util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](crtl, 0, maxcr);
            crtr = _util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](crtr, 0, maxcr);
            crbr = _util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](crbr, 0, maxcr);
            crbl = _util_Math__WEBPACK_IMPORTED_MODULE_1__["fitToRange"](crbl, 0, maxcr);
            const display = this._display;
            display.moveTo(crtl * wSign, 0);
            display.lineTo(w - crtr * wSign, 0);
            if (crtr > 0) {
                display.arcTo(w, 0, w, crtr * hSign, crtr);
            }
            display.lineTo(w, h - crbr * hSign);
            if (crbr > 0) {
                display.arcTo(w, h, w - crbr * wSign, h, crbr);
            }
            display.lineTo(crbl * wSign, h);
            if (crbl > 0) {
                display.arcTo(0, h, 0, h - crbl * hSign, crbl);
            }
            display.lineTo(0, crtl * hSign);
            if (crtl > 0) {
                display.arcTo(0, 0, crtl * wSign, 0, crtl);
            }
            display.closePath();
        }
    }
}
Object.defineProperty(RoundedRectangle, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "RoundedRectangle"
});
Object.defineProperty(RoundedRectangle, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Rectangle__WEBPACK_IMPORTED_MODULE_3__["Rectangle"].classNames.concat([RoundedRectangle.className])
});
//# sourceMappingURL=RoundedRectangle.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Scrollbar.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Scrollbar.js ***!
  \*****************************************************************************/
/*! exports provided: Scrollbar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scrollbar", function() { return Scrollbar; });
/* harmony import */ var _render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Button */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");






/**
 * A control that allows zooming chart's axes, or other uses requiring range
 * selection.
 *
 * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/scrollbars/} for more info
 */
class Scrollbar extends _Container__WEBPACK_IMPORTED_MODULE_1__["Container"] {
    constructor() {
        super(...arguments);
        /**
         * A thumb elment - a draggable square between the grips, used for panning
         * the selection.
         */
        Object.defineProperty(this, "thumb", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._makeThumb()
        });
        /**
         * Start grip button.
         */
        Object.defineProperty(this, "startGrip", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._makeButton()
        });
        /**
         * End grip button.
         */
        Object.defineProperty(this, "endGrip", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._makeButton()
        });
        Object.defineProperty(this, "_thumbBusy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_startDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_endDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_thumbDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_gripDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _addOrientationClass() {
        this._settings.themeTags = _util_Utils__WEBPACK_IMPORTED_MODULE_5__["mergeTags"](this._settings.themeTags, ["scrollbar", this._settings.orientation]);
        if (!this._settings.background) {
            this._settings.background = _render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__["RoundedRectangle"].new(this._root, {
                themeTags: _util_Utils__WEBPACK_IMPORTED_MODULE_5__["mergeTags"](this._settings.themeTags, ["main", "background"])
            });
        }
    }
    _makeButton() {
        return this.children.push(_Button__WEBPACK_IMPORTED_MODULE_3__["Button"].new(this._root, {
            themeTags: ["resize", "button", this.get("orientation")], icon: _Graphics__WEBPACK_IMPORTED_MODULE_2__["Graphics"].new(this._root, {
                themeTags: ["icon"]
            })
        }));
    }
    _makeThumb() {
        return this.children.push(_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_0__["RoundedRectangle"].new(this._root, {
            themeTags: ["thumb", this.get("orientation")]
        }));
    }
    _handleAnimation(animation) {
        if (animation) {
            this._disposers.push(animation.events.on("stopped", () => {
                this.setPrivateRaw("isBusy", false);
                this._thumbBusy = false;
            }));
        }
    }
    _afterNew() {
        this._addOrientationClass();
        super._afterNew();
        const startGrip = this.startGrip;
        const endGrip = this.endGrip;
        const thumb = this.thumb;
        const background = this.get("background");
        if (background) {
            this._disposers.push(background.events.on("click", (event) => {
                this.setPrivateRaw("isBusy", true);
                const point = this._display.toLocal(event.point);
                const w = this.width();
                const h = this.height();
                const orientation = this.get("orientation");
                let newMiddle;
                if (orientation == "vertical") {
                    newMiddle = (point.y - thumb.height() / 2) / h;
                }
                else {
                    newMiddle = (point.x - thumb.width() / 2) / w;
                }
                let newCoordinate;
                let key;
                if (orientation == "vertical") {
                    newCoordinate = newMiddle * h;
                    key = "y";
                }
                else {
                    newCoordinate = newMiddle * w;
                    key = "x";
                }
                const duration = this.get("animationDuration", 0);
                if (duration > 0) {
                    this._thumbBusy = true;
                    this._handleAnimation(this.thumb.animate({ key: key, to: newCoordinate, duration: duration, easing: this.get("animationEasing") }));
                }
                else {
                    this.thumb.set(key, newCoordinate);
                    this._root.events.once("frameended", () => {
                        this.setPrivateRaw("isBusy", false);
                    });
                }
            }));
        }
        this._disposers.push(thumb.events.on("dblclick", (event) => {
            if (!_util_Utils__WEBPACK_IMPORTED_MODULE_5__["isLocalEvent"](event.originalEvent, this)) {
                return;
            }
            const duration = this.get("animationDuration", 0);
            const easing = this.get("animationEasing");
            this.animate({ key: "start", to: 0, duration: duration, easing: easing });
            this.animate({ key: "end", to: 1, duration: duration, easing: easing });
        }));
        this._disposers.push(startGrip.events.on("pointerdown", () => {
            this.setPrivateRaw("isBusy", true);
            this._startDown = true;
            this._gripDown = "start";
        }));
        this._disposers.push(endGrip.events.on("pointerdown", () => {
            this.setPrivateRaw("isBusy", true);
            this._endDown = true;
            this._gripDown = "end";
        }));
        this._disposers.push(thumb.events.on("pointerdown", () => {
            this.setPrivateRaw("isBusy", true);
            this._thumbDown = true;
            this._gripDown = undefined;
        }));
        this._disposers.push(startGrip.events.on("globalpointerup", () => {
            if (this._startDown) {
                this.setPrivateRaw("isBusy", false);
            }
            this._startDown = false;
        }));
        this._disposers.push(endGrip.events.on("globalpointerup", () => {
            if (this._endDown) {
                this.setPrivateRaw("isBusy", false);
            }
            this._endDown = false;
        }));
        this._disposers.push(thumb.events.on("globalpointerup", () => {
            if (this._thumbDown) {
                this.setPrivateRaw("isBusy", false);
            }
            this._thumbDown = false;
        }));
        this._disposers.push(startGrip.on("x", () => {
            this._updateThumb();
        }));
        this._disposers.push(endGrip.on("x", () => {
            this._updateThumb();
        }));
        this._disposers.push(startGrip.on("y", () => {
            this._updateThumb();
        }));
        this._disposers.push(endGrip.on("y", () => {
            this._updateThumb();
        }));
        this._disposers.push(thumb.events.on("positionchanged", () => {
            this._updateGripsByThumb();
        }));
        if (this.get("orientation") == "vertical") {
            startGrip.set("x", 0);
            endGrip.set("x", 0);
            this._disposers.push(thumb.adapters.add("y", (value) => {
                return Math.max(Math.min(Number(value), this.height() - thumb.height()), 0);
            }));
            this._disposers.push(thumb.adapters.add("x", (_value) => {
                return this.width() / 2;
            }));
            this._disposers.push(startGrip.adapters.add("x", (_value) => {
                return this.width() / 2;
            }));
            this._disposers.push(endGrip.adapters.add("x", (_value) => {
                return this.width() / 2;
            }));
            this._disposers.push(startGrip.adapters.add("y", (value) => {
                return Math.max(Math.min(Number(value), this.height()), 0);
            }));
            this._disposers.push(endGrip.adapters.add("y", (value) => {
                return Math.max(Math.min(Number(value), this.height()), 0);
            }));
        }
        else {
            startGrip.set("y", 0);
            endGrip.set("y", 0);
            this._disposers.push(thumb.adapters.add("x", (value) => {
                return Math.max(Math.min(Number(value), this.width() - thumb.width()), 0);
            }));
            this._disposers.push(thumb.adapters.add("y", (_value) => {
                return this.height() / 2;
            }));
            this._disposers.push(startGrip.adapters.add("y", (_value) => {
                return this.height() / 2;
            }));
            this._disposers.push(endGrip.adapters.add("y", (_value) => {
                return this.height() / 2;
            }));
            this._disposers.push(startGrip.adapters.add("x", (value) => {
                return Math.max(Math.min(Number(value), this.width()), 0);
            }));
            this._disposers.push(endGrip.adapters.add("x", (value) => {
                return Math.max(Math.min(Number(value), this.width()), 0);
            }));
        }
    }
    _updateChildren() {
        super._updateChildren();
        if (this.isDirty("end") || this.isDirty("start") || this._sizeDirty) {
            this.updateGrips();
        }
    }
    _changed() {
        super._changed();
        if (this.isDirty("start") || this.isDirty("end")) {
            const eventType = "rangechanged";
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, { type: eventType, target: this, start: this.get("start", 0), end: this.get("end", 1), grip: this._gripDown });
            }
        }
    }
    /**
     * @ignore
     */
    updateGrips() {
        const startGrip = this.startGrip;
        const endGrip = this.endGrip;
        const orientation = this.get("orientation");
        const height = this.height();
        const width = this.width();
        if (orientation == "vertical") {
            startGrip.set("y", height * this.get("start", 0));
            endGrip.set("y", height * this.get("end", 1));
        }
        else {
            startGrip.set("x", width * this.get("start", 0));
            endGrip.set("x", width * this.get("end", 1));
        }
        const valueFunction = this.getPrivate("positionTextFunction");
        const from = Math.round(this.get("start", 0) * 100);
        const to = Math.round(this.get("end", 0) * 100);
        let fromValue;
        let toValue;
        if (valueFunction) {
            fromValue = valueFunction.call(this, this.get("start", 0));
            toValue = valueFunction.call(this, this.get("end", 0));
        }
        else {
            fromValue = from + "%";
            toValue = to + "%";
        }
        startGrip.set("ariaLabel", this._t("From %1", undefined, fromValue));
        startGrip.set("ariaValueNow", "" + from);
        startGrip.set("ariaValueText", from + "%");
        startGrip.set("ariaValueMin", "0");
        startGrip.set("ariaValueMax", "100");
        endGrip.set("ariaLabel", this._t("To %1", undefined, toValue));
        endGrip.set("ariaValueNow", "" + to);
        endGrip.set("ariaValueText", to + "%");
        endGrip.set("ariaValueMin", "0");
        endGrip.set("ariaValueMax", "100");
    }
    _updateThumb() {
        const thumb = this.thumb;
        const startGrip = this.startGrip;
        const endGrip = this.endGrip;
        const height = this.height();
        const width = this.width();
        let x0 = startGrip.x();
        let x1 = endGrip.x();
        let y0 = startGrip.y();
        let y1 = endGrip.y();
        let start = 0;
        let end = 1;
        if (this.get("orientation") == "vertical") {
            if (_util_Type__WEBPACK_IMPORTED_MODULE_4__["isNumber"](y0) && _util_Type__WEBPACK_IMPORTED_MODULE_4__["isNumber"](y1)) {
                if (!this._thumbBusy && !thumb.isDragging()) {
                    thumb.set("height", y1 - y0);
                    thumb.set("y", y0);
                }
                start = y0 / height;
                end = y1 / height;
            }
        }
        else {
            if (_util_Type__WEBPACK_IMPORTED_MODULE_4__["isNumber"](x0) && _util_Type__WEBPACK_IMPORTED_MODULE_4__["isNumber"](x1)) {
                if (!this._thumbBusy && !thumb.isDragging()) {
                    thumb.set("width", x1 - x0);
                    thumb.set("x", x0);
                }
                start = x0 / width;
                end = x1 / width;
            }
        }
        if (this.getPrivate("isBusy") && (this.get("start") != start || this.get("end") != end)) {
            this.set("start", start);
            this.set("end", end);
        }
        const valueFunction = this.getPrivate("positionTextFunction");
        const from = Math.round(this.get("start", 0) * 100);
        const to = Math.round(this.get("end", 0) * 100);
        let fromValue;
        let toValue;
        if (valueFunction) {
            fromValue = valueFunction.call(this, this.get("start", 0));
            toValue = valueFunction.call(this, this.get("end", 0));
        }
        else {
            fromValue = from + "%";
            toValue = to + "%";
        }
        thumb.set("ariaLabel", this._t("From %1 to %2", undefined, fromValue, toValue));
        thumb.set("ariaValueNow", "" + from);
        thumb.set("ariaValueText", from + "%");
    }
    _updateGripsByThumb() {
        const thumb = this.thumb;
        const startGrip = this.startGrip;
        const endGrip = this.endGrip;
        if (this.get("orientation") == "vertical") {
            const thumbSize = thumb.height();
            startGrip.set("y", thumb.y());
            endGrip.set("y", thumb.y() + thumbSize);
        }
        else {
            const thumbSize = thumb.width();
            startGrip.set("x", thumb.x());
            endGrip.set("x", thumb.x() + thumbSize);
        }
    }
}
Object.defineProperty(Scrollbar, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Scrollbar"
});
Object.defineProperty(Scrollbar, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_1__["Container"].classNames.concat([Scrollbar.className])
});
//# sourceMappingURL=Scrollbar.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js ***!
  \*******************************************************************************/
/*! exports provided: SerialChart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SerialChart", function() { return SerialChart; });
/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Chart */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");





/**
 * A base class for all series-based charts.
 */
class SerialChart extends _Chart__WEBPACK_IMPORTED_MODULE_0__["Chart"] {
    constructor() {
        super(...arguments);
        /**
         * A [[Container]] where chart will store all series.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "seriesContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_1__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_3__["p100"], isMeasured: false })
        });
        /**
         * A list of chart's series.
         */
        Object.defineProperty(this, "series", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_2__["ListAutoDispose"]()
        });
    }
    _afterNew() {
        super._afterNew();
        this._disposers.push(this.series);
        const children = this.seriesContainer.children;
        this._disposers.push(this.series.events.onAll((change) => {
            if (change.type === "clear") {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_4__["each"](change.oldValues, (series) => {
                    this._removeSeries(series);
                });
                const colors = this.get("colors");
                if (colors) {
                    colors.reset();
                }
            }
            else if (change.type === "push") {
                children.moveValue(change.newValue);
                this._processSeries(change.newValue);
            }
            else if (change.type === "setIndex") {
                children.setIndex(change.index, change.newValue);
                this._processSeries(change.newValue);
            }
            else if (change.type === "insertIndex") {
                children.insertIndex(change.index, change.newValue);
                this._processSeries(change.newValue);
            }
            else if (change.type === "removeIndex") {
                this._removeSeries(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                children.moveValue(change.value, change.newIndex);
                this._processSeries(change.value);
            }
            else {
                throw new Error("Unknown IListEvent type");
            }
        }));
    }
    _processSeries(series) {
        series.chart = this;
        series._placeBulletsContainer(this);
    }
    _removeSeries(series) {
        if (!series.isDisposed()) {
            this.seriesContainer.children.removeValue(series);
            series._removeBulletsContainer();
        }
    }
}
Object.defineProperty(SerialChart, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "SerialChart"
});
Object.defineProperty(SerialChart, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Chart__WEBPACK_IMPORTED_MODULE_0__["Chart"].classNames.concat([SerialChart.className])
});
//# sourceMappingURL=SerialChart.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js ***!
  \**************************************************************************/
/*! exports provided: Series */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Series", function() { return Series; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/@amcharts/amcharts5/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _core_render_Component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony import */ var _core_util_List__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_util_Animation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/util/Animation */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _core_util_Type__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _core_util_Time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/util/Time */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js");
/* harmony import */ var _core_render_Container__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _core_render_Label__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../core/render/Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");












/**
 * A base class for all series.
 */
class Series extends _core_render_Component__WEBPACK_IMPORTED_MODULE_1__["Component"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_aggregatesCalculated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_selectionAggregatesCalculated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_dataProcessed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_psi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pei", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * A chart series belongs to.
         */
        Object.defineProperty(this, "chart", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * List of bullets to use for the series.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/bullets/} for more info
         */
        Object.defineProperty(this, "bullets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _core_util_List__WEBPACK_IMPORTED_MODULE_2__["List"]()
        });
        /**
         * A [[Container]] series' bullets are stored in.
         *
         * @default Container.new()
         */
        Object.defineProperty(this, "bulletsContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _core_render_Container__WEBPACK_IMPORTED_MODULE_9__["Container"].new(this._root, { width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["p100"], position: "absolute" })
        });
    }
    _afterNew() {
        this.valueFields.push("value");
        super._afterNew();
        this.setPrivate("customData", {});
        this._disposers.push(this.bullets.events.onAll((change) => {
            if (change.type === "clear") {
                this._handleBullets(this.dataItems);
            }
            else if (change.type === "push") {
                this._handleBullets(this.dataItems);
            }
            else if (change.type === "setIndex") {
                this._handleBullets(this.dataItems);
            }
            else if (change.type === "insertIndex") {
                this._handleBullets(this.dataItems);
            }
            else if (change.type === "removeIndex") {
                this._handleBullets(this.dataItems);
            }
            else if (change.type === "moveIndex") {
                this._handleBullets(this.dataItems);
            }
            else {
                throw new Error("Unknown IListEvent type");
            }
        }));
    }
    _dispose() {
        this.bulletsContainer.dispose(); // can be in a different parent
        super._dispose();
    }
    startIndex() {
        let len = this.dataItems.length;
        return Math.min(this.getPrivate("startIndex", 0), len);
    }
    endIndex() {
        let len = this.dataItems.length;
        return Math.min(this.getPrivate("endIndex", len), len);
    }
    _handleBullets(dataItems) {
        _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](dataItems, (dataItem) => {
            const bullets = dataItem.bullets;
            if (bullets) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](bullets, (bullet) => {
                    bullet.dispose();
                });
                dataItem.bullets = undefined;
            }
        });
        this.markDirtyValues();
    }
    /**
     * Looks up and returns a data item by its ID.
     *
     * @param   id  ID
     * @return      Data item
     */
    getDataItemById(id) {
        return _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["find"](this.dataItems, (dataItem) => {
            return dataItem.get("id") == id;
        });
    }
    _makeBullets(dataItem) {
        if (this._shouldMakeBullet(dataItem)) {
            dataItem.bullets = [];
            this.bullets.each((bulletFunction) => {
                this._makeBullet(dataItem, bulletFunction);
            });
        }
    }
    _shouldMakeBullet(_dataItem) {
        return true;
    }
    _makeBullet(dataItem, bulletFunction, index) {
        const bullet = bulletFunction(this._root, this, dataItem);
        if (bullet) {
            let sprite = bullet.get("sprite");
            if (sprite) {
                sprite._setDataItem(dataItem);
                sprite.setRaw("position", "absolute");
                this.bulletsContainer.children.push(sprite);
            }
            bullet._index = index;
            bullet.series = this;
            dataItem.bullets.push(bullet);
        }
        return bullet;
    }
    _clearDirty() {
        super._clearDirty();
        this._aggregatesCalculated = false;
        this._selectionAggregatesCalculated = false;
    }
    _prepareChildren() {
        super._prepareChildren();
        let startIndex = this.startIndex();
        let endIndex = this.endIndex();
        if (this.isDirty("heatRules")) {
            this._valuesDirty = true;
        }
        if (this.isPrivateDirty("baseValueSeries")) {
            const baseValueSeries = this.getPrivate("baseValueSeries");
            if (baseValueSeries) {
                this._disposers.push(baseValueSeries.onPrivate("startIndex", () => {
                    this.markDirtyValues();
                }));
            }
        }
        const calculateAggregates = this.get("calculateAggregates");
        if (calculateAggregates) {
            if (this._valuesDirty && !this._dataProcessed) {
                if (!this._aggregatesCalculated) {
                    this._calculateAggregates(0, this.dataItems.length);
                    this._aggregatesCalculated = true;
                }
            }
            if ((this._psi != startIndex || this._pei != endIndex) && !this._selectionAggregatesCalculated) {
                if (startIndex === 0 && endIndex === this.dataItems.length && this._aggregatesCalculated) {
                    // void
                }
                else {
                    this._calculateAggregates(startIndex, endIndex);
                }
                this._selectionAggregatesCalculated = true;
            }
        }
        if (this.isDirty("tooltip")) {
            let tooltip = this.get("tooltip");
            if (tooltip) {
                tooltip.hide(0);
                tooltip.set("tooltipTarget", this);
            }
        }
        if (this.isDirty("fill") || this.isDirty("stroke")) {
            let markerRectangle;
            const legendDataItem = this.get("legendDataItem");
            if (legendDataItem) {
                markerRectangle = legendDataItem.get("markerRectangle");
                if (markerRectangle) {
                    if (this.isVisible()) {
                        if (this.isDirty("stroke")) {
                            let stroke = this.get("stroke");
                            markerRectangle.set("stroke", stroke);
                        }
                        if (this.isDirty("fill")) {
                            let fill = this.get("fill");
                            markerRectangle.set("fill", fill);
                        }
                    }
                }
            }
            this.updateLegendMarker(undefined);
        }
        if (this.bullets.length > 0) {
            let startIndex = this.startIndex();
            let endIndex = this.endIndex();
            if (endIndex < this.dataItems.length) {
                endIndex++;
            }
            for (let i = startIndex; i < endIndex; i++) {
                let dataItem = this.dataItems[i];
                if (!dataItem.bullets) {
                    this._makeBullets(dataItem);
                }
            }
        }
    }
    _calculateAggregates(startIndex, endIndex) {
        let fields = this._valueFields;
        if (!fields) {
            throw new Error("No value fields are set for the series.");
        }
        const sum = {};
        const absSum = {};
        const count = {};
        const low = {};
        const high = {};
        const open = {};
        const close = {};
        const average = {};
        const previous = {};
        _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](fields, (key) => {
            sum[key] = 0;
            absSum[key] = 0;
            count[key] = 0;
        });
        _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](fields, (key) => {
            let change = key + "Change";
            let changePercent = key + "ChangePercent";
            let changePrevious = key + "ChangePrevious";
            let changePreviousPercent = key + "ChangePreviousPercent";
            let changeSelection = key + "ChangeSelection";
            let changeSelectionPercent = key + "ChangeSelectionPercent";
            let openKey = "valueY";
            if (key == "valueX" || key == "openValueX" || key == "lowValueX" || key == "highValueX") {
                openKey = "valueX";
            }
            const baseValueSeries = this.getPrivate("baseValueSeries");
            for (let i = startIndex; i < endIndex; i++) {
                const dataItem = this.dataItems[i];
                let value = dataItem.get(key);
                if (value != null) {
                    count[key]++;
                    sum[key] += value;
                    absSum[key] += Math.abs(value);
                    average[key] = sum[key] / count[key];
                    if (low[key] > value || low[key] == null) {
                        low[key] = value;
                    }
                    if (high[key] < value || high[key] == null) {
                        high[key] = value;
                    }
                    close[key] = value;
                    if (open[key] == null) {
                        open[key] = value;
                        previous[key] = value;
                        if (baseValueSeries) {
                            open[openKey] = baseValueSeries._getBase(openKey);
                        }
                    }
                    if (startIndex === 0) {
                        dataItem.setRaw((change), value - open[openKey]);
                        dataItem.setRaw((changePercent), (value - open[openKey]) / open[openKey] * 100);
                    }
                    dataItem.setRaw((changePrevious), value - previous[openKey]);
                    dataItem.setRaw((changePreviousPercent), (value - previous[openKey]) / previous[openKey] * 100);
                    dataItem.setRaw((changeSelection), value - open[openKey]);
                    dataItem.setRaw((changeSelectionPercent), (value - open[openKey]) / open[openKey] * 100);
                    previous[key] = value;
                }
            }
        });
        _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](fields, (key) => {
            this.setPrivate((key + "AverageSelection"), average[key]);
            this.setPrivate((key + "CountSelection"), count[key]);
            this.setPrivate((key + "SumSelection"), sum[key]);
            this.setPrivate((key + "AbsoluteSumSelection"), absSum[key]);
            this.setPrivate((key + "LowSelection"), low[key]);
            this.setPrivate((key + "HighSelection"), high[key]);
            this.setPrivate((key + "OpenSelection"), open[key]);
            this.setPrivate((key + "CloseSelection"), close[key]);
        });
        if (startIndex === 0 && endIndex === this.dataItems.length) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](fields, (key) => {
                this.setPrivate((key + "Average"), average[key]);
                this.setPrivate((key + "Count"), count[key]);
                this.setPrivate((key + "Sum"), sum[key]);
                this.setPrivate((key + "AbsoluteSum"), absSum[key]);
                this.setPrivate((key + "Low"), low[key]);
                this.setPrivate((key + "High"), high[key]);
                this.setPrivate((key + "Open"), open[key]);
                this.setPrivate((key + "Close"), close[key]);
            });
        }
    }
    _updateChildren() {
        super._updateChildren();
        this._psi = this.startIndex();
        this._pei = this.endIndex();
        if (this.isDirty("visible")) {
            this.bulletsContainer.set("visible", this.get("visible"));
        }
        // Apply heat rules
        const rules = this.get("heatRules");
        if (this._valuesDirty && rules && rules.length > 0) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](rules, (rule) => {
                const minValue = rule.minValue || this.getPrivate((rule.dataField + "Low")) || 0;
                const maxValue = rule.maxValue || this.getPrivate((rule.dataField + "High")) || 0;
                _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](rule.target._entities, (target) => {
                    const value = target.dataItem.get(rule.dataField);
                    if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_7__["isNumber"](value)) {
                        if (rule.neutral) {
                            target.set(rule.key, rule.neutral);
                        }
                        return;
                    }
                    let percent;
                    if (rule.logarithmic) {
                        percent = (Math.log(value) * Math.LOG10E - Math.log(minValue) * Math.LOG10E) / ((Math.log(maxValue) * Math.LOG10E - Math.log(minValue) * Math.LOG10E));
                    }
                    else {
                        percent = (value - minValue) / (maxValue - minValue);
                    }
                    if (_core_util_Type__WEBPACK_IMPORTED_MODULE_7__["isNumber"](value) && (!_core_util_Type__WEBPACK_IMPORTED_MODULE_7__["isNumber"](percent) || Math.abs(percent) == Infinity)) {
                        percent = 0.5;
                    }
                    // fixes problems if all values are the same
                    let propertyValue;
                    if (_core_util_Type__WEBPACK_IMPORTED_MODULE_7__["isNumber"](rule.min)) {
                        propertyValue = rule.min + (rule.max - rule.min) * percent;
                    }
                    else if (rule.min instanceof _core_util_Color__WEBPACK_IMPORTED_MODULE_3__["Color"]) {
                        propertyValue = _core_util_Color__WEBPACK_IMPORTED_MODULE_3__["Color"].interpolate(percent, rule.min, rule.max);
                    }
                    else if (rule.min instanceof _core_util_Percent__WEBPACK_IMPORTED_MODULE_5__["Percent"]) {
                        propertyValue = Object(_core_util_Animation__WEBPACK_IMPORTED_MODULE_4__["percentInterpolate"])(percent, rule.min, rule.max);
                    }
                    if (rule.customFunction) {
                        rule.customFunction.call(this, target, minValue, maxValue, value);
                    }
                    else {
                        target.set(rule.key, propertyValue);
                    }
                });
            });
        }
        if (this.bullets.length > 0) {
            let count = this.dataItems.length;
            let startIndex = this.startIndex();
            let endIndex = this.endIndex();
            if (endIndex < count) {
                endIndex++;
            }
            if (startIndex > 0) {
                startIndex--;
            }
            for (let i = 0; i < startIndex; i++) {
                this._hideBullets(this.dataItems[i]);
            }
            for (let i = startIndex; i < endIndex; i++) {
                this._positionBullets(this.dataItems[i]);
            }
            for (let i = endIndex; i < count; i++) {
                this._hideBullets(this.dataItems[i]);
            }
        }
    }
    _positionBullets(dataItem) {
        if (dataItem.bullets) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](dataItem.bullets, (bullet) => {
                this._positionBullet(bullet);
                const sprite = bullet.get("sprite");
                if (bullet.get("dynamic")) {
                    if (sprite) {
                        sprite._markDirtyKey("fill");
                        sprite.markDirtySize();
                    }
                    if (sprite instanceof _core_render_Container__WEBPACK_IMPORTED_MODULE_9__["Container"]) {
                        sprite.walkChildren((child) => {
                            child._markDirtyKey("fill");
                            child.markDirtySize();
                            if (child instanceof _core_render_Label__WEBPACK_IMPORTED_MODULE_10__["Label"]) {
                                child.text.markDirtyText();
                            }
                        });
                    }
                }
                if (sprite instanceof _core_render_Label__WEBPACK_IMPORTED_MODULE_10__["Label"] && sprite.get("populateText")) {
                    sprite.text.markDirtyText();
                }
            });
        }
    }
    _hideBullets(dataItem) {
        if (dataItem.bullets) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](dataItem.bullets, (bullet) => {
                let sprite = bullet.get("sprite");
                if (sprite) {
                    sprite.setPrivate("visible", false);
                }
            });
        }
    }
    _positionBullet(_bullet) {
    }
    _placeBulletsContainer(chart) {
        chart.bulletsContainer.children.moveValue(this.bulletsContainer);
    }
    _removeBulletsContainer() {
        const bulletsContainer = this.bulletsContainer;
        if (bulletsContainer.parent) {
            bulletsContainer.parent.children.removeValue(bulletsContainer);
        }
    }
    /**
     * @ignore
     */
    disposeDataItem(dataItem) {
        //super.disposeDataItem(dataItem); // does nothing
        const bullets = dataItem.bullets;
        if (bullets) {
            _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](bullets, (bullet) => {
                bullet.dispose();
            });
        }
    }
    _getItemReaderLabel() {
        return "";
    }
    /**
     * Shows series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    showDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            showDataItem: { get: () => super.showDataItem }
        });
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const promises = [_super.showDataItem.call(this, dataItem, duration)];
            const bullets = dataItem.bullets;
            if (bullets) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](bullets, (bullet) => {
                    promises.push(bullet.get("sprite").show(duration));
                });
            }
            yield Promise.all(promises);
        });
    }
    /**
     * Hides series's data item.
     *
     * @param   dataItem  Data item
     * @param   duration  Animation duration in milliseconds
     * @return            Promise
     */
    hideDataItem(dataItem, duration) {
        const _super = Object.create(null, {
            hideDataItem: { get: () => super.hideDataItem }
        });
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            const promises = [_super.hideDataItem.call(this, dataItem, duration)];
            const bullets = dataItem.bullets;
            if (bullets) {
                _core_util_Array__WEBPACK_IMPORTED_MODULE_6__["each"](bullets, (bullet) => {
                    promises.push(bullet.get("sprite").hide(duration));
                });
            }
            yield Promise.all(promises);
        });
    }
    _sequencedShowHide(show, duration) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            if (this.get("sequencedInterpolation")) {
                if (!_core_util_Type__WEBPACK_IMPORTED_MODULE_7__["isNumber"](duration)) {
                    duration = this.get("interpolationDuration", 0);
                }
                if (duration > 0) {
                    const startIndex = this.startIndex();
                    const endIndex = this.endIndex();
                    yield Promise.all(_core_util_Array__WEBPACK_IMPORTED_MODULE_6__["map"](this.dataItems, (dataItem, i) => Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
                        let realDuration = duration || 0;
                        if (i < startIndex - 10 || i > endIndex + 10) {
                            realDuration = 0;
                        }
                        //let delay = this.get("sequencedDelay", 0) * i + realDuration * (i - startIndex) / (endIndex - startIndex);
                        let delay = this.get("sequencedDelay", 0) + realDuration / (endIndex - startIndex);
                        yield _core_util_Time__WEBPACK_IMPORTED_MODULE_8__["sleep"](delay * (i - startIndex));
                        if (show) {
                            yield this.showDataItem(dataItem, realDuration);
                        }
                        else {
                            yield this.hideDataItem(dataItem, realDuration);
                        }
                    })));
                }
                else {
                    yield Promise.all(_core_util_Array__WEBPACK_IMPORTED_MODULE_6__["map"](this.dataItems, (dataItem) => {
                        if (show) {
                            return this.showDataItem(dataItem, 0);
                        }
                        else {
                            return this.hideDataItem(dataItem, 0);
                        }
                    }));
                }
            }
        });
    }
    /**
     * @ignore
     */
    updateLegendValue(dataItem) {
        if (dataItem) {
            const legendDataItem = dataItem.get("legendDataItem");
            if (legendDataItem) {
                const valueLabel = legendDataItem.get("valueLabel");
                if (valueLabel) {
                    const text = valueLabel.text;
                    let txt = "";
                    valueLabel._setDataItem(dataItem);
                    txt = this.get("legendValueText", text.get("text", ""));
                    valueLabel.set("text", txt);
                    text.markDirtyText();
                }
                const label = legendDataItem.get("label");
                if (label) {
                    const text = label.text;
                    let txt = "";
                    label._setDataItem(dataItem);
                    txt = this.get("legendLabelText", text.get("text", ""));
                    label.set("text", txt);
                    text.markDirtyText();
                }
            }
        }
    }
    /**
     * @ignore
     */
    updateLegendMarker(_dataItem) {
    }
    _onHide() {
        super._onHide();
        const tooltip = this.getTooltip();
        if (tooltip) {
            tooltip.hide();
        }
    }
    /**
     * @ignore
     */
    hoverDataItem(_dataItem) { }
    /**
     * @ignore
     */
    unhoverDataItem(_dataItem) { }
    /**
     * @ignore
     */
    _getBase(key) {
        const dataItem = this.dataItems[this.startIndex()];
        if (dataItem) {
            return dataItem.get(key);
        }
        return 0;
    }
}
Object.defineProperty(Series, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Series"
});
Object.defineProperty(Series, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _core_render_Component__WEBPACK_IMPORTED_MODULE_1__["Component"].classNames.concat([Series.className])
});
//# sourceMappingURL=Series.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Slice.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Slice.js ***!
  \*************************************************************************/
/*! exports provided: Slice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Slice", function() { return Slice; });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/index.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");





/**
 * Draws a slice shape.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 */
class Slice extends _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"] {
    constructor() {
        super(...arguments);
        /**
         * @ignore
         */
        Object.defineProperty(this, "ix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * @ignore
         */
        Object.defineProperty(this, "iy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_generator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__["arc"])()
        });
    }
    _getTooltipPoint() {
        let tooltipX = this.get("tooltipX");
        let tooltipY = this.get("tooltipY");
        let x = 0;
        let y = 0;
        if (_util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](tooltipX)) {
            x = tooltipX;
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](tooltipY)) {
            y = tooltipY;
        }
        let radius = this.get("radius", 0);
        let innerRadius = this.get("innerRadius", 0);
        let dRadius = this.get("dRadius", 0);
        let dInnerRadius = this.get("dInnerRadius", 0);
        radius += dRadius;
        innerRadius += dInnerRadius;
        if (innerRadius < 0) {
            innerRadius = radius + innerRadius;
        }
        if (tooltipX instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_2__["Percent"]) {
            x = this.ix * (innerRadius + (radius - innerRadius) * tooltipX.value);
        }
        if (tooltipY instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_2__["Percent"]) {
            y = this.iy * (innerRadius + (radius - innerRadius) * tooltipY.value);
        }
        if (this.get("arc") >= 360 && innerRadius == 0) {
            x = 0;
            y = 0;
        }
        return { x, y };
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("radius") || this.isDirty("arc") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("dRadius") || this.isDirty("dInnerRadius") || this.isDirty("cornerRadius")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            let startAngle = this.get("startAngle", 0);
            let arc = this.get("arc", 0);
            const generator = this._generator;
            if (arc < 0) {
                startAngle = startAngle + arc;
                arc = arc * -1;
            }
            if (arc > 0.1) { // this fixes bug with full circle when arc is very small
                generator.cornerRadius(this.get("cornerRadius", 0));
            }
            generator.context(this._display);
            let radius = this.get("radius", 0);
            let innerRadius = this.get("innerRadius", 0);
            let dRadius = this.get("dRadius", 0);
            let dInnerRadius = this.get("dInnerRadius", 0);
            radius += dRadius;
            innerRadius += dInnerRadius;
            if (innerRadius < 0) {
                innerRadius = radius + innerRadius;
            }
            generator({ innerRadius: innerRadius, outerRadius: radius, startAngle: (startAngle + 90) * _util_Math__WEBPACK_IMPORTED_MODULE_4__["RADIANS"], endAngle: (startAngle + arc + 90) * _util_Math__WEBPACK_IMPORTED_MODULE_4__["RADIANS"] });
            let middleAngle = startAngle + arc / 2;
            this.ix = _util_Math__WEBPACK_IMPORTED_MODULE_4__["cos"](middleAngle);
            this.iy = _util_Math__WEBPACK_IMPORTED_MODULE_4__["sin"](middleAngle);
        }
        if (this.isDirty("shiftRadius")) {
            const shiftRadius = this.get("shiftRadius", 0);
            this.setRaw("dx", this.ix * shiftRadius);
            this.setRaw("dy", this.iy * shiftRadius);
            this.markDirtyPosition();
        }
    }
}
Object.defineProperty(Slice, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Slice"
});
Object.defineProperty(Slice, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"].classNames.concat([Slice.className])
});
//# sourceMappingURL=Slice.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Slider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Slider.js ***!
  \**************************************************************************/
/*! exports provided: Slider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Slider", function() { return Slider; });
/* harmony import */ var _Scrollbar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scrollbar */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Scrollbar.js");

/**
 * A control that allows zooming chart's axes, or other uses requiring range
 * selection.
 */
class Slider extends _Scrollbar__WEBPACK_IMPORTED_MODULE_0__["Scrollbar"] {
    _afterNew() {
        this._addOrientationClass();
        super._afterNew();
        this.endGrip.setPrivate("visible", false);
        this.thumb.setPrivate("visible", false);
    }
    /**
     * @ignore
     */
    updateGrips() {
        super.updateGrips();
        const startGrip = this.startGrip;
        this.endGrip.setAll({ x: startGrip.x(), y: startGrip.y() });
        this.setRaw("end", this.get("start"));
    }
}
Object.defineProperty(Slider, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Slider"
});
Object.defineProperty(Slider, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Scrollbar__WEBPACK_IMPORTED_MODULE_0__["Scrollbar"].classNames.concat([Slider.className])
});
//# sourceMappingURL=Slider.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js ***!
  \**************************************************************************/
/*! exports provided: Sprite */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/@amcharts/amcharts5/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _util_Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _util_Template__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _util_EventDispatcher__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _util_Disposer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _util_Animation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Animation */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Object__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");












//import { populateString } from "../util/PopulateString";
/**
 * An [[EventDispatcher]] for [[Sprite]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
 */
class SpriteEventDispatcher extends _util_EventDispatcher__WEBPACK_IMPORTED_MODULE_4__["EventDispatcher"] {
    constructor(sprite) {
        super();
        Object.defineProperty(this, "_sprite", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_rendererDisposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dispatchParents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        this._sprite = sprite;
    }
    _makePointerEvent(key, event) {
        return {
            type: key,
            originalEvent: event.event,
            point: event.point,
            simulated: event.simulated,
            native: event.native,
            target: this._sprite
        };
    }
    _onRenderer(key, dispatch) {
        // TODO: is this OK? it'd be good not to require to set this on each individual element
        this._sprite.set("interactive", true);
        this._sprite._display.interactive = true;
        let events = this._rendererDisposers[key];
        if (events === undefined) {
            const disposer = this._sprite._display.on(key, (e) => {
                dispatch.call(this, e);
            });
            events = this._rendererDisposers[key] = new _util_Disposer__WEBPACK_IMPORTED_MODULE_5__["CounterDisposer"](() => {
                delete this._rendererDisposers[key];
                disposer.dispose();
            });
        }
        return events.increment();
    }
    _on(once, type, callback, context, shouldClone, dispatch) {
        const info = super._on(once, type, callback, context, shouldClone, dispatch);
        const rendererEvent = SpriteEventDispatcher.RENDERER_EVENTS[type];
        if (rendererEvent !== undefined) {
            info.disposer = new _util_Disposer__WEBPACK_IMPORTED_MODULE_5__["MultiDisposer"]([
                info.disposer,
                this._onRenderer(type, rendererEvent),
            ]);
        }
        return info;
    }
    /**
     * Will stop any bubbling up of the event to element's parents.
     *
     * Should be called in an event handler, e.g.:
     *
     * ```TypeScript
     * element.events.on("pointerdown", function(ev) {
     *   // Do something here and prevent from "pointerdown" bubbling up
     *   // ...
     *   ev.target.events.stopParentDispatch();
     * });
     * ```
     * ```JavaScript
     * element.events.on("pointerdown", function(ev) {
     *   // Do something here and prevent from "pointerdown" bubbling up
     *   // ...
     *   ev.target.events.stopParentDispatch();
     * });
     * ```
     */
    stopParentDispatch() {
        this._dispatchParents = false;
    }
    /**
     * @ignore
     */
    dispatchParents(type, event) {
        const old = this._dispatchParents;
        this._dispatchParents = true;
        try {
            this.dispatch(type, event);
            if (this._dispatchParents && this._sprite.parent) {
                this._sprite.parent.events.dispatchParents(type, event);
            }
        }
        finally {
            this._dispatchParents = old;
        }
    }
}
Object.defineProperty(SpriteEventDispatcher, "RENDERER_EVENTS", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        "click": function (event) {
            if (this.isEnabled("click") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent("click", event))) {
                this.dispatch("click", this._makePointerEvent("click", event));
            }
        },
        "rightclick": function (event) {
            if (this.isEnabled("rightclick")) {
                this.dispatch("rightclick", this._makePointerEvent("rightclick", event));
            }
        },
        "middleclick": function (event) {
            if (this.isEnabled("middleclick")) {
                this.dispatch("middleclick", this._makePointerEvent("middleclick", event));
            }
        },
        "dblclick": function (event) {
            this.dispatchParents("dblclick", this._makePointerEvent("dblclick", event));
        },
        "pointerover": function (event) {
            if (this.isEnabled("pointerover")) {
                this.dispatch("pointerover", this._makePointerEvent("pointerover", event));
            }
        },
        "pointerout": function (event) {
            if (this.isEnabled("pointerout")) {
                this.dispatch("pointerout", this._makePointerEvent("pointerout", event));
            }
        },
        "pointerdown": function (event) {
            this.dispatchParents("pointerdown", this._makePointerEvent("pointerdown", event));
        },
        "pointerup": function (event) {
            if (this.isEnabled("pointerup")) {
                this.dispatch("pointerup", this._makePointerEvent("pointerup", event));
            }
        },
        "globalpointerup": function (event) {
            if (this.isEnabled("globalpointerup")) {
                this.dispatch("globalpointerup", this._makePointerEvent("globalpointerup", event));
            }
        },
        "globalpointermove": function (event) {
            if (this.isEnabled("globalpointermove")) {
                this.dispatch("globalpointermove", this._makePointerEvent("globalpointermove", event));
            }
        },
        "wheel": function (event) {
            this.dispatchParents("wheel", {
                type: "wheel",
                target: this._sprite,
                originalEvent: event.event,
                point: event.point,
            });
        },
    }
});
/**
 * A base class for all visual elements.
 *
 * @important
 */
class Sprite extends _util_Entity__WEBPACK_IMPORTED_MODULE_1__["Entity"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_adjustedLocalBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { left: 0, right: 0, top: 0, bottom: 0 }
        });
        Object.defineProperty(this, "_localBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { left: 0, right: 0, top: 0, bottom: 0 }
        });
        Object.defineProperty(this, "_parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_dataItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_templateField", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_sizeDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // Will be true only when dragging
        Object.defineProperty(this, "_isDragging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // The event when the dragging starts
        Object.defineProperty(this, "_dragEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // The position when dragging starts
        Object.defineProperty(this, "_dragPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isHidden", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_isShowing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_isHiding", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_isDown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_downPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_downPoints", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_toggleDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_dragDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_hoverDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_focusDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipMoveDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tooltipPointerDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_statesHandled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _afterNew() {
        this.setPrivateRaw("visible", true);
        super._afterNew();
    }
    _markDirtyKey(key) {
        super._markDirtyKey(key);
        if (key == "x" || key == "y" || key == "dx" || key == "dy") {
            this.markDirtyBounds();
            this._addPercentagePositionChildren();
            this.markDirtyPosition();
        }
    }
    _markDirtyPrivateKey(key) {
        super._markDirtyPrivateKey(key);
        if (key == "x" || key == "y") {
            this.markDirtyPosition();
        }
    }
    _removeTemplateField() {
        if (this._templateField) {
            this._templateField._removeObjectTemplate(this);
        }
    }
    _createEvents() {
        return new SpriteEventDispatcher(this);
    }
    _processTemplateField() {
        let template;
        const field = this.get("templateField");
        if (field) {
            const dataItem = this.dataItem;
            if (dataItem) {
                const context = dataItem.dataContext;
                if (context) {
                    template = context[field];
                    if (!(template instanceof _util_Template__WEBPACK_IMPORTED_MODULE_2__["Template"]) && template) {
                        template = _util_Template__WEBPACK_IMPORTED_MODULE_2__["Template"].new(template);
                    }
                }
            }
        }
        if (this._templateField !== template) {
            this._removeTemplateField();
            this._templateField = template;
            if (template) {
                template._setObjectTemplate(this);
            }
            this._applyTemplates();
        }
    }
    // TODO change this to run before the element is added to the parent, so that way
    //      it doesn't need to apply the themes twice
    _setDataItem(dataItem) {
        const oldDataItem = this._dataItem;
        this._dataItem = dataItem;
        this._processTemplateField();
        const eventType = "dataitemchanged";
        if (dataItem != oldDataItem) {
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, {
                    type: eventType,
                    target: this,
                    oldDataItem: oldDataItem,
                    newDataItem: dataItem
                });
            }
        }
    }
    /**
     * A [[DataItem]] used for this element.
     *
     * NOTE: data item is being assigned automatically in most cases where it
     * matters. Use this accessor to set data item only if you know what you're
     * doing.
     *
     * @param  value  Data item
     */
    set dataItem(value) {
        this._setDataItem(value);
    }
    /**
     * @return DataItem
     */
    get dataItem() {
        if (this._dataItem) {
            return this._dataItem;
        }
        else {
            let parent = this._parent;
            while (parent) {
                if (parent._dataItem) {
                    return parent._dataItem;
                }
                else {
                    parent = parent._parent;
                }
            }
        }
    }
    _addPercentageSizeChildren() {
        let parent = this.parent;
        if (parent) {
            if (this.get("width") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"] || this.get("height") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) {
                _util_Array__WEBPACK_IMPORTED_MODULE_8__["pushOne"](parent._percentageSizeChildren, this);
            }
            else {
                _util_Array__WEBPACK_IMPORTED_MODULE_8__["removeFirst"](parent._percentageSizeChildren, this);
            }
        }
    }
    _addPercentagePositionChildren() {
        let parent = this.parent;
        if (parent) {
            if (this.get("x") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"] || this.get("y") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) {
                _util_Array__WEBPACK_IMPORTED_MODULE_8__["pushOne"](parent._percentagePositionChildren, this);
            }
            else {
                _util_Array__WEBPACK_IMPORTED_MODULE_8__["removeFirst"](parent._percentagePositionChildren, this);
            }
        }
    }
    /**
     * @ignore
     */
    markDirtyPosition() {
        this._root._addDirtyPosition(this);
    }
    updatePivotPoint() {
        const bounds = this._localBounds;
        if (bounds) {
            const centerX = this.get("centerX");
            if (centerX != null) {
                this._display.pivot.x = bounds.left + _util_Utils__WEBPACK_IMPORTED_MODULE_7__["relativeToValue"](centerX, bounds.right - bounds.left);
            }
            const centerY = this.get("centerY");
            if (centerY != null) {
                this._display.pivot.y = bounds.top + _util_Utils__WEBPACK_IMPORTED_MODULE_7__["relativeToValue"](centerY, bounds.bottom - bounds.top);
            }
        }
    }
    _beforeChanged() {
        super._beforeChanged();
        // handling states in beforeChanged, otherwise states is not applied without animated theme
        this._handleStates();
        if (this.isDirty("tooltip")) {
            const previous = this._prevSettings.tooltip;
            if (previous) {
                previous.dispose();
            }
        }
        if (this.isDirty("layer") || this.isDirty("layerMargin")) {
            this._display.setLayer(this.get("layer"), this.get("layerMargin"));
            this.markDirtyLayer();
        }
        if (this.isDirty("tooltipPosition")) {
            const tooltipMoveDp = this._tooltipMoveDp;
            if (tooltipMoveDp) {
                tooltipMoveDp.dispose();
                this._tooltipMoveDp = undefined;
            }
            const tooltipPointerDp = this._tooltipPointerDp;
            if (tooltipPointerDp) {
                tooltipPointerDp.dispose();
                this._tooltipPointerDp = undefined;
            }
            if (this.get("tooltipPosition") == "pointer") {
                this._tooltipPointerDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_5__["MultiDisposer"]([
                    this.events.on("pointerover", () => {
                        this._tooltipMoveDp = this.events.on("globalpointermove", (e) => {
                            this.showTooltip(e.point);
                        });
                    }),
                    this.events.on("pointerout", () => {
                        const tooltipMoveDp = this._tooltipMoveDp;
                        if (tooltipMoveDp) {
                            tooltipMoveDp.dispose();
                            this._tooltipMoveDp = undefined;
                        }
                    })
                ]);
            }
        }
    }
    _handleStates() {
        if (!this._statesHandled) {
            if (this.isDirty("active")) {
                if (this.get("active")) {
                    this.states.applyAnimate("active");
                    this.set("ariaChecked", true);
                }
                else {
                    if (!this.isHidden()) {
                        this.states.applyAnimate("default");
                    }
                    this.set("ariaChecked", false);
                }
                this.markDirtyAccessibility();
            }
            if (this.isDirty("disabled")) {
                if (this.get("disabled")) {
                    this.states.applyAnimate("disabled");
                    this.set("ariaChecked", false);
                }
                else {
                    if (!this.isHidden()) {
                        this.states.applyAnimate("default");
                    }
                    this.set("ariaChecked", true);
                }
                this.markDirtyAccessibility();
            }
            this._statesHandled = true;
        }
    }
    _changed() {
        super._changed();
        const display = this._display;
        const events = this.events;
        if (this.isDirty("draggable")) {
            const draggable = this.get("draggable");
            if (draggable) {
                this.set("interactive", true);
                this._dragDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_5__["MultiDisposer"]([
                    events.on("pointerdown", (ev) => {
                        this.dragStart(ev);
                    }),
                    events.on("globalpointermove", (ev) => {
                        this.dragMove(ev);
                    }),
                    events.on("globalpointerup", (ev) => {
                        this.dragStop(ev);
                    })
                ]);
            }
            else {
                if (this._dragDp) {
                    this._dragDp.dispose();
                    this._dragDp = undefined;
                }
            }
            display.cancelTouch = draggable ? true : false;
        }
        if (this.isDirty("tooltipText") || this.isDirty("tooltipHTML") || this.isDirty("showTooltipOn")) {
            const tooltipText = this.get("tooltipText");
            const tooltipHTML = this.get("tooltipHTML");
            const showTooltipOn = this.get("showTooltipOn", "hover");
            if (this._tooltipDp) {
                this._tooltipDp.dispose();
                this._tooltipDp = undefined;
            }
            if (tooltipText || tooltipHTML) {
                if (showTooltipOn == "click") {
                    this._tooltipDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_5__["MultiDisposer"]([
                        events.on("click", () => {
                            this.setTimeout(() => this.showTooltip(), 10);
                        }),
                        _util_Utils__WEBPACK_IMPORTED_MODULE_7__["addEventListener"](document, "click", (_ev) => {
                            this.hideTooltip();
                        })
                    ]);
                }
                else if (showTooltipOn == "always") {
                    // nothing
                }
                else {
                    this._tooltipDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_5__["MultiDisposer"]([
                        events.on("pointerover", () => {
                            this.showTooltip();
                        }),
                        events.on("pointerout", () => {
                            this.hideTooltip();
                        })
                    ]);
                }
            }
        }
        if (this.isDirty("toggleKey")) {
            let toggleKey = this.get("toggleKey");
            if (toggleKey && toggleKey != "none") {
                this._toggleDp = events.on("click", () => {
                    if (!this._isDragging) {
                        this.set(toggleKey, !this.get(toggleKey));
                    }
                });
            }
            else {
                if (this._toggleDp) {
                    this._toggleDp.dispose();
                    this._toggleDp = undefined;
                }
            }
        }
        if (this.isDirty("opacity")) {
            display.alpha = Math.max(0, this.get("opacity", 1));
        }
        if (this.isDirty("rotation")) {
            this.markDirtyBounds();
            display.angle = this.get("rotation", 0);
        }
        if (this.isDirty("scale")) {
            this.markDirtyBounds();
            display.scale = this.get("scale", 0);
        }
        if (this.isDirty("centerX") || this.isDirty("centerY")) {
            this.markDirtyBounds();
            this.updatePivotPoint();
        }
        if (this.isDirty("visible") || this.isPrivateDirty("visible") || this.isDirty("forceHidden")) {
            if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) {
                display.visible = false;
                this.hideTooltip();
            }
            else {
                display.visible = true;
            }
            this.markDirtyBounds();
            if (this.get("focusable")) {
                this.markDirtyAccessibility();
            }
        }
        if (this.isDirty("width") || this.isDirty("height")) {
            this.markDirtyBounds();
            this._addPercentageSizeChildren();
            const parent = this.parent;
            if (parent) {
                if ((this.isDirty("width") && this.get("width") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) || (this.isDirty("height") && this.get("height") instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"])) {
                    parent.markDirty();
                    parent._prevWidth = 0;
                }
            }
            this._sizeDirty = true;
        }
        if (this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("minWidth") || this.isDirty("minHeight") || this.isPrivateDirty("maxWidth") || this.isPrivateDirty("maxHeight") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) {
            this.markDirtyBounds();
            this._sizeDirty = true;
        }
        if (this._sizeDirty) {
            this._updateSize();
        }
        if (this.isDirty("wheelable")) {
            const wheelable = this.get("wheelable");
            if (wheelable) {
                this.set("interactive", true);
            }
            display.wheelable = wheelable ? true : false;
        }
        // Accessibility
        if (this.isDirty("tabindexOrder") || this.isDirty("focusableGroup")) {
            if (this.get("focusable")) {
                this._root._registerTabindexOrder(this);
            }
            else {
                this._root._unregisterTabindexOrder(this);
            }
        }
        if (this.isDirty("filter")) {
            //this.markDirtyBounds();
            display.filter = this.get("filter");
        }
        if (this.isDirty("cursorOverStyle")) {
            display.cursorOverStyle = this.get("cursorOverStyle");
        }
        if (this.isDirty("hoverOnFocus")) {
            if (this.get("hoverOnFocus")) {
                this._focusDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_5__["MultiDisposer"]([
                    events.on("focus", () => {
                        // TODO: proper hover, not just tooltip
                        this.showTooltip();
                    }),
                    events.on("blur", () => {
                        // TODO: proper hover, not just tooltip
                        this.hideTooltip();
                    })
                ]);
            }
            else {
                if (this._focusDp) {
                    this._focusDp.dispose();
                    this._focusDp = undefined;
                }
            }
        }
        if (this.isDirty("focusable")) {
            if (this.get("focusable")) {
                this._root._registerTabindexOrder(this);
            }
            else {
                this._root._unregisterTabindexOrder(this);
            }
            this.markDirtyAccessibility();
        }
        if (this.isDirty("role") || this.isDirty("ariaLive") || this.isDirty("ariaChecked") || this.isDirty("ariaHidden") || this.isDirty("ariaOrientation") || this.isDirty("ariaValueNow") || this.isDirty("ariaValueMin") || this.isDirty("ariaValueMax") || this.isDirty("ariaValueText") || this.isDirty("ariaLabel") || this.isDirty("ariaControls")) {
            // display.accessibility.ariaLabel = populateString(this, this.get("ariaLabel", ""));
            // @todo make sure ariaLabel gets populated in Root
            this.markDirtyAccessibility();
        }
        if (this.isDirty("exportable")) {
            display.exportable = this.get("exportable");
        }
        if (this.isDirty("interactive")) {
            const events = this.events;
            if (this.get("interactive")) {
                this._hoverDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_5__["MultiDisposer"]([
                    events.on("click", (ev) => {
                        if (_util_Utils__WEBPACK_IMPORTED_MODULE_7__["isTouchEvent"](ev.originalEvent)) {
                            if (!this.getPrivate("touchHovering")) {
                                this.setTimeout(() => {
                                    this._handleOver();
                                    if (this.get("tooltipText") || this.get("tooltipHTML")) {
                                        this.showTooltip();
                                    }
                                    this.setPrivateRaw("touchHovering", true);
                                    this.events.dispatch("pointerover", {
                                        type: "pointerover",
                                        target: ev.target,
                                        originalEvent: ev.originalEvent,
                                        point: ev.point,
                                        simulated: ev.simulated
                                    });
                                }, 10);
                            }
                        }
                    }),
                    events.on("globalpointerup", (ev) => {
                        if (_util_Utils__WEBPACK_IMPORTED_MODULE_7__["isTouchEvent"](ev.originalEvent)) {
                            if (this.getPrivate("touchHovering")) {
                                this._handleOut();
                                if (this.get("tooltipText") || this.get("tooltipHTML")) {
                                    this.hideTooltip();
                                }
                            }
                            this.setPrivateRaw("touchHovering", false);
                            this.events.dispatch("pointerout", {
                                type: "pointerout",
                                target: ev.target,
                                originalEvent: ev.originalEvent,
                                point: ev.point,
                                simulated: ev.simulated
                            });
                        }
                        if (this._isDown) {
                            this._handleUp(ev);
                        }
                        //this._isDown = false;
                    }),
                    events.on("pointerover", () => {
                        this._handleOver();
                    }),
                    events.on("pointerout", () => {
                        this._handleOut();
                    }),
                    events.on("pointerdown", (e) => {
                        this._handleDown(e);
                    })
                ]);
            }
            else {
                this._display.interactive = false;
                if (this._hoverDp) {
                    this._hoverDp.dispose();
                    this._hoverDp = undefined;
                }
            }
        }
        if (this.isDirty("forceInactive")) {
            this._display.inactive = this.get("forceInactive", false);
        }
        if (this.get("showTooltipOn") == "always" && this._display.visible) {
            this.showTooltip();
        }
    }
    /**
     * @ignore
     * @todo should this be user-accessible?
     */
    dragStart(e) {
        this._dragEvent = e;
        this.events.stopParentDispatch();
    }
    /**
     * @ignore
     * @todo should this be user-accessible?
     */
    dragStop(e) {
        this._dragEvent = undefined;
        this._dragPoint = undefined;
        this.events.stopParentDispatch();
        if (this._isDragging) {
            this._isDragging = false;
            const type = "dragstop";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, {
                    type: type,
                    target: this,
                    originalEvent: e.originalEvent,
                    point: e.point,
                    simulated: e.simulated,
                });
            }
        }
    }
    _handleOver() {
        if (!this.isHidden()) {
            if (this.get("active") && this.states.lookup("hoverActive")) {
                this.states.applyAnimate("hoverActive");
            }
            else if (this.get("disabled") && this.states.lookup("hoverDisabled")) {
                this.states.applyAnimate("hoverDisabled");
            }
            else {
                this.states.applyAnimate("hover");
            }
            if (this.get("draggable") && this._isDown && this.states.lookup("down")) {
                this.states.applyAnimate("down");
            }
        }
    }
    _handleOut() {
        if (!this.isHidden()) {
            if (this.get("active") && this.states.lookup("active")) {
                this.states.applyAnimate("active");
            }
            else if (this.get("disabled") && this.states.lookup("disabled")) {
                this.states.applyAnimate("disabled");
            }
            else {
                if (this.states.lookup("hover") || this.states.lookup("hoverActive")) {
                    this.states.applyAnimate("default");
                }
            }
            if (this.get("draggable") && this._isDown && this.states.lookup("down")) {
                this.states.applyAnimate("down");
            }
        }
    }
    _handleUp(e) {
        if (!this.isHidden()) {
            if (this.get("active") && this.states.lookup("active")) {
                this.states.applyAnimate("active");
            }
            else if (this.get("disabled") && this.states.lookup("disabled")) {
                this.states.applyAnimate("disabled");
            }
            else if (this.states.lookup("down")) {
                if (this.isHover()) {
                    this.states.applyAnimate("hover");
                }
                else {
                    this.states.applyAnimate("default");
                }
            }
            // @todo remove this once migrated to _downPoints
            this._downPoint = undefined;
            const pointerId = _util_Utils__WEBPACK_IMPORTED_MODULE_7__["getPointerId"](e.originalEvent);
            delete this._downPoints[pointerId];
            if (_util_Object__WEBPACK_IMPORTED_MODULE_10__["keys"](this._downPoints).length == 0) {
                this._isDown = false;
            }
        }
    }
    _hasMoved(e) {
        // @todo remove this once migrated to _downPoints
        // if (this._downPoint) {
        // 	const x = Math.abs(this._downPoint.x - e.point.x);
        // 	const y = Math.abs(this._downPoint.y - e.point.y);
        // 	return (x > 5) || (y > 5);
        // }
        const pointerId = _util_Utils__WEBPACK_IMPORTED_MODULE_7__["getPointerId"](e.originalEvent);
        const downPoint = this._downPoints[pointerId];
        if (downPoint) {
            const x = Math.abs(downPoint.x - e.point.x);
            const y = Math.abs(downPoint.y - e.point.y);
            return (x > 5) || (y > 5);
        }
        return false;
    }
    _hasDown() {
        return _util_Object__WEBPACK_IMPORTED_MODULE_10__["keys"](this._downPoints).length > 0;
    }
    _handleDown(e) {
        const parent = this.parent;
        if (parent && !this.get("draggable")) {
            parent._handleDown(e);
        }
        if (this.get("interactive") && !this.isHidden()) {
            if (this.states.lookup("down")) {
                this.states.applyAnimate("down");
            }
            this._downPoint = {
                x: e.point.x,
                y: e.point.y
            };
            // @todo remove this once migrated to _downPoints
            this._isDown = true;
            const pointerId = _util_Utils__WEBPACK_IMPORTED_MODULE_7__["getPointerId"](e.originalEvent);
            this._downPoints[pointerId] = {
                x: e.point.x,
                y: e.point.y
            };
        }
    }
    /**
     * @ignore
     * @todo should this be user-accessible?
     */
    dragMove(e) {
        let dragEvent = this._dragEvent;
        if (dragEvent) {
            if (dragEvent.simulated && !e.simulated) {
                return true;
            }
            let angle = 0;
            let parent = this.parent;
            while (parent != null) {
                angle += parent.get("rotation", 0);
                parent = parent.parent;
            }
            let x = e.point.x - dragEvent.point.x;
            let y = e.point.y - dragEvent.point.y;
            const events = this.events;
            if (dragEvent.simulated && !this._isDragging) {
                this._isDragging = true;
                this._dragEvent = e;
                this._dragPoint = {
                    x: this.x(),
                    y: this.y()
                };
                const type = "dragstart";
                if (events.isEnabled(type)) {
                    events.dispatch(type, {
                        type: type,
                        target: this,
                        originalEvent: e.originalEvent,
                        point: e.point,
                        simulated: e.simulated,
                    });
                }
            }
            if (this._isDragging) {
                let dragPoint = this._dragPoint;
                this.set("x", dragPoint.x + x * _util_Math__WEBPACK_IMPORTED_MODULE_11__["cos"](angle) + y * _util_Math__WEBPACK_IMPORTED_MODULE_11__["sin"](angle));
                this.set("y", dragPoint.y + y * _util_Math__WEBPACK_IMPORTED_MODULE_11__["cos"](angle) - x * _util_Math__WEBPACK_IMPORTED_MODULE_11__["sin"](angle));
                const type = "dragged";
                if (events.isEnabled(type)) {
                    events.dispatch(type, {
                        type: type,
                        target: this,
                        originalEvent: e.originalEvent,
                        point: e.point,
                        simulated: e.simulated,
                    });
                }
            }
            else {
                if (Math.hypot(x, y) > 5) {
                    this._isDragging = true;
                    this._dragEvent = e;
                    this._dragPoint = {
                        x: this.x(),
                        y: this.y()
                    };
                    const type = "dragstart";
                    if (events.isEnabled(type)) {
                        events.dispatch(type, {
                            type: type,
                            target: this,
                            originalEvent: e.originalEvent,
                            point: e.point,
                            simulated: e.simulated
                        });
                    }
                }
            }
        }
    }
    _updateSize() {
    }
    _getBounds() {
        this._localBounds = this._display.getLocalBounds();
    }
    /**
     * Returns depth (how deep in the hierachy of the content tree) of this
     * element.
     *
     * @return Depth
     */
    depth() {
        let self = this.parent;
        let depth = 0;
        while (true) {
            if (self) {
                ++depth;
                self = self.parent;
            }
            else {
                return depth;
            }
        }
    }
    /**
     * @ignore
     */
    markDirtySize() {
        this._sizeDirty = true;
        this.markDirty();
    }
    /**
     * @ignore
     */
    markDirtyBounds() {
        if (this.get("isMeasured")) {
            const display = this._display;
            this._root._addDirtyBounds(this);
            display.isMeasured = true;
            display.invalidateBounds();
            const parent = this.parent;
            if (parent && this.get("position") != "absolute") {
                if (parent.get("width") == null || parent.get("height") == null || parent.get("layout")) {
                    parent.markDirtyBounds();
                }
            }
            if (this.get("focusable") && this.isFocus()) {
                this.markDirtyAccessibility();
            }
        }
    }
    /**
     * @ignore
     */
    markDirtyAccessibility() {
        //if (this._root.focused(this)) {
        this._root._invalidateAccessibility(this);
        //}
    }
    /**
     * @ignore
     */
    markDirtyLayer() {
        //this._display.markDirtyLayer(this.isDirty("opacity") || this.isDirty("visible")); https://codepen.io/team/amcharts/pen/gOWZPmP <- problems
        this._display.markDirtyLayer(true);
    }
    /**
     * @ignore
     */
    markDirty() {
        super.markDirty();
        this.markDirtyLayer();
    }
    _updateBounds() {
        const oldBounds = this._adjustedLocalBounds;
        let newBounds;
        // if display.visible == false, it still returns bounds
        if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) {
            newBounds = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            this._localBounds = newBounds;
            this._adjustedLocalBounds = newBounds;
        }
        else {
            this._getBounds();
            this._fixMinBounds(this._localBounds);
            this.updatePivotPoint();
            this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds);
            newBounds = this._adjustedLocalBounds;
        }
        if (!oldBounds || (oldBounds.left !== newBounds.left || oldBounds.top !== newBounds.top || oldBounds.right !== newBounds.right || oldBounds.bottom !== newBounds.bottom)) {
            const eventType = "boundschanged";
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, { type: eventType, target: this });
            }
            if (this.parent) {
                this.parent.markDirty();
                this.parent.markDirtyBounds();
            }
        }
    }
    _fixMinBounds(bounds) {
        let minWidth = this.get("minWidth", this.getPrivate("minWidth"));
        let minHeight = this.get("minHeight", this.getPrivate("minHeight"));
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](minWidth)) {
            if (bounds.right - bounds.left < minWidth) {
                bounds.right = bounds.left + minWidth;
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](minHeight)) {
            if (bounds.bottom - bounds.top < minHeight) {
                bounds.bottom = bounds.top + minHeight;
            }
        }
        let privateWidth = this.getPrivate("width");
        let privateHeight = this.getPrivate("height");
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](privateWidth)) {
            if (privateWidth > 0) {
                bounds.right = bounds.left + privateWidth;
            }
            else {
                bounds.left = bounds.right + privateWidth;
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](privateHeight)) {
            if (privateHeight > 0) {
                bounds.bottom = bounds.top + privateHeight;
            }
            else {
                bounds.top = bounds.bottom + privateHeight;
            }
        }
    }
    _removeParent(parent) {
        if (parent) {
            parent.children.removeValue(this);
            _util_Array__WEBPACK_IMPORTED_MODULE_8__["removeFirst"](parent._percentageSizeChildren, this);
            _util_Array__WEBPACK_IMPORTED_MODULE_8__["removeFirst"](parent._percentagePositionChildren, this);
        }
    }
    _clearDirty() {
        super._clearDirty();
        this._sizeDirty = false;
        this._statesHandled = false;
    }
    /**
     * Simulate hover over element.
     */
    hover() {
        this.showTooltip();
        this._handleOver();
    }
    /**
     * Simulate unhover over element.
     */
    unhover() {
        this.hideTooltip();
        this._handleOut();
    }
    /**
     * Shows element's [[Tooltip]].
     */
    showTooltip(point) {
        const tooltip = this.getTooltip();
        const tooltipText = this.get("tooltipText");
        const tooltipHTML = this.get("tooltipHTML");
        if ((tooltipText || tooltipHTML) && tooltip) {
            const tooltipPosition = this.get("tooltipPosition");
            const tooltipTarget = this.getPrivate("tooltipTarget", this);
            if (tooltipPosition == "fixed" || !point) {
                this._display._setMatrix();
                point = this.toGlobal(tooltipTarget._getTooltipPoint());
            }
            tooltip.set("pointTo", point);
            tooltip.set("tooltipTarget", tooltipTarget);
            if (!tooltip.get("x")) {
                tooltip.set("x", point.x);
            }
            if (!tooltip.get("y")) {
                tooltip.set("y", point.y);
            }
            if (tooltipText) {
                tooltip.label.set("text", tooltipText);
            }
            if (tooltipHTML) {
                tooltip.label.set("html", tooltipHTML);
            }
            const dataItem = this.dataItem;
            if (dataItem) {
                tooltip.label._setDataItem(dataItem);
            }
            if (this.get("showTooltipOn") == "always" && (point.x < 0 || point.x > this._root.width() || point.y < 0 || point.y > this._root.height())) {
                this.hideTooltip();
                return;
            }
            tooltip.label.text.markDirtyText();
            const promise = tooltip.show();
            this.setPrivateRaw("showingTooltip", true);
            return promise;
        }
    }
    /**
     * Hides element's [[Tooltip]].
     */
    hideTooltip() {
        const tooltip = this.getTooltip();
        if (tooltip) {
            if (tooltip.get("tooltipTarget") == this.getPrivate("tooltipTarget", this)) {
                let timeout = tooltip.get("keepTargetHover") && tooltip.get("stateAnimationDuration", 0) == 0 ? 400 : undefined;
                const promise = tooltip.hide(timeout);
                this.setPrivateRaw("showingTooltip", false);
                return promise;
            }
        }
    }
    _getTooltipPoint() {
        const bounds = this._localBounds;
        if (bounds) {
            let x = 0;
            let y = 0;
            if (!this.get("isMeasured")) {
                x = _util_Utils__WEBPACK_IMPORTED_MODULE_7__["relativeToValue"](this.get("tooltipX", 0), this.width());
                y = _util_Utils__WEBPACK_IMPORTED_MODULE_7__["relativeToValue"](this.get("tooltipY", 0), this.height());
            }
            else {
                x = bounds.left + _util_Utils__WEBPACK_IMPORTED_MODULE_7__["relativeToValue"](this.get("tooltipX", 0), bounds.right - bounds.left);
                y = bounds.top + _util_Utils__WEBPACK_IMPORTED_MODULE_7__["relativeToValue"](this.get("tooltipY", 0), bounds.bottom - bounds.top);
            }
            return { x, y };
        }
        return { x: 0, y: 0 };
    }
    /**
     * Returns [[Tooltip]] used for this element.
     *
     * @return Tooltip
     */
    getTooltip() {
        let tooltip = this.get("tooltip");
        if (!tooltip) {
            let parent = this.parent;
            if (parent) {
                return parent.getTooltip();
            }
        }
        else {
            return tooltip;
        }
    }
    _updatePosition() {
        const parent = this.parent;
        let dx = this.get("dx", 0);
        let dy = this.get("dy", 0);
        let x = this.get("x");
        let _x = this.getPrivate("x");
        let xx = 0;
        let yy = 0;
        const position = this.get("position");
        if (x instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) {
            if (parent) {
                x = parent.innerWidth() * x.value + parent.get("paddingLeft", 0);
            }
            else {
                x = 0;
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](x)) {
            xx = x + dx;
        }
        else {
            if (_x != null) {
                xx = _x;
            }
            else if (parent) {
                if (position == "relative") {
                    xx = parent.get("paddingLeft", 0) + dx;
                }
            }
        }
        let y = this.get("y");
        let _y = this.getPrivate("y");
        if (y instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) {
            if (parent) {
                y = parent.innerHeight() * y.value + parent.get("paddingTop", 0);
            }
            else {
                y = 0;
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](y)) {
            yy = y + dy;
        }
        else {
            if (_y != null) {
                yy = _y;
            }
            else if (parent) {
                if (position == "relative") {
                    yy = parent.get("paddingTop", 0) + dy;
                }
            }
        }
        const display = this._display;
        if (display.x != xx || display.y != yy) {
            display.invalidateBounds();
            display.x = xx;
            display.y = yy;
            const eventType = "positionchanged";
            if (this.events.isEnabled(eventType)) {
                this.events.dispatch(eventType, { type: eventType, target: this });
            }
        }
        // Update tooltip position together with the Sprite
        if (this.getPrivate("showingTooltip")) {
            this.showTooltip();
        }
    }
    /**
     * Returns element's actual X position in pixels.
     *
     * @return X (px)
     */
    x() {
        let x = this.get("x");
        let _x = this.getPrivate("x");
        const parent = this.parent;
        if (parent) {
            if (x instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) {
                return _util_Utils__WEBPACK_IMPORTED_MODULE_7__["relativeToValue"](x, parent.innerWidth()) + parent.get("paddingLeft", 0);
            }
            else {
                if (!_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](x)) {
                    if (_x != null) {
                        return _x;
                    }
                    else {
                        return parent.get("paddingLeft", this._display.x);
                    }
                }
                else {
                    return x;
                }
            }
        }
        return this._display.x;
    }
    /**
     * Returns element's actual Y position in pixels.
     *
     * @return Y (px)
     */
    y() {
        let _y = this.getPrivate("y");
        if (_y != null) {
            return _y;
        }
        let y = this.get("y");
        const parent = this.parent;
        if (parent) {
            if (y instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) {
                return _util_Utils__WEBPACK_IMPORTED_MODULE_7__["relativeToValue"](y, parent.innerHeight()) + parent.get("paddingTop", 0);
            }
            else {
                if (!_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](y)) {
                    if (_y != null) {
                        return _y;
                    }
                    else {
                        return parent.get("paddingTop", this._display.y);
                    }
                }
                else {
                    return y;
                }
            }
        }
        return this._display.y;
    }
    _dispose() {
        super._dispose();
        this._display.dispose();
        this._removeTemplateField();
        this._removeParent(this.parent);
        this._root._removeFocusElement(this);
        const tooltip = this.get("tooltip");
        if (tooltip) {
            tooltip.dispose();
        }
        this.markDirty();
    }
    /**
     * @ignore
     */
    adjustedLocalBounds() {
        this._fixMinBounds(this._adjustedLocalBounds);
        return this._adjustedLocalBounds;
    }
    /**
     * Returns local coordinates of the element's bounds.
     *
     * @ignore
     * @return Global bounds
     */
    localBounds() {
        return this._localBounds;
    }
    /**
     * Returns adjusted local coordinates of the element's bounds.
     *
     * @ignore
     * @return Global bounds
     */
    bounds() {
        const bounds = this._adjustedLocalBounds;
        const x = this.x();
        const y = this.y();
        return { left: bounds.left + x, right: bounds.right + x, top: bounds.top + y, bottom: bounds.bottom + y };
    }
    /**
     * Returns global coordinates of the element's bounds.
     *
     * @ignore
     * @return Global bounds
     */
    globalBounds() {
        const bounds = this.localBounds();
        const p0 = this.toGlobal({ x: bounds.left, y: bounds.top });
        const p1 = this.toGlobal({ x: bounds.right, y: bounds.top });
        const p2 = this.toGlobal({ x: bounds.right, y: bounds.bottom });
        const p3 = this.toGlobal({ x: bounds.left, y: bounds.bottom });
        return {
            left: Math.min(p0.x, p1.x, p2.x, p3.x),
            top: Math.min(p0.y, p1.y, p2.y, p3.y),
            right: Math.max(p0.x, p1.x, p2.x, p3.x),
            bottom: Math.max(p0.y, p1.y, p2.y, p3.y)
        };
    }
    _onShow(_duration) {
    }
    _onHide(_duration) {
    }
    /**
     * Plays initial reveal animation regardless if element is currently hidden
     * or visible.
     *
     * @param   duration  Duration of the animation in milliseconds
     * @param   delay     Delay showing of the element by X milliseconds
     * @return            Promise
     */
    appear(duration, delay) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            yield this.hide(0);
            if (delay) {
                return new Promise((success, _error) => {
                    this.setTimeout(() => {
                        success(this.show(duration));
                    }, delay);
                });
            }
            else {
                return this.show(duration);
            }
        });
    }
    /**
     * Shows currently hidden element and returns a `Promise` which completes
     * when all showing animations are finished.
     *
     * ```TypeScript
     * series.show().then(function(ev) {
     *   console.log("Series is now fully visible");
     * })
     * ```
     * ```JavaScript
     * series.show().then(function(ev) {
     *   console.log("Series is now fully visible");
     * })
     * ```
     *
     * @return Promise
     */
    show(duration) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            if (!this._isShowing) {
                this._isHidden = false;
                this._isShowing = true;
                this._isHiding = false;
                if (this.states.lookup("default").get("visible")) {
                    this.set("visible", true);
                }
                this._onShow(duration);
                const animations = this.states.applyAnimate("default", duration);
                yield Object(_util_Animation__WEBPACK_IMPORTED_MODULE_6__["waitForAnimations"])(animations);
                this._isShowing = false;
            }
        });
    }
    /**
     * Hides the element and returns a `Promise` which completes when all hiding
     * animations are finished.
     *
     * ```TypeScript
     * series.hide().then(function(ev) {
     *   console.log("Series finished hiding");
     * })
     * ```
     * ```JavaScript
     * series.hide().then(function(ev) {
     *   console.log("Series finished hiding");
     * })
     * ```
     *
     * @return Promise
     */
    hide(duration) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
            if (!this._isHiding && !this._isHidden) {
                this._isHiding = true;
                this._isShowing = false;
                let state = this.states.lookup("hidden");
                if (!state) {
                    state = this.states.create("hidden", {
                        "opacity": 0,
                        "visible": false
                    });
                }
                this._isHidden = true;
                this._onHide(duration);
                const animations = this.states.applyAnimate("hidden", duration);
                yield Object(_util_Animation__WEBPACK_IMPORTED_MODULE_6__["waitForAnimations"])(animations);
                this._isHiding = false;
            }
        });
    }
    /**
     * Returns `true` if this element is currently hidden.
     *
     * @return Is hidden?
     */
    isHidden() {
        return this._isHidden;
    }
    /**
     * Returns `true` if this element is currently animating to a default state.
     *
     * @return Is showing?
     */
    isShowing() {
        return this._isShowing;
    }
    /**
     * Returns `true` if this element is currently animating to a hidden state.
     *
     * @return Is hiding?
     */
    isHiding() {
        return this._isHiding;
    }
    /**
     * Returns `true` if this element is currently hovered by a pointer.
     *
     * @return Is hovered?
     */
    isHover() {
        return this._display.hovering();
    }
    /**
     * Returns `true` if this element does currently have focus.
     *
     * @return Is focused?
     */
    isFocus() {
        return this._root.focused(this);
    }
    /**
     * Returns `true` if this element is currently being dragged.
     *
     * @return Is dragged?
     */
    isDragging() {
        return this._isDragging;
    }
    /**
     * Returns `false` if if either public or private setting `visible` is set
     * to `false`, or `forceHidden` is set to `true`.
     *
     * @return Visible?
     */
    isVisible() {
        if (this.get("visible") && this.getPrivate("visible") && !this.get("forceHidden")) {
            return true;
        }
        return false;
    }
    /**
     * Same as `isVisible()`, except it checks all ascendants, too.
     *
     * @since 5.2.7
     * @return Visible?
     */
    isVisibleDeep() {
        return this._parent ? (this._parent.isVisibleDeep() && this.isVisible()) : this.isVisible();
    }
    /**
     * Returns an actual opacity of the element, taking into account all parents.
     *
     * @return Opacity
     * @since 5.2.11
     */
    compositeOpacity() {
        const opacity = this.get("opacity", 1);
        return this._parent ? (this._parent.compositeOpacity() * opacity) : opacity;
    }
    /**
     * Returns width of this element in pixels.
     *
     * @return Width (px)
     */
    width() {
        let width = this.get("width");
        let maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));
        let minWidth = this.get("minWidth", this.getPrivate("minWidth"));
        let privateWidth = this.getPrivate("width");
        let w = 0;
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](privateWidth)) {
            w = privateWidth;
        }
        else {
            if (width == null) {
                if (this._adjustedLocalBounds) {
                    w = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left;
                }
            }
            else {
                if (width instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) {
                    const parent = this.parent;
                    if (parent) {
                        w = parent.innerWidth() * width.value;
                    }
                    else {
                        w = this._root.width() * width.value;
                    }
                }
                else if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](width)) {
                    w = width;
                }
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](minWidth)) {
            w = Math.max(minWidth, w);
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](maxWidth)) {
            w = Math.min(maxWidth, w);
        }
        return w;
    }
    /**
     * Returns maximum allowed width of this element in pixels.
     *
     * @return Maximum width (px)
     */
    maxWidth() {
        let maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](maxWidth)) {
            return maxWidth;
        }
        else {
            let width = this.get("width");
            if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](width)) {
                return width;
            }
        }
        const parent = this.parent;
        if (parent) {
            return parent.innerWidth();
        }
        return this._root.width();
    }
    /**
     * Returns maximum allowed height of this element in pixels.
     *
     * @return Maximum height (px)
     */
    maxHeight() {
        let maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](maxHeight)) {
            return maxHeight;
        }
        else {
            let height = this.get("height");
            if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](height)) {
                return height;
            }
        }
        const parent = this.parent;
        if (parent) {
            return parent.innerHeight();
        }
        return this._root.height();
    }
    /**
     * Returns height of this element in pixels.
     *
     * @return Height (px)
     */
    height() {
        let height = this.get("height");
        let maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));
        let minHeight = this.get("minHeight", this.getPrivate("minHeight"));
        let privateHeight = this.getPrivate("height");
        let h = 0;
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](privateHeight)) {
            h = privateHeight;
        }
        else {
            if (height == null) {
                if (this._adjustedLocalBounds) {
                    h = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top;
                }
            }
            else {
                if (height instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) {
                    const parent = this.parent;
                    if (parent) {
                        h = parent.innerHeight() * height.value;
                    }
                    else {
                        h = this._root.height() * height.value;
                    }
                }
                else if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](height)) {
                    h = height;
                }
            }
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](minHeight)) {
            h = Math.max(minHeight, h);
        }
        if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](maxHeight)) {
            h = Math.min(maxHeight, h);
        }
        return h;
    }
    _findStaticTemplate(f) {
        // templateField overrides template
        if (this._templateField && f(this._templateField)) {
            return this._templateField;
        }
        return super._findStaticTemplate(f);
    }
    _walkParents(f) {
        if (this._parent) {
            this._walkParent(f);
        }
    }
    _walkParent(f) {
        if (this._parent) {
            this._parent._walkParent(f);
        }
        f(this);
    }
    /**
     * Parent [[Container]] of this element.
     *
     * @return Parent container
     */
    get parent() {
        return this._parent;
    }
    _setParent(parent, updateChildren = false) {
        const prevParent = this._parent;
        if (parent !== prevParent) {
            this.markDirtyBounds();
            parent.markDirty();
            this._parent = parent;
            if (updateChildren) {
                this._removeParent(prevParent);
                if (parent) {
                    this._addPercentageSizeChildren();
                    this._addPercentagePositionChildren();
                }
            }
            this.markDirtyPosition();
            this._applyThemes();
        }
    }
    /**
     * Returns an instance of [[NumberFormatter]] used in this element.
     *
     * If this element does not have it set, global one form [[Root]] is used.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
     * @return NumberFormatter instace
     */
    getNumberFormatter() {
        return this.get("numberFormatter", this._root.numberFormatter);
    }
    /**
     * Returns an instance of [[DateFormatter]] used in this element.
     *
     * If this element does not have it set, global one form [[Root]] is used.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
     * @return DateFormatter instace
     */
    getDateFormatter() {
        return this.get("dateFormatter", this._root.dateFormatter);
    }
    /**
     * Returns an instance of [[DurationFormatter]] used in this element.
     *
     * If this element does not have it set, global one form [[Root]] is used.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
     * @return DurationFormatter instace
     */
    getDurationFormatter() {
        return this.get("durationFormatter", this._root.durationFormatter);
    }
    /**
     * Converts X/Y coordinate within this element to a global coordinate.
     *
     * @param  point  Local coordinate
     * @return        Global coordinate
     */
    toGlobal(point) {
        return this._display.toGlobal(point);
    }
    /**
     * Converts global X/Y coordinate to a coordinate within this element.
     *
     * @param  point  Global coordinate
     * @return        Local coordinate
     */
    toLocal(point) {
        return this._display.toLocal(point);
    }
    _getDownPoint() {
        const id = this._getDownPointId();
        if (id) {
            return this._downPoints[id];
        }
    }
    _getDownPointId() {
        if (this._downPoints) {
            return _util_Object__WEBPACK_IMPORTED_MODULE_10__["keysOrdered"](this._downPoints, (a, b) => {
                if (a > b) {
                    return 1;
                }
                if (a < b) {
                    return -1;
                }
                return 0;
            })[0];
        }
    }
    /**
     * Moves sprite to the end of the parent's children array.
     *
     * Depending on `layout` setting of the parten container, it may effect the
     * positioning or overlapping order of the elements.
     */
    toFront() {
        const parent = this.parent;
        if (parent) {
            parent.children.moveValue(this, parent.children.length - 1);
        }
    }
    /**
     * Moves sprite to the beginning of the parent's children array.
     *
     * Depending on `layout` setting of the parten container, it may effect the
     * positioning or overlapping order of the elements.
     */
    toBack() {
        const parent = this.parent;
        if (parent) {
            parent.children.moveValue(this, 0);
        }
    }
}
Object.defineProperty(Sprite, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Sprite"
});
Object.defineProperty(Sprite, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _util_Entity__WEBPACK_IMPORTED_MODULE_1__["Entity"].classNames.concat([Sprite.className])
});
//# sourceMappingURL=Sprite.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/SpriteResizer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/SpriteResizer.js ***!
  \*********************************************************************************/
/*! exports provided: SpriteResizer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteResizer", function() { return SpriteResizer; });
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _RoundedRectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony import */ var _Rectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony import */ var _util_Color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");






class SpriteResizer extends _Container__WEBPACK_IMPORTED_MODULE_0__["Container"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "rectangle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.children.push(_Rectangle__WEBPACK_IMPORTED_MODULE_3__["Rectangle"].new(this._root, { themeTags: ["rectangle"], fillOpacity: 0, fill: Object(_util_Color__WEBPACK_IMPORTED_MODULE_4__["color"])(0xFFFFFF) }))
        });
        Object.defineProperty(this, "gripL", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._createGrip("left")
        });
        Object.defineProperty(this, "gripR", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._createGrip("right")
        });
        Object.defineProperty(this, "gripT", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._createGrip("top")
        });
        Object.defineProperty(this, "gripB", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._createGrip("bottom")
        });
        Object.defineProperty(this, "_is", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "_ix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_iw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_positionDP", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_isHover", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _afterNew() {
        super._afterNew();
        this.addTag("resizer");
        this.set("visible", false);
        this.gripL.events.on("dragged", (e) => {
            this._resize(e.target, -1);
        });
        this.gripR.events.on("dragged", (e) => {
            this._resize(e.target, 1);
        });
        this.gripL.events.on("dragstart", (e) => {
            this._resizeStart(e.target);
        });
        this.gripR.events.on("dragstart", (e) => {
            this._resizeStart(e.target);
        });
        this.gripT.events.on("dragged", (e) => {
            this._rotate(e, 90);
        });
        this.gripB.events.on("dragged", (e) => {
            this._rotate(e, -90);
        });
        this.gripT.events.on("dragstart", (e) => {
            this._resizeStart(e.target);
        });
        this.gripB.events.on("dragstart", (e) => {
            this._resizeStart(e.target);
        });
    }
    _resizeStart(grip) {
        const sprite = this.get("sprite");
        if (sprite) {
            this._is = sprite.get("scale", 1);
            this._ix = grip.x();
            this._iw = this.width() / 2;
        }
    }
    _resize(grip, c) {
        const sprite = this.get("sprite");
        const spriteTemplate = this.get("spriteTemplate");
        if (sprite) {
            const scale = Math.max(0.01, this._is * (1 + c * (grip.x() - this._ix) / this._iw));
            if (spriteTemplate) {
                spriteTemplate.set("scale", scale);
            }
            else {
                sprite.set("scale", scale);
            }
            sprite.states.lookup("default").set("scale", scale);
            this._updatePositions();
        }
    }
    _rotate(e, delta) {
        const sprite = this.get("sprite");
        const spriteTemplate = this.get("spriteTemplate");
        if (sprite) {
            const parent = this.parent;
            if (parent) {
                const rotationStep = this.get("rotationStep", 10);
                let angle = Math.round(((_util_Math__WEBPACK_IMPORTED_MODULE_5__["getAngle"]({ x: this.x(), y: this.y() }, parent.toLocal(e.point)) + delta) / rotationStep)) * rotationStep;
                if (spriteTemplate) {
                    spriteTemplate.set("rotation", angle);
                }
                else {
                    sprite.set("rotation", angle);
                }
                sprite.states.lookup("default").set("rotation", angle);
                this._updatePositions();
            }
        }
    }
    _createGrip(themeTag) {
        const container = this.children.push(_Container__WEBPACK_IMPORTED_MODULE_0__["Container"].new(this._root, {
            themeTags: ["grip", themeTag],
            setStateOnChildren: true,
            draggable: true
        }));
        container.children.push(_RoundedRectangle__WEBPACK_IMPORTED_MODULE_2__["RoundedRectangle"].new(this._root, {
            themeTags: ["outline"],
            centerX: _util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            centerY: _util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"]
        }));
        container.children.push(_RoundedRectangle__WEBPACK_IMPORTED_MODULE_2__["RoundedRectangle"].new(this._root, {
            centerX: _util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            centerY: _util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"]
        }));
        return container;
    }
    _updateChildren() {
        super._updateChildren();
        if (this.isDirty("sprite")) {
            const sprite = this.get("sprite");
            if (sprite) {
                this.show(0);
                this.setPrivate("visible", true);
                this._updatePositions();
                const parent = sprite.parent;
                if (parent) {
                    parent.children.moveValue(this, 0);
                }
                this._positionDP = sprite.events.on("positionchanged", () => {
                    this._updatePositions();
                });
            }
            else {
                this.hide(0);
                this.setPrivate("visible", false);
                if (this._positionDP) {
                    this._positionDP.dispose();
                }
            }
        }
        if (this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation")) {
            this._updatePositions();
        }
    }
    _updatePositions() {
        const sprite = this.get("sprite");
        if (sprite) {
            let bounds = sprite.localBounds();
            let scale = sprite.get("scale", 1);
            let d = 20;
            let w = (bounds.right - bounds.left) * scale + d;
            let h = (bounds.bottom - bounds.top) * scale + d;
            let a = sprite.get("rotation", 0);
            const rectangle = this.rectangle;
            let cx = sprite.get("centerX", _util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"]);
            let cy = sprite.get("centerY", _util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"]);
            let cxr = 0;
            if (cx instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_1__["Percent"]) {
                cxr = cx.value;
            }
            let cyr = 0;
            if (cy instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_1__["Percent"]) {
                cyr = cy.value;
            }
            rectangle.setAll({ centerX: cx, centerY: cy, width: w, height: h });
            this.setAll({ x: sprite.x() + d * (cxr - 0.5) * _util_Math__WEBPACK_IMPORTED_MODULE_5__["cos"](a) - d * (cyr - 0.5) * _util_Math__WEBPACK_IMPORTED_MODULE_5__["sin"](a), y: sprite.y() + d * (cyr - 0.5) * _util_Math__WEBPACK_IMPORTED_MODULE_5__["cos"](a) + d * (cxr - 0.5) * _util_Math__WEBPACK_IMPORTED_MODULE_5__["sin"](a), width: w, height: h, rotation: a });
            this.gripT.setAll({ x: (0.5 - cxr) * w, y: -cyr * h });
            this.gripB.setAll({ x: (0.5 - cxr) * w, y: (1 - cyr) * h });
            this.gripL.setAll({ x: -cxr * w, y: (0.5 - cyr) * h });
            this.gripR.setAll({ x: (1 - cxr) * w, y: (0.5 - cyr) * h });
            this.rectangle.setAll({ width: w, height: h });
        }
    }
}
Object.defineProperty(SpriteResizer, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "SpriteResizer"
});
Object.defineProperty(SpriteResizer, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_0__["Container"].classNames.concat([SpriteResizer.className])
});
//# sourceMappingURL=SpriteResizer.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Star.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Star.js ***!
  \************************************************************************/
/*! exports provided: Star */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Star", function() { return Star; });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony import */ var _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");


/**
 * Draws a Star.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Star extends _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("spikes")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            const display = this._display;
            const r = this.get("radius", 0);
            const ir = _core_util_Utils__WEBPACK_IMPORTED_MODULE_1__["relativeToValue"](this.get("innerRadius", 0), r);
            const spikes = this.get("spikes", 0);
            const step = Math.PI / spikes;
            let angle = Math.PI / 2 * 3;
            display.moveTo(0, -r);
            for (let i = 0; i < spikes; i++) {
                display.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                angle += step;
                display.lineTo(Math.cos(angle) * ir, Math.sin(angle) * ir);
                angle += step;
            }
            display.lineTo(0, -r);
            display.closePath();
        }
    }
}
Object.defineProperty(Star, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Star"
});
Object.defineProperty(Star, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"].classNames.concat([Star.className])
});
//# sourceMappingURL=Star.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js ***!
  \************************************************************************/
/*! exports provided: Text */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Text", function() { return Text; });
/* harmony import */ var _Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sprite */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js");
/* harmony import */ var _util_PopulateString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/PopulateString */ "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Disposer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");




/**
 * @ignore Text is an internal class. Use Label instead.
 */
class Text extends _Sprite__WEBPACK_IMPORTED_MODULE_0__["Sprite"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "textStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeTextStyle()
        });
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeText("", this.textStyle)
        });
        Object.defineProperty(this, "_textStyles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: [
                "textAlign",
                "fontFamily",
                "fontSize",
                "fontStyle",
                "fontWeight",
                "fontStyle",
                "fontVariant",
                "textDecoration",
                "shadowColor",
                "shadowBlur",
                "shadowOffsetX",
                "shadowOffsetY",
                "shadowOpacity",
                // "leading",
                // "letterSpacing",
                "lineHeight",
                "baselineRatio",
                //"padding",
                // "stroke",
                // "strokeThickness",
                // "trim",
                // "wordWrap",
                "direction",
                "textBaseline",
                "oversizedBehavior",
                "breakWords",
                "ellipsis",
                "minScale"
            ]
        });
        Object.defineProperty(this, "_originalScale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _updateBounds() {
        if (!this.get("text")) {
            let newBounds = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
            };
            this._adjustedLocalBounds = newBounds;
        }
        else {
            super._updateBounds();
        }
    }
    _changed() {
        super._changed();
        this._display.clear();
        let textStyle = this.textStyle;
        if (this.isDirty("opacity")) {
            let opacity = this.get("opacity", 1);
            this._display.alpha = opacity;
        }
        if (this.isDirty("text") || this.isDirty("populateText")) {
            this._display.text = this._getText();
            this.markDirtyBounds();
            if (this.get("role") == "tooltip") {
                this._root.updateTooltip(this);
            }
        }
        if (this.isPrivateDirty("tooltipElement")) {
            const tooltipElement = this.getPrivate("tooltipElement");
            if (tooltipElement) {
                this._disposers.push(new _util_Disposer__WEBPACK_IMPORTED_MODULE_3__["Disposer"](() => {
                    this._root._removeTooltipElement(this);
                }));
            }
        }
        if (this.isDirty("width")) {
            textStyle.wordWrapWidth = this.width();
            this.markDirtyBounds();
        }
        if (this.isDirty("oversizedBehavior")) {
            textStyle.oversizedBehavior = this.get("oversizedBehavior", "none");
            this.markDirtyBounds();
        }
        if (this.isDirty("breakWords")) {
            textStyle.breakWords = this.get("breakWords", false);
            this.markDirtyBounds();
        }
        if (this.isDirty("ellipsis")) {
            textStyle.ellipsis = this.get("ellipsis");
            this.markDirtyBounds();
        }
        if (this.isDirty("ignoreFormatting")) {
            textStyle.ignoreFormatting = this.get("ignoreFormatting", false);
            this.markDirtyBounds();
        }
        if (this.isDirty("minScale")) {
            textStyle.minScale = this.get("minScale", 0);
            this.markDirtyBounds();
        }
        if (this.isDirty("fill")) {
            let fill = this.get("fill");
            if (fill) {
                textStyle.fill = fill;
            }
        }
        if (this.isDirty("fillOpacity")) {
            let fillOpacity = this.get("fillOpacity", 1);
            if (fillOpacity) {
                textStyle.fillOpacity = fillOpacity;
            }
        }
        if (this.isDirty("maxWidth") || this.isPrivateDirty("maxWidth")) {
            textStyle.maxWidth = this.get("maxWidth", this.getPrivate("maxWidth"));
            this.markDirtyBounds();
        }
        if (this.isDirty("maxHeight") || this.isPrivateDirty("maxHeight")) {
            textStyle.maxHeight = this.get("maxHeight", this.getPrivate("maxHeight"));
            this.markDirtyBounds();
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_2__["each"](this._textStyles, (styleName) => {
            if (this._dirty[styleName]) {
                textStyle[styleName] = this.get(styleName);
                this.markDirtyBounds();
            }
        });
        textStyle["fontSize"] = this.get("fontSize");
        textStyle["fontFamily"] = this.get("fontFamily");
        this._display.style = textStyle;
        if (this.isDirty("role") && this.get("role") == "tooltip") {
            this._root.updateTooltip(this);
        }
    }
    _getText() {
        const text = this.get("text", "");
        return this.get("populateText") ? Object(_util_PopulateString__WEBPACK_IMPORTED_MODULE_1__["populateString"])(this, text) : text;
    }
    markDirtyText() {
        this._display.text = this._getText();
        if (this.get("role") == "tooltip") {
            this._root.updateTooltip(this);
        }
        this.markDirtyBounds();
        this.markDirty();
    }
    _setDataItem(dataItem) {
        super._setDataItem(dataItem);
        if (this.get("populateText")) {
            this.markDirtyText();
        }
    }
    getNumberFormatter() {
        if (this.parent) {
            return this.parent.getNumberFormatter();
        }
        else {
            return super.getNumberFormatter();
        }
    }
    getDateFormatter() {
        if (this.parent) {
            return this.parent.getDateFormatter();
        }
        else {
            return super.getDateFormatter();
        }
    }
    getDurationFormatter() {
        if (this.parent) {
            return this.parent.getDurationFormatter();
        }
        else {
            return super.getDurationFormatter();
        }
    }
}
Object.defineProperty(Text, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Text"
});
Object.defineProperty(Text, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Sprite__WEBPACK_IMPORTED_MODULE_0__["Sprite"].classNames.concat([Text.className])
});
//# sourceMappingURL=Text.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js ***!
  \************************************************************************/
/*! exports provided: Tick */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tick", function() { return Tick; });
/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js");

/**
 * Draws a tick element (mostly used on axes).
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 */
class Tick extends _Line__WEBPACK_IMPORTED_MODULE_0__["Line"] {
}
Object.defineProperty(Tick, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Tick"
});
Object.defineProperty(Tick, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Line__WEBPACK_IMPORTED_MODULE_0__["Line"].classNames.concat([Tick.className])
});
//# sourceMappingURL=Tick.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js ***!
  \***************************************************************************/
/*! exports provided: Tooltip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tooltip", function() { return Tooltip; });
/* harmony import */ var _util_Disposer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _render_Label__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");
/* harmony import */ var _render_PointedRectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/PointedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js");
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _util_Color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");









/**
 * Creates a tooltip.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info
 * @important
 */
class Tooltip extends _Container__WEBPACK_IMPORTED_MODULE_3__["Container"] {
    constructor(root, settings, isReal, templates = []) {
        super(root, settings, isReal, templates);
        Object.defineProperty(this, "_fx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_fy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_label", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_fillDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_strokeDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_labelDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_w", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_h", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_keepHoverDp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_htmlContentHovered", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _afterNew() {
        this._settings.themeTags = _util_Utils__WEBPACK_IMPORTED_MODULE_8__["mergeTags"](this._settings.themeTags, ["tooltip"]);
        super._afterNew();
        this.set("background", _render_PointedRectangle__WEBPACK_IMPORTED_MODULE_2__["PointedRectangle"].new(this._root, {
            themeTags: ["tooltip", "background"]
        }));
        this._label = this.children.push(_render_Label__WEBPACK_IMPORTED_MODULE_1__["Label"].new(this._root, {}));
        this._disposers.push(this._label.events.on("boundschanged", () => {
            this._updateBackground();
        }));
        this._disposers.push(this.on("bounds", () => {
            this._updateBackground();
        }));
        this._updateTextColor();
        this._root.tooltipContainer.children.push(this);
        this.hide(0);
        this._disposers.push(this.label.onPrivate("htmlElement", (htmlElement) => {
            if (htmlElement) {
                _util_Utils__WEBPACK_IMPORTED_MODULE_8__["addEventListener"](htmlElement, "pointerover", (_ev) => {
                    this._htmlContentHovered = true;
                });
                _util_Utils__WEBPACK_IMPORTED_MODULE_8__["addEventListener"](htmlElement, "pointerout", (_ev) => {
                    this._htmlContentHovered = false;
                });
            }
        }));
        this._root._tooltips.push(this);
    }
    /**
     * A [[Label]] element for the tooltip.
     *
     * @readonly
     * @return Label
     */
    get label() {
        return this._label;
    }
    /**
     * Permanently disposes the tooltip.
     */
    dispose() {
        super.dispose();
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["remove"](this._root._tooltips, this);
    }
    _updateChildren() {
        super._updateChildren();
        if (this.isDirty("pointerOrientation") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) {
            this.get("background")._markDirtyKey("width");
        }
        const labelText = this.get("labelText");
        if (labelText != null) {
            this.label.set("text", this.get("labelText"));
        }
        const labelHTML = this.get("labelHTML");
        if (labelHTML != null) {
            this.label.set("html", this.get("labelHTML"));
        }
    }
    _changed() {
        super._changed();
        if (this.isDirty("pointTo") || this.isDirty("pointerOrientation")) {
            // can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)
            this._updateBackground();
        }
        if (this.isDirty("tooltipTarget")) {
            this.updateBackgroundColor();
        }
        if (this.isDirty("keepTargetHover")) {
            const keephover = this.get("keepTargetHover");
            if (keephover) {
                const bg = this.get("background");
                this._keepHoverDp = new _util_Disposer__WEBPACK_IMPORTED_MODULE_0__["MultiDisposer"]([
                    bg.events.on("pointerover", (_ev) => {
                        let target = this.get("tooltipTarget");
                        if (target) {
                            if (target.parent && target.parent.getPrivate("tooltipTarget") == target) {
                                target = target.parent;
                            }
                            target.hover();
                        }
                    }),
                    bg.events.on("pointerout", (_ev) => {
                        let target = this.get("tooltipTarget");
                        if (target) {
                            if (target.parent && target.parent.getPrivate("tooltipTarget") == target) {
                                target = target.parent;
                            }
                            if (!this._htmlContentHovered) {
                                target.unhover();
                            }
                        }
                    })
                ]);
            }
            else {
                if (this._keepHoverDp) {
                    this._keepHoverDp.dispose();
                    this._keepHoverDp = undefined;
                }
            }
        }
    }
    _onShow() {
        super._onShow();
        this.updateBackgroundColor();
    }
    updateBackgroundColor() {
        let tooltipTarget = this.get("tooltipTarget");
        const background = this.get("background");
        let fill;
        let stroke;
        if (tooltipTarget && background) {
            fill = tooltipTarget.get("fill");
            stroke = tooltipTarget.get("stroke");
            if (fill == null) {
                fill = stroke;
            }
            if (this.get("getFillFromSprite")) {
                if (this._fillDp) {
                    this._fillDp.dispose();
                }
                if (fill != null) {
                    background.set("fill", fill);
                }
                this._fillDp = tooltipTarget.on("fill", (fill) => {
                    if (fill != null) {
                        background.set("fill", fill);
                        this._updateTextColor(fill);
                    }
                });
                this._disposers.push(this._fillDp);
            }
            if (this.get("getStrokeFromSprite")) {
                if (this._strokeDp) {
                    this._strokeDp.dispose();
                }
                if (fill != null) {
                    background.set("stroke", fill);
                }
                this._strokeDp = tooltipTarget.on("fill", (fill) => {
                    if (fill != null) {
                        background.set("stroke", fill);
                    }
                });
                this._disposers.push(this._strokeDp);
            }
            if (this.get("getLabelFillFromSprite")) {
                if (this._labelDp) {
                    this._labelDp.dispose();
                }
                if (fill != null) {
                    this.label.set("fill", fill);
                }
                this._labelDp = tooltipTarget.on("fill", (fill) => {
                    if (fill != null) {
                        this.label.set("fill", fill);
                    }
                });
                this._disposers.push(this._labelDp);
            }
        }
        this._updateTextColor(fill);
    }
    _updateTextColor(fill) {
        if (this.get("autoTextColor")) {
            if (fill == null) {
                fill = this.get("background").get("fill");
            }
            if (fill == null) {
                fill = this._root.interfaceColors.get("background");
            }
            if (fill instanceof _util_Color__WEBPACK_IMPORTED_MODULE_5__["Color"]) {
                this.label.set("fill", _util_Color__WEBPACK_IMPORTED_MODULE_5__["Color"].alternative(fill, this._root.interfaceColors.get("alternativeText"), this._root.interfaceColors.get("text")));
            }
        }
    }
    _setDataItem(dataItem) {
        super._setDataItem(dataItem);
        this.label._setDataItem(dataItem);
    }
    _updateBackground() {
        super.updateBackground();
        const parent = this._root.container;
        if (parent) {
            let cw = 0.5;
            let ch = 0.5;
            let centerX = this.get("centerX");
            if (centerX instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_4__["Percent"]) {
                cw = centerX.value;
            }
            let centerY = this.get("centerY");
            if (centerY instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_4__["Percent"]) {
                ch = centerY.value;
            }
            let parentW = parent.width();
            let parentH = parent.height();
            let tooltipContainer = this.parent;
            let xx = 0;
            let yy = 0;
            if (tooltipContainer) {
                xx = tooltipContainer.x();
                yy = tooltipContainer.y();
                const layerMargin = tooltipContainer.get("layerMargin");
                if (layerMargin) {
                    xx += layerMargin.left || 0;
                    yy += layerMargin.top || 0;
                    parentW += (layerMargin.left || 0) + (layerMargin.right || 0);
                    parentH += (layerMargin.top || 0) + (layerMargin.bottom || 0);
                }
            }
            const bounds = this.get("bounds", { left: -xx, top: -yy, right: parentW - xx, bottom: parentH - yy });
            this._updateBounds();
            let w = this.width();
            let h = this.height();
            // use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens
            if (w === 0) {
                w = this._w;
            }
            if (h === 0) {
                h = this._h;
            }
            let pointTo = this.get("pointTo", { x: parentW / 2, y: parentH / 2 });
            let x = pointTo.x;
            let y = pointTo.y;
            let pointerOrientation = this.get("pointerOrientation");
            let background = this.get("background");
            let pointerLength = 0;
            let bgStrokeSizeY = 0;
            let bgStrokeSizeX = 0;
            if (background instanceof _render_PointedRectangle__WEBPACK_IMPORTED_MODULE_2__["PointedRectangle"]) {
                pointerLength = background.get("pointerLength", 0);
                bgStrokeSizeY = background.get("strokeWidth", 0) / 2;
                bgStrokeSizeX = bgStrokeSizeY;
                background.set("width", w);
                background.set("height", h);
            }
            let pointerX = 0;
            let pointerY = 0;
            let boundsW = bounds.right - bounds.left;
            let boundsH = bounds.bottom - bounds.top;
            // horizontal
            if (pointerOrientation == "horizontal" || pointerOrientation == "left" || pointerOrientation == "right") {
                bgStrokeSizeY = 0;
                if (pointerOrientation == "horizontal") {
                    if (x > bounds.left + boundsW / 2) {
                        x -= (w * (1 - cw) + pointerLength);
                        bgStrokeSizeX *= -1;
                    }
                    else {
                        x += (w * cw + pointerLength);
                    }
                }
                else if (pointerOrientation == "left") {
                    x += (w * (1 - cw) + pointerLength);
                }
                else {
                    x -= (w * cw + pointerLength);
                    bgStrokeSizeX *= -1;
                }
            }
            // vertical pointer
            else {
                bgStrokeSizeX = 0;
                if (pointerOrientation == "vertical") {
                    if (y > bounds.top + h / 2 + pointerLength) {
                        y -= (h * (1 - ch) + pointerLength);
                    }
                    else {
                        y += (h * ch + pointerLength);
                        bgStrokeSizeY *= -1;
                    }
                }
                else if (pointerOrientation == "down") {
                    y -= (h * (1 - ch) + pointerLength);
                }
                else {
                    y += (h * ch + pointerLength);
                    bgStrokeSizeY *= -1;
                }
            }
            x = _util_Math__WEBPACK_IMPORTED_MODULE_6__["fitToRange"](x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;
            y = _util_Math__WEBPACK_IMPORTED_MODULE_6__["fitToRange"](y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;
            pointerX = pointTo.x - x + w * cw + bgStrokeSizeX;
            pointerY = pointTo.y - y + h * ch - bgStrokeSizeY;
            this._fx = x;
            this._fy = y;
            const animationDuration = this.get("animationDuration", 0);
            if (animationDuration > 0 && this.get("visible") && this.get("opacity") > 0.1) {
                const animationEasing = this.get("animationEasing");
                this.animate({ key: "x", to: x, duration: animationDuration, easing: animationEasing });
                this.animate({ key: "y", to: y, duration: animationDuration, easing: animationEasing });
            }
            else {
                this.set("x", x);
                this.set("y", y);
            }
            if (background instanceof _render_PointedRectangle__WEBPACK_IMPORTED_MODULE_2__["PointedRectangle"]) {
                background.set("pointerX", pointerX);
                background.set("pointerY", pointerY);
            }
            if (w > 0) {
                this._w = w;
            }
            if (h > 0) {
                this._h = h;
            }
        }
    }
}
Object.defineProperty(Tooltip, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Tooltip"
});
Object.defineProperty(Tooltip, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Container__WEBPACK_IMPORTED_MODULE_3__["Container"].classNames.concat([Tooltip.className])
});
//# sourceMappingURL=Tooltip.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/Triangle.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/Triangle.js ***!
  \****************************************************************************/
/*! exports provided: Triangle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");

/**
 * Draws a triangle.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info
 * @important
 */
class Triangle extends _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear && !this.get("draw")) {
            this._draw();
        }
    }
    _draw() {
        const w = this.width();
        const h = this.height();
        const display = this._display;
        display.moveTo(-w / 2, h / 2);
        display.lineTo(0, -h / 2);
        display.lineTo(w / 2, h / 2);
        display.lineTo(-w / 2, h / 2);
        display.closePath();
    }
    _updateSize() {
        this.markDirty();
        this._clear = true;
    }
}
Object.defineProperty(Triangle, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Triangle"
});
Object.defineProperty(Triangle, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Graphics__WEBPACK_IMPORTED_MODULE_0__["Graphics"].classNames.concat([Triangle.className])
});
//# sourceMappingURL=Triangle.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js ***!
  \**********************************************************************************/
/*! exports provided: VerticalLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VerticalLayout", function() { return VerticalLayout; });
/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Layout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");



/**
 * A vertical children layout for [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/#Layout} for more info
 */
class VerticalLayout extends _Layout__WEBPACK_IMPORTED_MODULE_0__["Layout"] {
    /**
     * @ignore
     */
    updateContainer(container) {
        let paddingTop = container.get("paddingTop", 0);
        let availableHeight = container.innerHeight();
        let totalPercent = 0;
        Object(_Layout__WEBPACK_IMPORTED_MODULE_0__["eachChildren"])(container, (child) => {
            if (child.isVisible()) {
                if (child.get("position") == "relative") {
                    let childHeight = child.get("height");
                    if (childHeight instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_2__["Percent"]) {
                        totalPercent += childHeight.value;
                        let h = availableHeight * childHeight.value;
                        let minHeight = child.get("minHeight", child.getPrivate("minHeight", -Infinity));
                        if (minHeight > h) {
                            availableHeight -= minHeight;
                            totalPercent -= childHeight.value;
                        }
                        let maxHeight = child.get("maxHeight", child.getPrivate("maxHeight", Infinity));
                        if (h > maxHeight) {
                            availableHeight -= maxHeight;
                            totalPercent -= childHeight.value;
                        }
                    }
                    else {
                        if (!_util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](childHeight)) {
                            childHeight = child.height();
                        }
                        availableHeight -= childHeight + child.get("marginTop", 0) + child.get("marginBottom", 0);
                    }
                }
            }
        });
        if (availableHeight <= 0 || availableHeight == Infinity) {
            availableHeight = .1;
        }
        //if (availableHeight > 0) {
        Object(_Layout__WEBPACK_IMPORTED_MODULE_0__["eachChildren"])(container, (child) => {
            if (child.isVisible()) {
                if (child.get("position") == "relative") {
                    let childHeight = child.get("height");
                    if (childHeight instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_2__["Percent"]) {
                        let privateHeight = availableHeight * childHeight.value / totalPercent - child.get("marginTop", 0) - child.get("marginBottom", 0);
                        let minHeight = child.get("minHeight", child.getPrivate("minHeight", -Infinity));
                        let maxHeight = child.get("maxHeight", child.getPrivate("maxHeight", Infinity));
                        privateHeight = Math.min(Math.max(minHeight, privateHeight), maxHeight);
                        child.setPrivate("height", privateHeight);
                    }
                }
            }
        });
        //}
        let prevY = paddingTop;
        Object(_Layout__WEBPACK_IMPORTED_MODULE_0__["eachChildren"])(container, (child) => {
            if (child.get("position") == "relative") {
                if (child.isVisible()) {
                    let bounds = child.adjustedLocalBounds();
                    let marginTop = child.get("marginTop", 0);
                    let top = bounds.top;
                    let bottom = bounds.bottom;
                    let maxHeight = child.get("maxHeight");
                    if (maxHeight) {
                        if (bottom - top > maxHeight) {
                            bottom = top + maxHeight;
                        }
                    }
                    let marginBottom = child.get("marginBottom", 0);
                    let y = prevY + marginTop - top;
                    child.setPrivate("y", y);
                    prevY = y + bottom + marginBottom;
                }
                else {
                    child.setPrivate("y", undefined);
                }
            }
        });
    }
}
Object.defineProperty(VerticalLayout, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "VerticalLayout"
});
Object.defineProperty(VerticalLayout, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Layout__WEBPACK_IMPORTED_MODULE_0__["Layout"].classNames.concat([VerticalLayout.className])
});
//# sourceMappingURL=VerticalLayout.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/CanvasRenderer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/backend/CanvasRenderer.js ***!
  \******************************************************************************************/
/*! exports provided: CanvasPivot, CanvasDisplayObject, CanvasContainer, CanvasGraphics, CanvasText, CanvasTextStyle, CanvasRadialText, CanvasImage, CanvasRendererEvent, CanvasRenderer, CanvasLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasPivot", function() { return CanvasPivot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasDisplayObject", function() { return CanvasDisplayObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasContainer", function() { return CanvasContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasGraphics", function() { return CanvasGraphics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasText", function() { return CanvasText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTextStyle", function() { return CanvasTextStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRadialText", function() { return CanvasRadialText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasImage", function() { return CanvasImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRendererEvent", function() { return CanvasRendererEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return CanvasRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasLayer", function() { return CanvasLayer; });
/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Renderer */ "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js");
/* harmony import */ var _util_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _util_Matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Matrix */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Matrix.js");
/* harmony import */ var _util_Percent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _util_Disposer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _util_TextFormatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Object__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony import */ var svg_arc_to_cubic_bezier__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! svg-arc-to-cubic-bezier */ "./node_modules/svg-arc-to-cubic-bezier/modules/index.js");
/** @ignore */ /** */




//import { Throttler } from "../../util/Throttler";








/**
 * @ignore
 */
function checkArgs(name, actual, expected) {
    if (actual !== expected) {
        throw new Error("Required " + expected + " arguments for " + name + " but got " + actual);
    }
}
/**
 * @ignore
 */
function checkMinArgs(name, actual, expected) {
    if (actual < expected) {
        throw new Error("Required at least " + expected + " arguments for " + name + " but got " + actual);
    }
}
/**
 * @ignore
 */
function checkEvenArgs(name, actual, expected) {
    checkMinArgs(name, actual, expected);
    if ((actual % expected) !== 0) {
        throw new Error("Arguments for " + name + " must be in pairs of " + expected);
    }
}
/**
 * @ignore
 * This splits the flag so that way 0017 will be processed as 0 0 17
 *
 * This is important for weird paths like `M17 5A1 1 0 0017 30 1 1 0 0017 5`
 */
function splitArcFlags(args) {
    for (let i = 0; i < args.length; i += 7) {
        let index = i + 3;
        let flag = args[index];
        if (flag.length > 1) {
            const a = /^([01])([01])(.*)$/.exec(flag);
            if (a !== null) {
                args.splice(index, 0, a[1]);
                ++index;
                args.splice(index, 0, a[2]);
                ++index;
                if (a[3].length > 0) {
                    args[index] = a[3];
                }
                else {
                    args.splice(index, 1);
                }
            }
        }
        ++index;
        flag = args[index];
        if (flag.length > 1) {
            const a = /^([01])(.+)$/.exec(flag);
            if (a !== null) {
                args.splice(index, 0, a[1]);
                ++index;
                args[index] = a[2];
            }
        }
    }
}
/**
 * @ignore
 */
function assertBinary(value) {
    if (value === 0 || value === 1) {
        return value;
    }
    else {
        throw new Error("Flag must be 0 or 1");
    }
}
//  1 -> 0xffffff * (2 / 2)
//  2 -> 0xffffff * (1 / 2)
//
//  3 -> 0xffffff * (3 / 4)
//  4 -> 0xffffff * (1 / 4)
//
//  5 -> 0xffffff * (7 / 8)
//  6 -> 0xffffff * (5 / 8)
//  7 -> 0xffffff * (3 / 8)
//  8 -> 0xffffff * (1 / 8)
//
//  9 -> 0xffffff * (15 / 16)
// 10 -> 0xffffff * (13 / 16)
// 11 -> 0xffffff * (11 / 16)
// 12 -> 0xffffff *  (9 / 16)
// 13 -> 0xffffff *  (7 / 16)
// 14 -> 0xffffff *  (5 / 16)
// 15 -> 0xffffff *  (3 / 16)
// 16 -> 0xffffff *  (1 / 16)
// @todo remove this old color distribution algo if the new one pans out
// function distributeIdBAK(id: number): number {
// 	if (id === 1) {
// 		return 0x000001;
// 	} else {
// 		// Finds the closest power of 2
// 		const base = Math.pow(2, Math.ceil(Math.log(id) / Math.log(2)));
// 		// Translates the id into an odd fraction index
// 		const index = ((base - id) * 2) + 1;
// 		// TODO is Math.round correct ?
// 		return Math.round(0xffffff * (index / base));
// 	}
// }
/**
 * Function by smeans:
 * https://lowcode.life/generating-unique-contrasting-colors-in-javascript/
 * @ignore
 */
function distributeId(id) {
    const rgb = [0, 0, 0];
    for (let i = 0; i < 24; i++) {
        rgb[i % 3] <<= 1;
        rgb[i % 3] |= id & 0x01;
        id >>= 1;
    }
    return (rgb[2] | 0) + (rgb[1] << 8) + (rgb[0] << 16);
}
/**
 * @ignore
 */
function eachTargets(hitTarget, f) {
    for (;;) {
        if (hitTarget.interactive) {
            if (!f(hitTarget)) {
                break;
            }
        }
        if (hitTarget._parent) {
            hitTarget = hitTarget._parent;
        }
        else {
            break;
        }
    }
}
// TODO feature detection for mouse/touch/pointer
/**
 * @ignore
 */
function onPointerEvent(element, name, f) {
    return _util_Utils__WEBPACK_IMPORTED_MODULE_6__["addEventListener"](element, _util_Utils__WEBPACK_IMPORTED_MODULE_6__["getRendererEvent"](name), (event) => {
        let touches = event.touches;
        if (touches) {
            if (touches.length == 0) {
                touches = event.changedTouches;
            }
            f(_util_Array__WEBPACK_IMPORTED_MODULE_7__["copy"](touches));
        }
        else {
            f([event]);
        }
    });
}
/**
 * @ignore
 */
function isTainted(image) {
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const context = canvas.getContext("2d", { willReadFrequently: true });
    context.drawImage(image, 0, 0, 1, 1);
    try {
        context.getImageData(0, 0, 1, 1);
        return false;
    }
    catch (err) {
        console.warn("Image \"" + image.src + "\" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors");
        return true;
    }
}
/**
 * This is needed to workaround a bug in iOS which causes it to not GC canvas elements.
 *
 * @ignore
 */
function clearCanvas(view) {
    view.width = 0;
    view.height = 0;
    view.style.width = "0px";
    view.style.height = "0px";
}
/**
 * @ignore
 */
class CanvasPivot {
    constructor() {
        Object.defineProperty(this, "_x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    get x() {
        return this._x;
    }
    get y() {
        return this._y;
    }
    set x(value) {
        this._x = value;
    }
    set y(value) {
        this._y = value;
    }
}
/**
 * @ignore
 */
class CanvasDisplayObject extends _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["DisposerClass"] {
    constructor(renderer) {
        super();
        Object.defineProperty(this, "_layer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "visible", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "exportable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "interactive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "inactive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "wheelable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "cancelTouch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "isMeasured", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "buttonMode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "alpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "compoundAlpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "angle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "scale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "crisp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "pivot", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new CanvasPivot()
        });
        Object.defineProperty(this, "filter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cursorOverStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_replacedCursorStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_localMatrix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_Matrix__WEBPACK_IMPORTED_MODULE_2__["Matrix"]()
        });
        Object.defineProperty(this, "_matrix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_Matrix__WEBPACK_IMPORTED_MODULE_2__["Matrix"]()
        });
        // TODO can this be replaced with _localMatrix ?
        Object.defineProperty(this, "_uMatrix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _util_Matrix__WEBPACK_IMPORTED_MODULE_2__["Matrix"]()
        });
        Object.defineProperty(this, "_renderer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_localBounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_bounds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_colorId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._renderer = renderer;
    }
    _dispose() {
        this._renderer._removeObject(this);
        this.getLayer().dirty = true;
    }
    getCanvas() {
        return this.getLayer().view;
    }
    getLayer() {
        let self = this;
        for (;;) {
            if (self._layer) {
                return self._layer;
            }
            else if (self._parent) {
                self = self._parent;
            }
            else {
                return this._renderer.defaultLayer;
            }
        }
    }
    setLayer(order, margin) {
        if (order == null) {
            this._layer = undefined;
        }
        else {
            const visible = true;
            this._layer = this._renderer.getLayer(order, visible);
            this._layer.visible = visible;
            this._layer.margin = margin;
            if (margin) {
                _util_Utils__WEBPACK_IMPORTED_MODULE_6__["setInteractive"](this._layer.view, false);
            }
            this._renderer._ghostLayer.setMargin(this._renderer.layers);
            if (this._parent) {
                this._parent.registerChildLayer(this._layer);
            }
            this._layer.dirty = true;
            this._renderer.resizeLayer(this._layer);
            this._renderer.resizeGhost();
        }
    }
    markDirtyLayer() {
        this.getLayer().dirty = true;
    }
    clear() {
        this.invalidateBounds();
    }
    invalidateBounds() {
        this._localBounds = undefined;
    }
    _addBounds(_bounds) { }
    _getColorId() {
        if (this._colorId === undefined) {
            this._colorId = this._renderer.paintId(this);
        }
        return this._colorId;
    }
    _isInteractive() {
        return this.inactive == false && (this.interactive || this._renderer._forceInteractive > 0);
    }
    _isInteractiveMask() {
        return this._isInteractive();
    }
    contains(child) {
        for (;;) {
            if (child === this) {
                return true;
            }
            else if (child._parent) {
                child = child._parent;
            }
            else {
                return false;
            }
        }
    }
    toGlobal(point) {
        return this._matrix.apply(point);
    }
    toLocal(point) {
        return this._matrix.applyInverse(point);
    }
    getLocalMatrix() {
        this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale);
        return this._uMatrix;
    }
    getLocalBounds() {
        if (!this._localBounds) {
            const bn = 10000000;
            this._localBounds = {
                left: bn,
                top: bn,
                right: -bn,
                bottom: -bn
            };
            this._addBounds(this._localBounds);
        }
        return this._localBounds;
    }
    getAdjustedBounds(bounds) {
        this._setMatrix();
        const matrix = this.getLocalMatrix();
        const p0 = matrix.apply({ x: bounds.left, y: bounds.top });
        const p1 = matrix.apply({ x: bounds.right, y: bounds.top });
        const p2 = matrix.apply({ x: bounds.right, y: bounds.bottom });
        const p3 = matrix.apply({ x: bounds.left, y: bounds.bottom });
        return {
            left: Math.min(p0.x, p1.x, p2.x, p3.x),
            top: Math.min(p0.y, p1.y, p2.y, p3.y),
            right: Math.max(p0.x, p1.x, p2.x, p3.x),
            bottom: Math.max(p0.y, p1.y, p2.y, p3.y)
        };
    }
    on(key, callback, context) {
        if (this.interactive) {
            return this._renderer._addEvent(this, key, callback, context);
        }
        else {
            return new _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["Disposer"](() => { });
        }
    }
    _setMatrix() {
        // TODO only calculate this if it has actually changed
        this._localMatrix.setTransform(this.x, this.y, this.pivot.x, this.pivot.y, 
        // Converts degrees to radians
        this.angle * Math.PI / 180, this.scale);
        this._matrix.copyFrom(this._localMatrix);
        if (this._parent) {
            // TODO only calculate this if it has actually changed
            this._matrix.prepend(this._parent._matrix);
        }
    }
    _transform(context, resolution) {
        const m = this._matrix;
        let tx = m.tx * resolution;
        let ty = m.ty * resolution;
        if (this.crisp) {
            tx = Math.floor(tx) + .5;
            ty = Math.floor(ty) + .5;
        }
        context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, tx, ty);
    }
    _transformMargin(context, resolution, margin) {
        const m = this._matrix;
        context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, (m.tx + margin.left) * resolution, (m.ty + margin.top) * resolution);
    }
    _transformLayer(context, resolution, layer) {
        if (layer.margin) {
            this._transformMargin(context, layer.scale || resolution, layer.margin);
        }
        else {
            this._transform(context, layer.scale || resolution);
        }
    }
    render(parentLayer) {
        if (this.visible && (this.exportable !== false || !this._renderer._omitTainted)) {
            this._setMatrix();
            const resolution = this._renderer.resolution;
            const layers = this._renderer.layers;
            const ghostLayer = this._renderer._ghostLayer;
            const ghostContext = ghostLayer.context;
            const mask = this.mask;
            if (mask) {
                mask._setMatrix();
            }
            // TODO improve this
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](layers, (layer) => {
                if (layer) {
                    const context = layer.context;
                    context.save();
                    // We must apply the mask before we transform the element
                    if (mask) {
                        mask._transformLayer(context, resolution, layer);
                        mask._runPath(context);
                        context.clip();
                    }
                    context.globalAlpha = this.compoundAlpha * this.alpha;
                    this._transformLayer(context, resolution, layer);
                    if (this.filter) {
                        context.filter = this.filter;
                    }
                }
            });
            ghostContext.save();
            // We must apply the mask before we transform the element
            if (mask && this._isInteractiveMask()) {
                mask._transformMargin(ghostContext, resolution, ghostLayer.margin);
                mask._runPath(ghostContext);
                ghostContext.clip();
            }
            this._transformMargin(ghostContext, resolution, ghostLayer.margin);
            this._render(parentLayer);
            ghostContext.restore();
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](layers, (layer) => {
                if (layer) {
                    layer.context.restore();
                }
            });
        }
    }
    _render(parentLayer) {
        if (this.exportable === false) {
            const layer = this._layer || parentLayer;
            layer.tainted = true;
        }
    }
    hovering() {
        return this._renderer._hovering.has(this);
    }
    dragging() {
        return this._renderer._dragging.some((x) => x.value === this);
    }
    shouldCancelTouch() {
        const renderer = this._renderer;
        if (renderer.tapToActivate && !renderer._touchActive) {
            return false;
        }
        if (this.cancelTouch) {
            return true;
        }
        else if (this._parent) {
            return this._parent.shouldCancelTouch();
        }
        return false;
    }
}
/**
 * @ignore
 */
class CanvasContainer extends CanvasDisplayObject {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "interactiveChildren", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_childLayers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    _isInteractiveMask() {
        return this.interactiveChildren || super._isInteractiveMask();
    }
    addChild(child) {
        child._parent = this;
        this._children.push(child);
        if (child._layer) {
            this.registerChildLayer(child._layer);
        }
    }
    addChildAt(child, index) {
        child._parent = this;
        this._children.splice(index, 0, child);
        if (child._layer) {
            this.registerChildLayer(child._layer);
        }
    }
    removeChild(child) {
        child._parent = undefined;
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["removeFirst"](this._children, child);
    }
    _render(parentLayer) {
        super._render(parentLayer);
        const renderer = this._renderer;
        if (this.interactive && this.interactiveChildren) {
            ++renderer._forceInteractive;
        }
        const layer = this._layer || parentLayer;
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._children, (child) => {
            child.compoundAlpha = this.compoundAlpha * this.alpha;
            child.render(layer);
        });
        if (this.interactive && this.interactiveChildren) {
            --renderer._forceInteractive;
        }
    }
    registerChildLayer(layer) {
        if (!this._childLayers) {
            this._childLayers = [];
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["pushOne"](this._childLayers, layer);
        if (this._parent) {
            this._parent.registerChildLayer(layer);
        }
    }
    markDirtyLayer(deep = false) {
        super.markDirtyLayer();
        if (deep && this._childLayers) {
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._childLayers, (layer) => layer.dirty = true);
        }
    }
    _dispose() {
        super._dispose();
        if (this._childLayers) {
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._childLayers, (layer) => {
                layer.dirty = true;
            });
        }
    }
}
/**
 * @ignore
 */
function setPoint(bounds, point) {
    bounds.left = Math.min(bounds.left, point.x);
    bounds.top = Math.min(bounds.top, point.y);
    bounds.right = Math.max(bounds.right, point.x);
    bounds.bottom = Math.max(bounds.bottom, point.y);
}
/**
 * @ignore
 */
class Op {
    colorize(_context, _forceColor) { }
    path(_context) { }
    addBounds(_bounds) { }
}
/**
 * @ignore
 */
class BeginPath extends Op {
    colorize(context, _forceColor) {
        context.beginPath();
    }
}
/**
 * @ignore
 */
class BeginFill extends Op {
    constructor(color) {
        super();
        Object.defineProperty(this, "color", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: color
        });
    }
    colorize(context, forceColor) {
        if (forceColor !== undefined) {
            context.fillStyle = forceColor;
        }
        else {
            context.fillStyle = this.color;
        }
    }
}
/**
 * @ignore
 */
class EndFill extends Op {
    constructor(clearShadow) {
        super();
        Object.defineProperty(this, "clearShadow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: clearShadow
        });
    }
    colorize(context, _forceColor) {
        context.fill();
        if (this.clearShadow) {
            context.shadowColor = "";
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
        }
    }
}
/**
 * @ignore
 */
class EndStroke extends Op {
    colorize(context, _forceColor) {
        context.stroke();
    }
}
/**
 * @ignore
 */
class LineStyle extends Op {
    constructor(width, color, lineJoin) {
        super();
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: width
        });
        Object.defineProperty(this, "color", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: color
        });
        Object.defineProperty(this, "lineJoin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: lineJoin
        });
    }
    colorize(context, forceColor) {
        if (forceColor !== undefined) {
            context.strokeStyle = forceColor;
        }
        else {
            context.strokeStyle = this.color;
        }
        context.lineWidth = this.width;
        if (this.lineJoin) {
            context.lineJoin = this.lineJoin;
        }
    }
}
/**
 * @ignore
 */
class LineDash extends Op {
    constructor(dash) {
        super();
        Object.defineProperty(this, "dash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dash
        });
    }
    colorize(context, _forceColor) {
        context.setLineDash(this.dash);
    }
}
/**
 * @ignore
 */
class LineDashOffset extends Op {
    constructor(dashOffset) {
        super();
        Object.defineProperty(this, "dashOffset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dashOffset
        });
    }
    colorize(context, _forceColor) {
        context.lineDashOffset = this.dashOffset;
    }
}
/**
 * @ignore
 */
class DrawRect extends Op {
    constructor(x, y, width, height) {
        super();
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: width
        });
        Object.defineProperty(this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: height
        });
    }
    path(context) {
        context.rect(this.x, this.y, this.width, this.height);
    }
    addBounds(bounds) {
        const l = this.x;
        const t = this.y;
        const r = l + this.width;
        const b = t + this.height;
        setPoint(bounds, { x: l, y: t });
        setPoint(bounds, { x: r, y: t });
        setPoint(bounds, { x: l, y: b });
        setPoint(bounds, { x: r, y: b });
    }
}
/**
 * @ignore
 */
class DrawCircle extends Op {
    constructor(x, y, radius) {
        super();
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        Object.defineProperty(this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radius
        });
    }
    path(context) {
        context.moveTo(this.x + this.radius, this.y);
        context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
    }
    // TODO handle skewing and rotation
    addBounds(bounds) {
        setPoint(bounds, { x: this.x - this.radius, y: this.y - this.radius });
        setPoint(bounds, { x: this.x + this.radius, y: this.y + this.radius });
    }
}
/**
 * @ignore
 */
class DrawEllipse extends Op {
    constructor(x, y, radiusX, radiusY) {
        super();
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
        Object.defineProperty(this, "radiusX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radiusX
        });
        Object.defineProperty(this, "radiusY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radiusY
        });
    }
    path(context) {
        context.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);
    }
    // TODO handle skewing and rotation
    addBounds(bounds) {
        setPoint(bounds, { x: this.x - this.radiusX, y: this.y - this.radiusY });
        setPoint(bounds, { x: this.x + this.radiusX, y: this.y + this.radiusY });
    }
}
/**
 * @ignore
 */
class Arc extends Op {
    constructor(cx, cy, radius, startAngle, endAngle, anticlockwise) {
        super();
        Object.defineProperty(this, "cx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cx
        });
        Object.defineProperty(this, "cy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cy
        });
        Object.defineProperty(this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radius
        });
        Object.defineProperty(this, "startAngle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: startAngle
        });
        Object.defineProperty(this, "endAngle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: endAngle
        });
        Object.defineProperty(this, "anticlockwise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: anticlockwise
        });
    }
    path(context) {
        if (this.radius > 0) {
            context.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
        }
    }
    addBounds(bounds) {
        let arcBounds = _util_Math__WEBPACK_IMPORTED_MODULE_10__["getArcBounds"](this.cx, this.cy, this.startAngle * _util_Math__WEBPACK_IMPORTED_MODULE_10__["DEGREES"], this.endAngle * _util_Math__WEBPACK_IMPORTED_MODULE_10__["DEGREES"], this.radius);
        setPoint(bounds, { x: arcBounds.left, y: arcBounds.top });
        setPoint(bounds, { x: arcBounds.right, y: arcBounds.bottom });
    }
}
/**
 * @ignore
 */
class ArcTo extends Op {
    constructor(x1, y1, x2, y2, radius) {
        super();
        Object.defineProperty(this, "x1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x1
        });
        Object.defineProperty(this, "y1", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y1
        });
        Object.defineProperty(this, "x2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x2
        });
        Object.defineProperty(this, "y2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y2
        });
        Object.defineProperty(this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: radius
        });
    }
    path(context) {
        if (this.radius > 0) {
            context.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);
        }
    }
    // TODO: add points
    addBounds(_bounds) {
        /*
        // not finished
        https://math.stackexchange.com/questions/1781438/finding-the-center-of-a-circle-given-two-points-and-a-radius-algebraically

        if (prevPoint) {
            let x1 = prevPoint.x;
            let y1 = prevPoint.y;
            let x2 = this.x2;
            let y2 = this.y2;
            let r = this.radius;

            let xa = (x2 - x1) / 2;
            let ya = (y2 - y1) / 2;

            let x0 = x1 + xa;
            let y0 = y1 + ya;

            let a = Math.hypot(xa, ya);
            let b = Math.sqrt(r * r - a * a);

            let cx = x0 + b * ya / a;
            let cy = y0 - b * xa / a;

            console.log(cx, cy);
        }*/
    }
}
/**
 * @ignore
 */
class LineTo extends Op {
    constructor(x, y) {
        super();
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
    }
    path(context) {
        context.lineTo(this.x, this.y);
    }
    addBounds(bounds) {
        setPoint(bounds, { x: this.x, y: this.y });
    }
}
/**
 * @ignore
 */
class MoveTo extends Op {
    constructor(x, y) {
        super();
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
    }
    path(context) {
        context.moveTo(this.x, this.y);
    }
    addBounds(bounds) {
        setPoint(bounds, { x: this.x, y: this.y });
    }
}
/**
 * @ignore
 */
class ClosePath extends Op {
    path(context) {
        context.closePath();
    }
}
/**
 * @ignore
 */
class BezierCurveTo extends Op {
    constructor(cpX, cpY, cpX2, cpY2, toX, toY) {
        super();
        Object.defineProperty(this, "cpX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpX
        });
        Object.defineProperty(this, "cpY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpY
        });
        Object.defineProperty(this, "cpX2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpX2
        });
        Object.defineProperty(this, "cpY2", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpY2
        });
        Object.defineProperty(this, "toX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toX
        });
        Object.defineProperty(this, "toY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toY
        });
    }
    path(context) {
        context.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);
    }
    // TODO: OK?
    addBounds(bounds) {
        setPoint(bounds, { x: this.cpX, y: this.cpY });
        setPoint(bounds, { x: this.cpX2, y: this.cpY2 });
        setPoint(bounds, { x: this.toX, y: this.toY });
    }
}
/**
 * @ignore
 */
class QuadraticCurveTo extends Op {
    constructor(cpX, cpY, toX, toY) {
        super();
        Object.defineProperty(this, "cpX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpX
        });
        Object.defineProperty(this, "cpY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: cpY
        });
        Object.defineProperty(this, "toX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toX
        });
        Object.defineProperty(this, "toY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: toY
        });
    }
    path(context) {
        context.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);
    }
    // TODO: OK?
    addBounds(bounds) {
        setPoint(bounds, { x: this.cpX, y: this.cpY });
        setPoint(bounds, { x: this.toX, y: this.toY });
    }
}
/**
 * @ignore
 */
class Shadow extends Op {
    constructor(color, blur, offsetX, offsetY, opacity) {
        super();
        Object.defineProperty(this, "color", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: color
        });
        Object.defineProperty(this, "blur", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: blur
        });
        Object.defineProperty(this, "offsetX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: offsetX
        });
        Object.defineProperty(this, "offsetY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: offsetY
        });
        Object.defineProperty(this, "opacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: opacity
        });
    }
    colorize(context, _forceColor) {
        if (this.opacity) {
            context.fillStyle = this.color;
        }
        context.shadowColor = this.color;
        context.shadowBlur = this.blur;
        context.shadowOffsetX = this.offsetX;
        context.shadowOffsetY = this.offsetY;
    }
}
/**
 * @ignore
 */
class GraphicsImage extends Op {
    constructor(image, width, height, x, y) {
        super();
        Object.defineProperty(this, "image", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: image
        });
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: width
        });
        Object.defineProperty(this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: height
        });
        Object.defineProperty(this, "x", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: x
        });
        Object.defineProperty(this, "y", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: y
        });
    }
    path(context) {
        context.drawImage(this.image, this.x, this.y, this.width, this.height);
    }
    // TODO: OK?
    addBounds(bounds) {
        setPoint(bounds, { x: this.x, y: this.y });
        setPoint(bounds, { x: this.width, y: this.height });
    }
}
/**
 * @ignore
 */
class CanvasGraphics extends CanvasDisplayObject {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_operations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "blendMode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _Renderer__WEBPACK_IMPORTED_MODULE_0__["BlendMode"].NORMAL
        });
        Object.defineProperty(this, "_hasShadows", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_fillAlpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_strokeAlpha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    clear() {
        super.clear();
        this._operations.length = 0;
    }
    _pushOp(op) {
        this._operations.push(op);
    }
    beginFill(color, alpha = 1) {
        this._fillAlpha = alpha;
        if (color) {
            if (color instanceof _util_Color__WEBPACK_IMPORTED_MODULE_1__["Color"]) {
                this._pushOp(new BeginFill(color.toCSS(alpha)));
            }
            else {
                this.isMeasured = true;
                this._pushOp(new BeginFill(color));
            }
        }
        else {
            this._pushOp(new BeginFill("rgba(0, 0, 0, " + alpha + ")"));
        }
    }
    endFill() {
        this._pushOp(new EndFill(this._hasShadows));
    }
    endStroke() {
        this._pushOp(new EndStroke());
    }
    beginPath() {
        this._pushOp(new BeginPath());
    }
    lineStyle(width = 0, color, alpha = 1, lineJoin) {
        this._strokeAlpha = alpha;
        if (color) {
            if (color instanceof _util_Color__WEBPACK_IMPORTED_MODULE_1__["Color"]) {
                this._pushOp(new LineStyle(width, color.toCSS(alpha), lineJoin));
            }
            else {
                this._pushOp(new LineStyle(width, color, lineJoin));
            }
        }
        else {
            this._pushOp(new LineStyle(width, "rgba(0, 0, 0, " + alpha + ")", lineJoin));
        }
    }
    setLineDash(dash) {
        this._pushOp(new LineDash(dash ? dash : []));
    }
    setLineDashOffset(dashOffset = 0) {
        this._pushOp(new LineDashOffset(dashOffset));
    }
    drawRect(x, y, width, height) {
        this._pushOp(new DrawRect(x, y, width, height));
    }
    drawCircle(x, y, radius) {
        this._pushOp(new DrawCircle(x, y, radius));
    }
    drawEllipse(x, y, radiusX, radiusY) {
        this._pushOp(new DrawEllipse(x, y, radiusX, radiusY));
    }
    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
        this._pushOp(new Arc(cx, cy, radius, startAngle, endAngle, anticlockwise));
    }
    arcTo(x1, y1, x2, y2, radius) {
        this._pushOp(new ArcTo(x1, y1, x2, y2, radius));
    }
    lineTo(x, y) {
        this._pushOp(new LineTo(x, y));
    }
    moveTo(x, y) {
        this._pushOp(new MoveTo(x, y));
    }
    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._pushOp(new BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY));
    }
    quadraticCurveTo(cpX, cpY, toX, toY) {
        this._pushOp(new QuadraticCurveTo(cpX, cpY, toX, toY));
    }
    closePath() {
        this._pushOp(new ClosePath());
    }
    shadow(color, blur = 0, offsetX = 0, offsetY = 0, opacity) {
        this._hasShadows = true;
        this._pushOp(new Shadow(opacity ? color.toCSS(opacity) : color.toCSS(this._fillAlpha || this._strokeAlpha), blur, offsetX, offsetY));
    }
    image(image, width, height, x, y) {
        this._pushOp(new GraphicsImage(image, width, height, x, y));
    }
    // https://svgwg.org/svg2-draft/paths.html#DProperty
    // TODO better error checking
    svgPath(path) {
        let x = 0;
        let y = 0;
        let cpx = null;
        let cpy = null;
        let qcpx = null;
        let qcpy = null;
        const SEGMENTS_REGEXP = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g;
        const ARGS_REGEXP = /[\u0009\u0020\u000A\u000C\u000D]*([\+\-]?[0-9]*\.?[0-9]+(?:[eE][\+\-]?[0-9]+)?)[\u0009\u0020\u000A\u000C\u000D]*,?/g;
        let match;
        while ((match = SEGMENTS_REGEXP.exec(path)) !== null) {
            const name = match[1];
            const rest = match[2];
            const args = [];
            while ((match = ARGS_REGEXP.exec(rest)) !== null) {
                args.push(match[1]);
            }
            // Reset control point
            if (name !== "S" && name !== "s" && name !== "C" && name !== "c") {
                cpx = null;
                cpy = null;
            }
            // Reset control point
            if (name !== "Q" && name !== "q" && name !== "T" && name !== "t") {
                qcpx = null;
                qcpy = null;
            }
            switch (name) {
                case "M":
                    checkEvenArgs(name, args.length, 2);
                    x = +args[0];
                    y = +args[1];
                    this.moveTo(x, y);
                    for (let i = 2; i < args.length; i += 2) {
                        x = +args[i];
                        y = +args[i + 1];
                        this.lineTo(x, y);
                    }
                    break;
                case "m":
                    checkEvenArgs(name, args.length, 2);
                    x += +args[0];
                    y += +args[1];
                    this.moveTo(x, y);
                    for (let i = 2; i < args.length; i += 2) {
                        x += +args[i];
                        y += +args[i + 1];
                        this.lineTo(x, y);
                    }
                    break;
                case "L":
                    checkEvenArgs(name, args.length, 2);
                    for (let i = 0; i < args.length; i += 2) {
                        x = +args[i];
                        y = +args[i + 1];
                        this.lineTo(x, y);
                    }
                    break;
                case "l":
                    checkEvenArgs(name, args.length, 2);
                    for (let i = 0; i < args.length; i += 2) {
                        x += +args[i];
                        y += +args[i + 1];
                        this.lineTo(x, y);
                    }
                    break;
                case "H":
                    checkMinArgs(name, args.length, 1);
                    for (let i = 0; i < args.length; ++i) {
                        x = +args[i];
                        this.lineTo(x, y);
                    }
                    break;
                case "h":
                    checkMinArgs(name, args.length, 1);
                    for (let i = 0; i < args.length; ++i) {
                        x += +args[i];
                        this.lineTo(x, y);
                    }
                    break;
                case "V":
                    checkMinArgs(name, args.length, 1);
                    for (let i = 0; i < args.length; ++i) {
                        y = +args[i];
                        this.lineTo(x, y);
                    }
                    break;
                case "v":
                    checkMinArgs(name, args.length, 1);
                    for (let i = 0; i < args.length; ++i) {
                        y += +args[i];
                        this.lineTo(x, y);
                    }
                    break;
                case "C":
                    checkEvenArgs(name, args.length, 6);
                    for (let i = 0; i < args.length; i += 6) {
                        const x1 = +args[i];
                        const y1 = +args[i + 1];
                        cpx = +args[i + 2];
                        cpy = +args[i + 3];
                        x = +args[i + 4];
                        y = +args[i + 5];
                        this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                    }
                    break;
                case "c":
                    checkEvenArgs(name, args.length, 6);
                    for (let i = 0; i < args.length; i += 6) {
                        const x1 = +args[i] + x;
                        const y1 = +args[i + 1] + y;
                        cpx = +args[i + 2] + x;
                        cpy = +args[i + 3] + y;
                        x += +args[i + 4];
                        y += +args[i + 5];
                        this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                    }
                    break;
                case "S":
                    checkEvenArgs(name, args.length, 4);
                    if (cpx === null || cpy === null) {
                        cpx = x;
                        cpy = y;
                    }
                    for (let i = 0; i < args.length; i += 4) {
                        const x1 = 2 * x - cpx;
                        const y1 = 2 * y - cpy;
                        cpx = +args[i];
                        cpy = +args[i + 1];
                        x = +args[i + 2];
                        y = +args[i + 3];
                        this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                    }
                    break;
                case "s":
                    checkEvenArgs(name, args.length, 4);
                    if (cpx === null || cpy === null) {
                        cpx = x;
                        cpy = y;
                    }
                    for (let i = 0; i < args.length; i += 4) {
                        const x1 = 2 * x - cpx;
                        const y1 = 2 * y - cpy;
                        cpx = +args[i] + x;
                        cpy = +args[i + 1] + y;
                        x += +args[i + 2];
                        y += +args[i + 3];
                        this.bezierCurveTo(x1, y1, cpx, cpy, x, y);
                    }
                    break;
                case "Q":
                    checkEvenArgs(name, args.length, 4);
                    for (let i = 0; i < args.length; i += 4) {
                        qcpx = +args[i];
                        qcpy = +args[i + 1];
                        x = +args[i + 2];
                        y = +args[i + 3];
                        this.quadraticCurveTo(qcpx, qcpy, x, y);
                    }
                    break;
                case "q":
                    checkEvenArgs(name, args.length, 4);
                    for (let i = 0; i < args.length; i += 4) {
                        qcpx = +args[i] + x;
                        qcpy = +args[i + 1] + y;
                        x += +args[i + 2];
                        y += +args[i + 3];
                        this.quadraticCurveTo(qcpx, qcpy, x, y);
                    }
                    break;
                case "T":
                    checkEvenArgs(name, args.length, 2);
                    if (qcpx === null || qcpy === null) {
                        qcpx = x;
                        qcpy = y;
                    }
                    for (let i = 0; i < args.length; i += 2) {
                        qcpx = 2 * x - qcpx;
                        qcpy = 2 * y - qcpy;
                        x = +args[i];
                        y = +args[i + 1];
                        this.quadraticCurveTo(qcpx, qcpy, x, y);
                    }
                    break;
                case "t":
                    checkEvenArgs(name, args.length, 2);
                    if (qcpx === null || qcpy === null) {
                        qcpx = x;
                        qcpy = y;
                    }
                    for (let i = 0; i < args.length; i += 2) {
                        qcpx = 2 * x - qcpx;
                        qcpy = 2 * y - qcpy;
                        x += +args[i];
                        y += +args[i + 1];
                        this.quadraticCurveTo(qcpx, qcpy, x, y);
                    }
                    break;
                case "A":
                case "a":
                    const relative = (name === "a");
                    splitArcFlags(args);
                    checkEvenArgs(name, args.length, 7);
                    for (let i = 0; i < args.length; i += 7) {
                        let cx = +args[i + 5];
                        let cy = +args[i + 6];
                        if (relative) {
                            cx += x;
                            cy += y;
                        }
                        const bs = Object(svg_arc_to_cubic_bezier__WEBPACK_IMPORTED_MODULE_11__["default"])({
                            px: x,
                            py: y,
                            rx: +args[i],
                            ry: +args[i + 1],
                            xAxisRotation: +args[i + 2],
                            largeArcFlag: assertBinary(+args[i + 3]),
                            sweepFlag: assertBinary(+args[i + 4]),
                            cx,
                            cy,
                        });
                        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](bs, (b) => {
                            this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y);
                            x = b.x;
                            y = b.y;
                        });
                    }
                    break;
                case "Z":
                case "z":
                    checkArgs(name, args.length, 0);
                    this.closePath();
                    break;
            }
        }
    }
    _runPath(context) {
        context.beginPath();
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._operations, (op) => {
            op.path(context);
        });
    }
    _render(parentLayer) {
        super._render(parentLayer);
        const layer = this._layer || parentLayer;
        const layerDirty = layer.dirty;
        const interactive = this._isInteractive();
        if (layerDirty || interactive) {
            const context = layer.context;
            const ghostContext = this._renderer._ghostLayer.context;
            if (layerDirty) {
                context.globalCompositeOperation = this.blendMode;
                context.beginPath();
            }
            let color;
            if (interactive) {
                ghostContext.beginPath();
                color = this._getColorId();
            }
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._operations, (op) => {
                if (layerDirty) {
                    op.path(context);
                    op.colorize(context, undefined);
                }
                if (interactive) {
                    op.path(ghostContext);
                    op.colorize(ghostContext, color);
                }
            });
        }
    }
    renderDetached(context) {
        if (this.visible) {
            this._setMatrix();
            context.save();
            // We must apply the mask before we transform the element
            const mask = this.mask;
            if (mask) {
                mask._setMatrix();
                mask._transform(context, 1);
                mask._runPath(context);
                context.clip();
            }
            // TODO handle compoundAlpha somehow ?
            context.globalAlpha = this.compoundAlpha * this.alpha;
            this._transform(context, 1);
            if (this.filter) {
                context.filter = this.filter;
            }
            context.globalCompositeOperation = this.blendMode;
            context.beginPath();
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._operations, (op) => {
                op.path(context);
                op.colorize(context, undefined);
            });
            context.restore();
        }
    }
    _addBounds(bounds) {
        if (this.visible && this.isMeasured) {
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._operations, (op) => {
                op.addBounds(bounds);
            });
        }
    }
}
/**
 * @ignore
 */
class CanvasText extends CanvasDisplayObject {
    constructor(renderer, text, style) {
        super(renderer);
        Object.defineProperty(this, "text", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "style", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolution", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        Object.defineProperty(this, "textVisible", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_textInfo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_originalScale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1
        });
        this.text = text;
        this.style = style;
    }
    invalidateBounds() {
        super.invalidateBounds();
        this._textInfo = undefined;
    }
    _shared(context) {
        if (this.style.textAlign) {
            context.textAlign = this.style.textAlign;
        }
        if (this.style.direction) {
            context.direction = this.style.direction;
        }
        if (this.style.textBaseline) {
            context.textBaseline = this.style.textBaseline;
        }
    }
    _prerender(layer, ignoreGhost = false, ignoreFontWeight = false) {
        super._render(layer);
        const context = layer.context;
        const ghostContext = this._renderer._ghostLayer.context;
        // Font style
        const style = this.style;
        let fontStyle = this._getFontStyle(undefined, ignoreFontWeight);
        context.font = fontStyle;
        if (this._isInteractive() && !ignoreGhost) {
            ghostContext.font = fontStyle;
        }
        // Other parameters
        if (style.fill) {
            if (style.fill instanceof _util_Color__WEBPACK_IMPORTED_MODULE_1__["Color"]) {
                context.fillStyle = style.fill.toCSS(style.fillOpacity != undefined ? style.fillOpacity : 1);
            }
            else {
                context.fillStyle = style.fill;
            }
        }
        if (style.shadowColor) {
            layer.context.shadowColor = style.shadowColor.toCSS(style.shadowOpacity || 1);
        }
        if (style.shadowBlur) {
            layer.context.shadowBlur = style.shadowBlur;
        }
        if (style.shadowOffsetX) {
            layer.context.shadowOffsetX = style.shadowOffsetX;
        }
        if (style.shadowOffsetY) {
            layer.context.shadowOffsetY = style.shadowOffsetY;
        }
        this._shared(context);
        if (this._isInteractive() && !ignoreGhost) {
            ghostContext.fillStyle = this._getColorId();
            this._shared(ghostContext);
        }
    }
    _getFontStyle(style2, ignoreFontWeight = false) {
        // Process defaults
        const style = this.style;
        let fontStyle = [];
        if (style2 && style2.fontVariant) {
            fontStyle.push(style2.fontVariant);
        }
        else if (style.fontVariant) {
            fontStyle.push(style.fontVariant);
        }
        if (!ignoreFontWeight) {
            if (style2 && style2.fontWeight) {
                fontStyle.push(style2.fontWeight);
            }
            else if (style.fontWeight) {
                fontStyle.push(style.fontWeight);
            }
        }
        if (style2 && style2.fontStyle) {
            fontStyle.push(style2.fontStyle);
        }
        else if (style.fontStyle) {
            fontStyle.push(style.fontStyle);
        }
        if (style2 && style2.fontSize) {
            if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](style2.fontSize)) {
                style2.fontSize = style2.fontSize + "px";
            }
            fontStyle.push(style2.fontSize);
        }
        else if (style.fontSize) {
            if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](style.fontSize)) {
                style.fontSize = style.fontSize + "px";
            }
            fontStyle.push(style.fontSize);
        }
        if (style2 && style2.fontFamily) {
            fontStyle.push(style2.fontFamily);
        }
        else if (style.fontFamily) {
            fontStyle.push(style.fontFamily);
        }
        else if (fontStyle.length) {
            fontStyle.push("Arial");
        }
        return fontStyle.join(" ");
    }
    _render(parentLayer) {
        const layer = this._layer || parentLayer;
        // We need measurements in order to properly position text for alignment
        if (!this._textInfo) {
            this._measure(layer);
        }
        if (this.textVisible) {
            const interactive = this._isInteractive();
            const context = layer.context;
            const layerDirty = layer.dirty;
            const ghostContext = this._renderer._ghostLayer.context;
            context.save();
            ghostContext.save();
            this._prerender(layer);
            // const lines = this.text.toString().replace(/\r/g, "").split(/\n/);
            // const x = this._localBounds && (this._localBounds.left < 0) ? Math.abs(this._localBounds.left) : 0;
            // Process text info produced by _measure()
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._textInfo, (line, _index) => {
                _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](line.textChunks, (chunk, _index) => {
                    // Set style
                    if (chunk.style) {
                        context.save();
                        ghostContext.save();
                        context.font = chunk.style;
                        if (this._isInteractive()) {
                            ghostContext.font = chunk.style;
                        }
                    }
                    if (chunk.fill) {
                        context.save();
                        context.fillStyle = chunk.fill.toCSS();
                        // Color does not affect ghostContext so we not set it
                    }
                    // Draw text
                    if (layerDirty) {
                        context.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);
                    }
                    // Draw underline
                    if (chunk.textDecoration == "underline" || chunk.textDecoration == "line-through") {
                        let thickness = 1;
                        let offset = 1;
                        let fontSize = chunk.height;
                        let offsetX = chunk.offsetX;
                        switch (this.style.textAlign) {
                            case "right":
                            case "end":
                                offsetX -= chunk.width;
                                break;
                            case "center":
                                offsetX -= chunk.width / 2;
                                break;
                        }
                        if (chunk.style) {
                            const format = _util_TextFormatter__WEBPACK_IMPORTED_MODULE_5__["TextFormatter"].getTextStyle(chunk.style);
                            switch (format.fontWeight) {
                                case "bolder":
                                case "bold":
                                case "700":
                                case "800":
                                case "900":
                                    thickness = 2;
                                    break;
                            }
                        }
                        if (fontSize) {
                            offset = fontSize / 20;
                        }
                        let y;
                        if (chunk.textDecoration == "line-through") {
                            y = thickness + line.offsetY + chunk.offsetY - chunk.height / 2;
                        }
                        else {
                            y = thickness + offset * 1.5 + line.offsetY + chunk.offsetY;
                        }
                        context.save();
                        context.beginPath();
                        if (chunk.fill) {
                            context.strokeStyle = chunk.fill.toCSS();
                        }
                        else if (this.style.fill && this.style.fill instanceof _util_Color__WEBPACK_IMPORTED_MODULE_1__["Color"]) {
                            context.strokeStyle = this.style.fill.toCSS();
                        }
                        context.lineWidth = thickness * offset;
                        context.moveTo(offsetX, y);
                        context.lineTo(offsetX + chunk.width, y);
                        context.stroke();
                        context.restore();
                    }
                    if (interactive && this.interactive) {
                        // Draw text in ghost canvas ONLY if it is set as interactive
                        // explicitly. This way we avoid hit test anomalies caused by anti
                        // aliasing of text.
                        ghostContext.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);
                    }
                    if (chunk.fill) {
                        context.restore();
                        // Color does not affect ghostContext so we not set it
                    }
                    // Reset style
                    if (chunk.style) {
                        context.restore();
                        ghostContext.restore();
                    }
                });
            });
            context.restore();
            ghostContext.restore();
        }
    }
    _addBounds(bounds) {
        if (this.visible && this.isMeasured) {
            //if (this._textVisible) {
            const x = this._measure(this.getLayer());
            setPoint(bounds, { x: x.left, y: x.top });
            setPoint(bounds, { x: x.right, y: x.bottom });
            //}
        }
    }
    _ignoreFontWeight() {
        return /apple/i.test(navigator.vendor);
    }
    _measure(layer) {
        const context = layer.context;
        const ghostContext = this._renderer._ghostLayer.context;
        const rtl = this.style.direction == "rtl";
        // Reset text info
        this._textInfo = [];
        // Init
        const oversizedBehavior = this.style.oversizedBehavior;
        const maxWidth = this.style.maxWidth;
        const truncate = _util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](maxWidth) && oversizedBehavior == "truncate";
        const wrap = _util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](maxWidth) && (oversizedBehavior == "wrap" || oversizedBehavior == "wrap-no-break");
        // Pre-render
        context.save();
        ghostContext.save();
        this._prerender(layer, true, this._ignoreFontWeight());
        // Get default font metrix
        const refText = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
        // Split up text into lines
        const lines = this.text.toString().replace(/\r/g, "").split(/\n/);
        let styleRestored = true;
        let minX = 0;
        let maxX = 0;
        // Iterate through the lines
        let offsetY = 0;
        let currentStyle;
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](lines, (line, _index) => {
            // Split up line into format/value chunks
            let chunks;
            if (line == "") {
                chunks = [{
                        type: "value",
                        text: ""
                    }];
            }
            else {
                chunks = _util_TextFormatter__WEBPACK_IMPORTED_MODULE_5__["TextFormatter"].chunk(line, false, this.style.ignoreFormatting);
            }
            while (chunks.length > 0) {
                // Init line object
                let lineInfo = {
                    offsetY: offsetY,
                    ascent: 0,
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    textChunks: []
                };
                // Measure reference text
                const metrics = this._measureText(refText, context);
                const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                lineInfo.height = height;
                lineInfo.ascent = metrics.actualBoundingBoxAscent;
                let currentFormat;
                let currentDecoration = this.style.textDecoration;
                let currentFill;
                let currentChunkWidth;
                let skipFurtherText = false;
                let firstTextChunk = true;
                let leftoverChunks = [];
                let currentVerticalAlign;
                //let offsetX = 0;
                //let chunk;
                //while(chunk = chunks.shift()) {
                _util_Array__WEBPACK_IMPORTED_MODULE_7__["eachContinue"](chunks, (chunk, index) => {
                    // Format chunk
                    if (chunk.type == "format") {
                        if (chunk.text == "[/]") {
                            if (!styleRestored) {
                                context.restore();
                                ghostContext.restore();
                                styleRestored = true;
                            }
                            currentFill = undefined;
                            currentStyle = undefined;
                            currentChunkWidth = undefined;
                            currentDecoration = this.style.textDecoration;
                            currentVerticalAlign = undefined;
                            currentFormat = chunk.text;
                        }
                        else {
                            if (!styleRestored) {
                                context.restore();
                                ghostContext.restore();
                            }
                            let format = _util_TextFormatter__WEBPACK_IMPORTED_MODULE_5__["TextFormatter"].getTextStyle(chunk.text);
                            const fontStyle = this._getFontStyle(format);
                            context.save();
                            ghostContext.save();
                            context.font = fontStyle;
                            currentStyle = fontStyle;
                            currentFormat = chunk.text;
                            if (format.textDecoration) {
                                currentDecoration = format.textDecoration;
                            }
                            if (format.fill) {
                                currentFill = format.fill;
                            }
                            if (format.width) {
                                currentChunkWidth = _util_Type__WEBPACK_IMPORTED_MODULE_9__["toNumber"](format.width);
                            }
                            if (format.verticalAlign) {
                                currentVerticalAlign = format.verticalAlign;
                            }
                            styleRestored = false;
                            // Measure reference text after change of format
                            const metrics = this._measureText(refText, context);
                            const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                            if (height > lineInfo.height) {
                                lineInfo.height = height;
                            }
                            if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {
                                lineInfo.ascent = metrics.actualBoundingBoxAscent;
                            }
                        }
                    }
                    // Text chunk
                    else if (chunk.type == "value" && !skipFurtherText) {
                        // Measure
                        const metrics = this._measureText(chunk.text, context);
                        let chunkWidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
                        // Check for fit
                        if (truncate) {
                            // Break words?
                            let breakWords = firstTextChunk || this.style.breakWords || false;
                            // Measure ellipsis and check if it fits
                            const ellipsis = this.style.ellipsis || "";
                            const ellipsisMetrics = this._measureText(ellipsis, context);
                            const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;
                            // Check fit
                            if ((lineInfo.width + chunkWidth) > maxWidth) {
                                const excessWidth = maxWidth - lineInfo.width - ellipsisWidth;
                                chunk.text = this._truncateText(context, chunk.text, excessWidth, breakWords);
                                chunk.text += ellipsis;
                                skipFurtherText = true;
                            }
                        }
                        else if (wrap) {
                            // Check fit
                            if ((lineInfo.width + chunkWidth) > maxWidth) {
                                const excessWidth = maxWidth - lineInfo.width;
                                const tmpText = this._truncateText(context, chunk.text, excessWidth, false, (firstTextChunk && this.style.oversizedBehavior != "wrap-no-break"));
                                if (tmpText == "") {
                                    // Unable to fit a single letter - hide the whole label
                                    this.textVisible = true;
                                    return false;
                                }
                                //skipFurtherText = true;
                                //Add remaining chunks for the next line
                                leftoverChunks = chunks.slice(index + 1);
                                //Add remaining text of current chunk if it was forced-cut
                                if (_util_Utils__WEBPACK_IMPORTED_MODULE_6__["trim"](tmpText) != _util_Utils__WEBPACK_IMPORTED_MODULE_6__["trim"](chunk.text)) {
                                    leftoverChunks.unshift({
                                        type: "value",
                                        text: chunk.text.substr(tmpText.length)
                                    });
                                    if (currentFormat) {
                                        leftoverChunks.unshift({
                                            type: "format",
                                            text: currentFormat
                                        });
                                    }
                                }
                                // Set current chunk (truncated)
                                chunk.text = _util_Utils__WEBPACK_IMPORTED_MODULE_6__["trim"](tmpText);
                                chunks = [];
                                skipFurtherText = true;
                            }
                        }
                        // Chunk width?
                        let leftBoundMod = 1;
                        let rightBoundMod = 1;
                        if (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {
                            // increase horizontal bounding boxes accordingly
                            const boundsMod = chunkWidth / currentChunkWidth;
                            switch (this.style.textAlign) {
                                case "right":
                                case "end":
                                    leftBoundMod = boundsMod;
                                    break;
                                case "center":
                                    leftBoundMod = boundsMod;
                                    rightBoundMod = boundsMod;
                                    break;
                                default:
                                    rightBoundMod = boundsMod;
                            }
                            chunkWidth = currentChunkWidth;
                        }
                        const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                        if (chunkHeight > lineInfo.height) {
                            lineInfo.height = chunkHeight;
                        }
                        if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {
                            lineInfo.ascent = metrics.actualBoundingBoxAscent;
                        }
                        lineInfo.width += chunkWidth;
                        lineInfo.left += metrics.actualBoundingBoxLeft / leftBoundMod;
                        lineInfo.right += metrics.actualBoundingBoxRight / rightBoundMod;
                        lineInfo.textChunks.push({
                            style: currentStyle,
                            fill: currentFill,
                            text: chunk.text,
                            width: chunkWidth,
                            height: chunkHeight,
                            left: metrics.actualBoundingBoxLeft,
                            right: metrics.actualBoundingBoxRight,
                            ascent: metrics.actualBoundingBoxAscent,
                            offsetX: 0,
                            offsetY: 0,
                            textDecoration: currentDecoration,
                            verticalAlign: currentVerticalAlign
                        });
                        //offsetX += chunkWidth;
                        firstTextChunk = false;
                    }
                    if (leftoverChunks) {
                        //return false;
                    }
                    return true;
                    //}
                });
                if (this.style.lineHeight instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) {
                    lineInfo.height *= this.style.lineHeight.value;
                    lineInfo.ascent *= this.style.lineHeight.value;
                }
                else {
                    lineInfo.height *= this.style.lineHeight || 1.2;
                    lineInfo.ascent *= this.style.lineHeight || 1.2;
                }
                if (minX < lineInfo.left) {
                    minX = lineInfo.left;
                }
                if (maxX < lineInfo.right) {
                    maxX = lineInfo.right;
                }
                this._textInfo.push(lineInfo);
                //lineInfo.offsetY += lineInfo.ascent;
                offsetY += lineInfo.height;
                // Reset chunks so that it can proceed to the next line
                chunks = leftoverChunks || [];
            }
        });
        if (!styleRestored) {
            context.restore();
            ghostContext.restore();
        }
        // Adjust chunk internal offsets
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._textInfo, (lineInfo, _index) => {
            let currentChunkOffset = 0;
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](lineInfo.textChunks, (chunk) => {
                chunk.offsetX = currentChunkOffset + chunk.left - lineInfo.left;
                chunk.offsetY += lineInfo.height - lineInfo.height * (this.style.baselineRatio || 0.19);
                currentChunkOffset += chunk.width;
                if (chunk.verticalAlign) {
                    switch (chunk.verticalAlign) {
                        case "super":
                            chunk.offsetY -= lineInfo.height / 2 - chunk.height / 2;
                            break;
                        case "sub":
                            chunk.offsetY += chunk.height / 2;
                            break;
                    }
                }
            });
        });
        const bounds = {
            left: rtl ? -maxX : -minX,
            top: 0,
            right: rtl ? minX : maxX,
            bottom: offsetY,
        };
        // We need to fit?
        if (oversizedBehavior !== "none") {
            const ratio = this._fitRatio(bounds);
            if (ratio < 1) {
                if (oversizedBehavior == "fit") {
                    if (_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](this.style.minScale) && (ratio < this.style.minScale)) {
                        this.textVisible = false;
                        bounds.left = 0;
                        bounds.top = 0;
                        bounds.right = 0;
                        bounds.bottom = 0;
                    }
                    else {
                        if (!this._originalScale || this._originalScale == 1) {
                            this._originalScale = this.scale;
                        }
                        this.scale = ratio;
                        this.textVisible = true;
                    }
                }
                else if (oversizedBehavior == "hide") {
                    this.textVisible = false;
                    bounds.left = 0;
                    bounds.top = 0;
                    bounds.right = 0;
                    bounds.bottom = 0;
                }
                else {
                    switch (this.style.textAlign) {
                        case "right":
                        case "end":
                            bounds.left = -maxWidth;
                            bounds.right = 0;
                            break;
                        case "center":
                            bounds.left = -maxWidth / 2;
                            bounds.right = maxWidth / 2;
                            break;
                        default:
                            bounds.left = 0;
                            bounds.right = maxWidth;
                    }
                    this.scale = this._originalScale || 1;
                    this._originalScale = undefined;
                    this.textVisible = true;
                }
            }
            else {
                this.scale = this._originalScale || 1;
                this._originalScale = undefined;
                this.textVisible = true;
            }
        }
        context.restore();
        ghostContext.restore();
        return bounds;
    }
    _fitRatio(bounds) {
        const maxW = this.style.maxWidth;
        const maxH = this.style.maxHeight;
        if (!_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](maxW) && !_util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](maxH)) {
            return 1;
        }
        const w = bounds.right - bounds.left;
        const h = bounds.bottom - bounds.top;
        return Math.min(maxW / w || 1, maxH / h || 1);
    }
    _truncateText(context, text, maxWidth, breakWords = false, fallbackBreakWords = true) {
        let width;
        do {
            if (breakWords) {
                text = text.slice(0, -1);
            }
            else {
                let tmp = text.replace(/[^,;:!?\\\/\s]+[,;:!?\\\/\s]*$/g, "");
                if (tmp == "" && fallbackBreakWords) {
                    breakWords = true;
                }
                else if (tmp == "") {
                    return text;
                }
                else {
                    text = tmp;
                }
            }
            const metrics = this._measureText(text, context);
            width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
        } while ((width > maxWidth) && text != "");
        return text;
    }
    _measureText(text, context) {
        let metrics = context.measureText(text);
        let fakeMetrics = {};
        if (metrics.actualBoundingBoxAscent == null) {
            const div = document.createElement("div");
            div.innerText = text;
            div.style.visibility = "hidden";
            div.style.position = "absolute";
            div.style.top = "-1000000px;";
            div.style.fontFamily = this.style.fontFamily || "";
            div.style.fontSize = this.style.fontSize + "";
            document.body.appendChild(div);
            const bbox = div.getBoundingClientRect();
            document.body.removeChild(div);
            const h = bbox.height;
            const w = metrics.width;
            let left = 0;
            let right = w;
            fakeMetrics = {
                actualBoundingBoxAscent: h,
                actualBoundingBoxDescent: 0,
                actualBoundingBoxLeft: left,
                actualBoundingBoxRight: right,
                fontBoundingBoxAscent: h,
                fontBoundingBoxDescent: 0,
                width: w
            };
            //return fake;
        }
        else {
            fakeMetrics = {
                actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
                actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
                actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,
                actualBoundingBoxRight: metrics.actualBoundingBoxRight,
                fontBoundingBoxAscent: metrics.actualBoundingBoxAscent,
                fontBoundingBoxDescent: metrics.actualBoundingBoxDescent,
                width: metrics.width
            };
        }
        const w = metrics.width;
        switch (this.style.textAlign) {
            case "right":
            case "end":
                fakeMetrics.actualBoundingBoxLeft = w;
                fakeMetrics.actualBoundingBoxRight = 0;
                break;
            case "center":
                fakeMetrics.actualBoundingBoxLeft = w / 2;
                fakeMetrics.actualBoundingBoxRight = w / 2;
                break;
            default:
                fakeMetrics.actualBoundingBoxLeft = 0;
                fakeMetrics.actualBoundingBoxRight = w;
        }
        return fakeMetrics;
    }
}
/**
 * @ignore
 */
class CanvasTextStyle {
    constructor() {
        //public wordWrapWidth: number = 100;
        Object.defineProperty(this, "fill", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fillOpacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textAlign", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontFamily", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontWeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontStyle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fontVariant", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textDecoration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowColor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowBlur", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOffsetX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOffsetY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOpacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // leading?: number;
        // letterSpacing?: number;
        Object.defineProperty(this, "lineHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Object(_util_Percent__WEBPACK_IMPORTED_MODULE_3__["percent"])(120)
        });
        Object.defineProperty(this, "baselineRatio", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0.19
        });
        // padding?: number;
        // stroke?: number;
        // strokeThickness?: number;
        // trim?: number;
        // wordWrap?: boolean;
        Object.defineProperty(this, "direction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textBaseline", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oversizedBehavior", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "none"
        });
        Object.defineProperty(this, "breakWords", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "ellipsis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "…"
        });
        Object.defineProperty(this, "maxWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "maxHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "minScale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ignoreFormatting", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
}
/**
 * @ignore
 */
class CanvasRadialText extends CanvasText {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "textType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "circular"
        });
        Object.defineProperty(this, "radius", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "startAngle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "inside", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "orientation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "auto"
        });
        Object.defineProperty(this, "kerning", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_textReversed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _render(parentLayer) {
        switch (this.textType) {
            case "circular":
                this._renderCircular(parentLayer);
                break;
            default:
                super._render(parentLayer);
                break;
        }
    }
    _renderCircular(parentLayer) {
        if (this.textVisible) {
            const layer = this._layer || parentLayer;
            this._prerender(layer);
            const interactive = this._isInteractive();
            const context = layer.context;
            const layerDirty = layer.dirty;
            const ghostContext = this._renderer._ghostLayer.context;
            // Savepoint
            context.save();
            if (interactive) {
                ghostContext.save();
            }
            // We need measurements in order to properly position text for alignment
            if (!this._textInfo) {
                this._measure(layer);
            }
            // Init
            let radius = (this.radius || 0);
            let startAngle = (this.startAngle || 0);
            let deltaAngle = 0;
            let orientation = this.orientation;
            let inward = orientation == "auto" ? "auto" : orientation == "inward";
            const inside = this.inside;
            const align = this.style.textAlign || "left";
            const kerning = this.kerning || 0;
            let clockwise = align == "left" ? 1 : -1;
            const shouldReverse = !this._textReversed;
            // Check if we need to invert the whole stuff
            if (inward == "auto") {
                // Calc max angle so we know whether we need to flip it
                let maxAngle = 0;
                let midAngle = 0;
                _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._textInfo, (line, _index) => {
                    const deltaAngle = startAngle + (line.width / (radius - line.height)) / 2 * -clockwise;
                    if (deltaAngle > maxAngle) {
                        maxAngle = deltaAngle;
                    }
                });
                if (align == "left") {
                    midAngle = (maxAngle + deltaAngle / 2) * _util_Math__WEBPACK_IMPORTED_MODULE_10__["DEGREES"];
                }
                else if (align == "right") {
                    midAngle = (maxAngle - deltaAngle / 2) * _util_Math__WEBPACK_IMPORTED_MODULE_10__["DEGREES"];
                }
                else {
                    midAngle = startAngle * _util_Math__WEBPACK_IMPORTED_MODULE_10__["DEGREES"];
                }
                midAngle = _util_Math__WEBPACK_IMPORTED_MODULE_10__["normalizeAngle"](midAngle);
                inward = (midAngle >= 270) || (midAngle <= 90);
            }
            if (inward == true && shouldReverse) {
                this._textInfo.reverse();
                this._textReversed = true;
            }
            // if ((inward == false && align == "left") || (inward == true && align == "right")) {
            // 	clockwise *= -1;
            // }
            // Process text info produced by _measure()
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._textInfo, (line, _index) => {
                const textHeight = line.height;
                // Adjust radius (for `inside = false`)
                // Radius adjustment for `inside = false` is below the line calculation
                if (!inside) {
                    radius += textHeight;
                }
                // Reverse letters if we're painting them counter-clockwise
                if (((clockwise == -1 && inward) || (clockwise == 1 && !inward)) && shouldReverse) {
                    line.textChunks.reverse();
                }
                // Init angles
                let lineStartAngle = startAngle;
                deltaAngle = 0;
                // Adjust for center-align
                if (align == "center") {
                    lineStartAngle += (line.width / (radius - textHeight)) / 2 * -clockwise;
                    deltaAngle = lineStartAngle - startAngle;
                }
                // if (inward == "auto") {
                // 	let midAngle;
                // 	if (align == "left") {
                // 		midAngle = (lineStartAngle + deltaAngle / 2) * $math.DEGREES;
                // 	}
                // 	else if () {
                // 		midAngle = (lineStartAngle - deltaAngle / 2) * $math.DEGREES;
                // 	}
                // 	inward = (midAngle >= 270) || (midAngle <= 90);
                // }
                // Rotate letters if they are facing outward
                lineStartAngle += (Math.PI * (inward ? 0 : 1)); // Rotate 180 if outward
                // Savepoint
                context.save();
                if (interactive) {
                    ghostContext.save();
                }
                // Assume starting angle
                context.rotate(lineStartAngle);
                if (interactive) {
                    ghostContext.rotate(lineStartAngle);
                }
                let angleShift = 0;
                _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](line.textChunks, (chunk, _index) => {
                    // Draw the letter
                    const char = chunk.text;
                    const charWidth = chunk.width;
                    // Rotate half a letter
                    angleShift = (charWidth / 2) / (radius - textHeight) * clockwise;
                    context.rotate(angleShift);
                    if (interactive) {
                        ghostContext.rotate(angleShift);
                    }
                    // Set style
                    if (chunk.style) {
                        context.save();
                        ghostContext.save();
                        context.font = chunk.style;
                        if (interactive) {
                            ghostContext.font = chunk.style;
                        }
                    }
                    if (chunk.fill) {
                        context.save();
                        context.fillStyle = chunk.fill.toCSS();
                        // Color does not affect ghostContext so we not set it
                    }
                    // Center letters
                    context.textBaseline = "middle";
                    context.textAlign = "center";
                    if (interactive) {
                        ghostContext.textBaseline = "middle";
                        ghostContext.textAlign = "center";
                    }
                    // Plop the letter
                    if (layerDirty) {
                        context.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));
                    }
                    if (interactive) {
                        ghostContext.fillText(char, 0, (inward ? 1 : -1) * (0 - radius + textHeight / 2));
                    }
                    if (chunk.fill) {
                        context.restore();
                        // Color does not affect ghostContext so we not set it
                    }
                    // Reset style
                    if (chunk.style) {
                        context.restore();
                        ghostContext.restore();
                    }
                    // Rotate half a letter and add spacing
                    angleShift = (charWidth / 2 + kerning) / (radius - textHeight) * clockwise;
                    context.rotate(angleShift);
                    if (interactive) {
                        ghostContext.rotate(angleShift);
                    }
                });
                // Restore angle
                context.restore();
                if (interactive) {
                    ghostContext.restore();
                }
                // Adjust radius (for `inside = true`)
                if (inside) {
                    radius -= textHeight;
                }
            });
            // Restore
            context.restore();
            if (interactive) {
                ghostContext.restore();
            }
        }
    }
    _measure(layer) {
        switch (this.textType) {
            case "circular":
                return this._measureCircular(layer);
            default:
                return super._measure(layer);
        }
    }
    _measureCircular(layer) {
        const context = layer.context;
        const ghostContext = this._renderer._ghostLayer.context;
        const rtl = this.style.direction == "rtl";
        const oversizedBehavior = this.style.oversizedBehavior;
        const maxWidth = this.style.maxWidth;
        const truncate = _util_Type__WEBPACK_IMPORTED_MODULE_9__["isNumber"](maxWidth) && oversizedBehavior == "truncate";
        const ellipsis = this.style.ellipsis || "";
        let ellipsisMetrics;
        //const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == "wrap" || oversizedBehavior == "wrap-no-break");
        // Reset text info
        this.textVisible = true;
        this._textInfo = [];
        this._textReversed = false;
        // Pre-render
        context.save();
        ghostContext.save();
        this._prerender(layer, true);
        // Split up text into lines
        const lines = this.text.toString().replace(/\r/g, "").split(/\n/);
        let styleRestored = true;
        let totalWidth = 0;
        // Iterate through the lines
        let offsetY = 0;
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](lines, (line, _index) => {
            // Split up line into format/value chunks
            let chunks = _util_TextFormatter__WEBPACK_IMPORTED_MODULE_5__["TextFormatter"].chunk(line, false, this.style.ignoreFormatting);
            // Init line object
            let lineInfo = {
                offsetY: offsetY,
                ascent: 0,
                width: 0,
                height: 0,
                left: 0,
                right: 0,
                textChunks: []
            };
            let currentStyle;
            let currentFill;
            let currentChunkWidth;
            //while(chunk = chunks.shift()) {
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](chunks, (chunk, _index) => {
                // Format chunk
                if (chunk.type == "format") {
                    if (chunk.text == "[/]") {
                        if (!styleRestored) {
                            context.restore();
                            ghostContext.restore();
                            styleRestored = true;
                        }
                        currentFill = undefined;
                        currentStyle = undefined;
                        currentChunkWidth = undefined;
                    }
                    else {
                        let format = _util_TextFormatter__WEBPACK_IMPORTED_MODULE_5__["TextFormatter"].getTextStyle(chunk.text);
                        const fontStyle = this._getFontStyle(format);
                        context.save();
                        ghostContext.save();
                        context.font = fontStyle;
                        currentStyle = fontStyle;
                        if (format.fill) {
                            currentFill = format.fill;
                        }
                        if (format.width) {
                            currentChunkWidth = _util_Type__WEBPACK_IMPORTED_MODULE_9__["toNumber"](format.width);
                        }
                        styleRestored = false;
                    }
                    if (truncate) {
                        ellipsisMetrics = this._measureText(ellipsis, context);
                    }
                }
                // Text format
                else if (chunk.type == "value") {
                    // Measure each letter
                    const chars = chunk.text.match(/./ug) || [];
                    if (rtl) {
                        chars.reverse();
                    }
                    for (let i = 0; i < chars.length; i++) {
                        const char = chars[i];
                        // Measure
                        const metrics = this._measureText(char, context);
                        let chunkWidth = metrics.width;
                        // Chunk width?
                        if (currentStyle && currentChunkWidth && (currentChunkWidth > chunkWidth)) {
                            chunkWidth = currentChunkWidth;
                        }
                        const chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                        if (chunkHeight > lineInfo.height) {
                            lineInfo.height = chunkHeight;
                        }
                        if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {
                            lineInfo.ascent = metrics.actualBoundingBoxAscent;
                        }
                        lineInfo.width += chunkWidth;
                        lineInfo.left += metrics.actualBoundingBoxLeft;
                        lineInfo.right += metrics.actualBoundingBoxRight;
                        lineInfo.textChunks.push({
                            style: currentStyle,
                            fill: currentFill,
                            text: char,
                            width: chunkWidth,
                            height: chunkHeight + metrics.actualBoundingBoxDescent,
                            left: metrics.actualBoundingBoxLeft,
                            right: metrics.actualBoundingBoxRight,
                            ascent: metrics.actualBoundingBoxAscent,
                            offsetX: 0,
                            offsetY: chunkHeight,
                            textDecoration: undefined
                        });
                        totalWidth += chunkWidth;
                        // Handle oversized behavior
                        if (truncate) {
                            // Measure ellipsis and check if it fits
                            if (!ellipsisMetrics) {
                                ellipsisMetrics = this._measureText(ellipsis, context);
                            }
                            const ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;
                            totalWidth += ellipsisWidth;
                            if ((totalWidth + ellipsisWidth) > maxWidth) {
                                if (lineInfo.textChunks.length == 1) {
                                    this.textVisible = false;
                                }
                                else {
                                    lineInfo.width += ellipsisWidth;
                                    lineInfo.left += ellipsisMetrics.actualBoundingBoxLeft;
                                    lineInfo.right += ellipsisMetrics.actualBoundingBoxRight;
                                    lineInfo.textChunks.push({
                                        style: currentStyle,
                                        fill: currentFill,
                                        text: ellipsis,
                                        width: ellipsisWidth,
                                        height: chunkHeight + ellipsisMetrics.actualBoundingBoxDescent,
                                        left: ellipsisMetrics.actualBoundingBoxLeft,
                                        right: ellipsisMetrics.actualBoundingBoxRight,
                                        ascent: ellipsisMetrics.actualBoundingBoxAscent,
                                        offsetX: 0,
                                        offsetY: chunkHeight,
                                        textDecoration: undefined
                                    });
                                }
                                break;
                            }
                        }
                        if (rtl) {
                            break;
                        }
                    }
                }
            });
            if (this.style.lineHeight instanceof _util_Percent__WEBPACK_IMPORTED_MODULE_3__["Percent"]) {
                lineInfo.height *= this.style.lineHeight.value;
            }
            else {
                lineInfo.height *= this.style.lineHeight || 1.2;
            }
            this._textInfo.push(lineInfo);
            //lineInfo.offsetY += lineInfo.ascent;
            offsetY += lineInfo.height;
        });
        if (!styleRestored) {
            context.restore();
            ghostContext.restore();
        }
        if (oversizedBehavior == "hide" && (totalWidth > maxWidth)) {
            this.textVisible = false;
        }
        // Adjust chunk internal offsets
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._textInfo, (lineInfo) => {
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](lineInfo.textChunks, (chunk) => {
                chunk.offsetY += Math.round((lineInfo.height - chunk.height + (lineInfo.ascent - chunk.ascent)) / 2);
            });
        });
        context.restore();
        ghostContext.restore();
        return {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
        };
    }
}
/**
 * @ignore
 */
class CanvasImage extends CanvasDisplayObject {
    constructor(renderer, image) {
        super(renderer);
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "image", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tainted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowColor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowBlur", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOffsetX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOffsetY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shadowOpacity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_imageMask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.image = image;
    }
    _dispose() {
        super._dispose();
        if (this._imageMask) {
            clearCanvas(this._imageMask);
        }
    }
    getLocalBounds() {
        if (!this._localBounds) {
            let w = 0;
            let h = 0;
            if (this.width) {
                w = this.width;
            }
            if (this.height) {
                h = this.height;
            }
            this._localBounds = {
                left: 0,
                top: 0,
                right: w,
                bottom: h
            };
            this._addBounds(this._localBounds);
        }
        return this._localBounds;
    }
    _render(parentLayer) {
        super._render(parentLayer);
        if (this.image) {
            const layer = this._layer || parentLayer;
            if (this.tainted === undefined) {
                this.tainted = isTainted(this.image);
                layer.tainted = true;
            }
            if (this.tainted && this._renderer._omitTainted) {
                return;
            }
            if (layer.dirty) {
                if (this.shadowColor) {
                    layer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1);
                }
                if (this.shadowBlur) {
                    layer.context.shadowBlur = this.shadowBlur;
                }
                if (this.shadowOffsetX) {
                    layer.context.shadowOffsetX = this.shadowOffsetX;
                }
                if (this.shadowOffsetY) {
                    layer.context.shadowOffsetY = this.shadowOffsetY;
                }
                // TODO should this round ?
                const width = this.width || this.image.naturalWidth;
                const height = this.height || this.image.naturalHeight;
                layer.context.drawImage(this.image, 0, 0, width, height);
            }
            if (this.interactive && this._isInteractive()) {
                const mask = this._getMask(this.image);
                this._renderer._ghostLayer.context.drawImage(mask, 0, 0);
            }
        }
    }
    clear() {
        super.clear();
        this.image = undefined;
        this._imageMask = undefined;
    }
    _getMask(image) {
        if (this._imageMask === undefined) {
            // TODO should this round ?
            const width = this.width || image.naturalWidth;
            const height = this.height || image.naturalHeight;
            // We need to create a second canvas because destination-in clears out the entire canvas
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext("2d");
            context.imageSmoothingEnabled = false;
            context.fillStyle = this._getColorId();
            context.fillRect(0, 0, width, height);
            if (!isTainted(image)) {
                context.globalCompositeOperation = "destination-in";
                context.drawImage(image, 0, 0, width, height);
            }
            this._imageMask = canvas;
        }
        return this._imageMask;
    }
}
/**
 * @ignore
 */
class CanvasRendererEvent {
    constructor(event, originalPoint, point, bbox) {
        Object.defineProperty(this, "event", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: event
        });
        Object.defineProperty(this, "originalPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: originalPoint
        });
        Object.defineProperty(this, "point", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: point
        });
        Object.defineProperty(this, "bbox", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: bbox
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "simulated", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "native", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        if (_util_Utils__WEBPACK_IMPORTED_MODULE_6__["supports"]("touchevents") && event instanceof Touch) {
            this.id = event.identifier;
        }
        else {
            this.id = null;
        }
    }
}
/**
 * @ignore
 */
class CanvasRenderer extends _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["ArrayDisposer"] {
    /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {
        this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);
    });
    */
    constructor(resolution) {
        super();
        Object.defineProperty(this, "view", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: document.createElement("div")
        });
        Object.defineProperty(this, "_layerDom", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: document.createElement("div")
        });
        Object.defineProperty(this, "layers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_dirtyLayers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "defaultLayer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.getLayer(0)
        });
        Object.defineProperty(this, "_ghostLayer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new GhostLayer()
        });
        Object.defineProperty(this, "_patternCanvas", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: document.createElement("canvas")
        });
        Object.defineProperty(this, "_patternContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._patternCanvas.getContext("2d")
        });
        Object.defineProperty(this, "_domWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_domHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_canvasWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_canvasHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "resolution", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "interactionsEnabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_listeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_colorId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_colorMap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_forceInteractive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_omitTainted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // TODO this should store the Id as well
        Object.defineProperty(this, "_hovering", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Set()
        });
        Object.defineProperty(this, "_dragging", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_mousedown", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_lastPointerMoveEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tapToActivate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "tapToActivateTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3000
        });
        Object.defineProperty(this, "_touchActive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_touchActiveTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (resolution == null) {
            this.resolution = window.devicePixelRatio;
        }
        else {
            this.resolution = resolution;
        }
        this.view.style.position = "absolute";
        this.view.appendChild(this._layerDom);
        this._disposers.push(new _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["Disposer"](() => {
            _util_Object__WEBPACK_IMPORTED_MODULE_8__["each"](this._events, (_key, events) => {
                events.disposer.dispose();
            });
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this.layers, (layer) => {
                clearCanvas(layer.view);
                if (layer.exportableView) {
                    clearCanvas(layer.exportableView);
                }
            });
            clearCanvas(this._ghostLayer.view);
            clearCanvas(this._patternCanvas);
        }));
        /*
        this._disposers.push($utils.addEventListener(this._ghostLayer.view, "click", (originalEvent: MouseEvent) => {
            const event = this.getEvent(originalEvent);
            const target = this._getHitTarget(event.originalPoint, event.bbox);
            console.debug(target);
        }));
        */
        // Monitor for possible pixel ratio changes (when page is zoomed)
        this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_6__["onZoom"](() => {
            if (resolution == null) {
                this.resolution = window.devicePixelRatio;
            }
        }));
        // We need this in order top prevent default touch gestures when dragging
        // draggable elements
        if (_util_Utils__WEBPACK_IMPORTED_MODULE_6__["supports"]("touchevents")) {
            const listener = (ev) => {
                if (this._dragging.length !== 0) {
                    _util_Array__WEBPACK_IMPORTED_MODULE_7__["eachContinue"](this._dragging, (item) => {
                        if (item.value.shouldCancelTouch()) {
                            ev.preventDefault();
                            return false;
                        }
                        return true;
                    });
                }
                // If touch down happends, delay touch out
                if (this._touchActiveTimeout) {
                    this._delayTouchDeactivate();
                }
            };
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_6__["addEventListener"](window, "touchstart", listener, { passive: false }));
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_6__["addEventListener"](this.view, "touchstart", listener, { passive: false }));
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_6__["addEventListener"](this.view, "touchmove", () => {
                // If touch is moving, delay touch out
                if (this._touchActiveTimeout) {
                    this._delayTouchDeactivate();
                }
            }, { passive: true }));
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_6__["addEventListener"](window, "click", (_ev) => {
                this._touchActive = false;
            }, { passive: true }));
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_6__["addEventListener"](this.view, "click", (_ev) => {
                window.setTimeout(() => {
                    this._touchActive = true;
                    this._delayTouchDeactivate();
                }, 100);
            }, { passive: true }));
        }
        // Prevent scrolling of the window when hovering on "wheelable" object
        if (_util_Utils__WEBPACK_IMPORTED_MODULE_6__["supports"]("wheelevents")) {
            this._disposers.push(_util_Utils__WEBPACK_IMPORTED_MODULE_6__["addEventListener"](this.view, "wheel", (ev) => {
                let prevent = false;
                this._hovering.forEach((obj) => {
                    if (obj.wheelable) {
                        prevent = true;
                        return false;
                    }
                });
                if (prevent) {
                    ev.preventDefault();
                }
            }, { passive: false }));
        }
    }
    _delayTouchDeactivate() {
        if (this._touchActiveTimeout) {
            clearTimeout(this._touchActiveTimeout);
        }
        if (this.tapToActivateTimeout > 0) {
            this._touchActiveTimeout = window.setTimeout(() => {
                this._touchActive = false;
            }, this.tapToActivateTimeout);
        }
    }
    get debugGhostView() {
        return !!this._ghostLayer.view.parentNode;
    }
    set debugGhostView(value) {
        if (value) {
            if (!this._ghostLayer.view.parentNode) {
                this.view.appendChild(this._ghostLayer.view);
            }
        }
        else {
            if (this._ghostLayer.view.parentNode) {
                this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);
            }
        }
    }
    createLinearGradient(x1, y1, x2, y2) {
        return this.defaultLayer.context.createLinearGradient(x1, y1, x2, y2);
    }
    createRadialGradient(x1, y1, radius1, x2, y2, radius2) {
        return this.defaultLayer.context.createRadialGradient(x1, y1, radius1, x2, y2, radius2);
    }
    createPattern(graphics, background, repetition, width, height) {
        // const patternCanvas = document.createElement("canvas");
        // const patternContext = patternCanvas.getContext("2d")!;
        // patternCanvas.width = width;
        // patternCanvas.height = height;
        // if (fill) {
        // 	patternContext.fillStyle = fill.toCSS();
        // 	patternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
        // }
        // const layer = {
        // 	view: patternCanvas,
        // 	context: patternContext,
        // 	visible: true,
        // 	order: 0,
        // 	width: width,
        // 	height: height,
        // 	dirty: true
        // };
        // // patternContext.arc(0, 0, 50, 0, .5 * Math.PI);
        // // patternContext.stroke();
        // image.targetLayer = layer;
        // image.render(layer);
        //this._layerDom.appendChild(patternCanvas);
        this._patternCanvas.width = width;
        this._patternCanvas.height = height;
        this._patternContext.clearRect(0, 0, width, height);
        // patternCanvas.style.width = width * this.resolution + "px";
        // patternCanvas.style.height = height * this.resolution + "px";
        background.renderDetached(this._patternContext);
        graphics.renderDetached(this._patternContext);
        return this._patternContext.createPattern(this._patternCanvas, repetition);
    }
    makeContainer() {
        return new CanvasContainer(this);
    }
    makeGraphics() {
        return new CanvasGraphics(this);
    }
    makeText(text, style) {
        return new CanvasText(this, text, style);
    }
    makeTextStyle() {
        return new CanvasTextStyle();
    }
    makeRadialText(text, style) {
        return new CanvasRadialText(this, text, style);
    }
    makePicture(image) {
        return new CanvasImage(this, image);
    }
    resizeLayer(layer) {
        layer.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);
    }
    resizeGhost() {
        this._ghostLayer.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);
    }
    resize(canvasWidth, canvasHeight, domWidth, domHeight) {
        this._canvasWidth = canvasWidth;
        this._canvasHeight = canvasHeight;
        this._domWidth = domWidth;
        this._domHeight = domHeight;
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this.layers, (layer) => {
            if (layer) {
                layer.dirty = true;
                this.resizeLayer(layer);
            }
        });
        this.resizeGhost();
        this.view.style.width = domWidth + "px";
        this.view.style.height = domHeight + "px";
    }
    createDetachedLayer(willReadFrequently = false) {
        const view = document.createElement("canvas");
        const context = view.getContext("2d", { willReadFrequently: willReadFrequently });
        const layer = new CanvasLayer(view, context);
        view.style.position = "absolute";
        view.style.top = "0px";
        view.style.left = "0px";
        return layer;
    }
    getLayerByOrder(order) {
        const layers = this.layers;
        const length = layers.length;
        for (let i = 0; i < length; i++) {
            const layer = layers[i];
            if (layer.order == order) {
                return layer;
            }
        }
    }
    getLayer(order, visible = true) {
        let existingLayer = this.getLayerByOrder(order);
        if (existingLayer) {
            return existingLayer;
        }
        const layer = this.createDetachedLayer(order == 99);
        layer.order = order;
        layer.visible = visible;
        if (layer.visible) {
            this.resizeLayer(layer);
        }
        const layers = this.layers;
        layers.push(layer);
        layers.sort((a, b) => {
            if (a.order > b.order) {
                return 1;
            }
            else if (a.order < b.order) {
                return -1;
            }
            else {
                return 0;
            }
        });
        const length = layers.length;
        const layerIndex = _util_Array__WEBPACK_IMPORTED_MODULE_7__["indexOf"](layers, layer);
        let next;
        for (let i = layerIndex + 1; i < length; i++) {
            if (layers[i].visible) {
                next = layers[i];
                break;
            }
        }
        if (layer.visible) {
            if (next === undefined) {
                this._layerDom.appendChild(layer.view);
            }
            else {
                this._layerDom.insertBefore(layer.view, next.view);
            }
        }
        return layer;
    }
    render(root) {
        this._dirtyLayers.length = 0;
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this.layers, (layer) => {
            if (layer) {
                if (layer.dirty && layer.visible) {
                    this._dirtyLayers.push(layer);
                    layer.clear();
                }
            }
        });
        this._ghostLayer.clear();
        root.render(this.defaultLayer);
        this._ghostLayer.context.restore();
        //setTimeout(() => {
        // Remove this after the Chrome bug is fixed:
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1279394
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this.layers, (layer) => {
            if (layer) {
                const context = layer.context;
                context.beginPath();
                context.moveTo(0, 0);
                context.stroke();
            }
        });
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._dirtyLayers, (layer) => {
            layer.context.restore();
            layer.dirty = false;
        });
        //}, 100)
        if (this._hovering.size && this._lastPointerMoveEvent) {
            //this._mouseMoveThrottler.run();
            const native = this._lastPointerMoveEvent.native;
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._lastPointerMoveEvent.events, (event) => {
                this._dispatchGlobalMousemove(event, native);
            });
        }
    }
    paintId(obj) {
        const id = distributeId(++this._colorId);
        const color = _util_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].fromHex(id).toCSS();
        this._colorMap[color] = obj;
        return color;
    }
    _removeObject(obj) {
        if (obj._colorId !== undefined) {
            delete this._colorMap[obj._colorId];
        }
    }
    // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {
    // 	return this._colorMap[colorId];
    // }
    _adjustBoundingBox(bbox) {
        const margin = this._ghostLayer.margin;
        return new DOMRect(bbox.left - margin.left, bbox.top - margin.top, bbox.width + margin.left + margin.right, bbox.height + margin.top + margin.bottom);
    }
    getEvent(originalEvent, adjustPoint = true) {
        const bbox = this.view.getBoundingClientRect();
        const originalPoint = {
            x: originalEvent.clientX || 0,
            y: originalEvent.clientY || 0,
        };
        const point = {
            x: originalPoint.x - (adjustPoint ? bbox.left : 0),
            y: originalPoint.y - (adjustPoint ? bbox.top : 0),
        };
        return new CanvasRendererEvent(originalEvent, originalPoint, point, this._adjustBoundingBox(bbox));
    }
    _getHitTarget(point, bbox, event) {
        if (bbox.width === 0 || bbox.height === 0 || point.x < bbox.left || point.x > bbox.right || point.y < bbox.top || point.y > bbox.bottom) {
            return;
        }
        if (!this._layerDom.contains(event.target)) {
            return;
        }
        const pixel = this._ghostLayer.getImageData(point, bbox);
        if (pixel.data[0] === 0 && pixel.data[1] === 0 && pixel.data[2] === 0) {
            return false;
        }
        const colorId = _util_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].fromRGB(pixel.data[0], pixel.data[1], pixel.data[2]).toCSS();
        const hit = this._colorMap[colorId];
        return hit;
    }
    _withEvents(key, f) {
        const events = this._events[key];
        if (events !== undefined) {
            events.dispatching = true;
            try {
                f(events);
            }
            finally {
                events.dispatching = false;
                if (events.cleanup) {
                    events.cleanup = false;
                    _util_Array__WEBPACK_IMPORTED_MODULE_7__["keepIf"](events.callbacks, (callback) => {
                        return !callback.disposed;
                    });
                    if (events.callbacks.length === 0) {
                        events.disposer.dispose();
                        delete this._events[key];
                    }
                }
            }
        }
    }
    _dispatchEventAll(key, event) {
        if (!this.interactionsEnabled) {
            return;
        }
        this._withEvents(key, (events) => {
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](events.callbacks, (callback) => {
                if (!callback.disposed) {
                    callback.callback.call(callback.context, event);
                }
            });
        });
    }
    _dispatchEvent(key, target, event) {
        if (!this.interactionsEnabled) {
            return false;
        }
        let dispatched = false;
        this._withEvents(key, (events) => {
            _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](events.callbacks, (callback) => {
                if (!callback.disposed && callback.object === target) {
                    callback.callback.call(callback.context, event);
                    dispatched = true;
                }
            });
        });
        return dispatched;
    }
    _dispatchMousedown(originalEvent) {
        const button = originalEvent.button;
        if (button != 0 && button != 2 && button != 1 && button !== undefined) {
            // Ignore non-primary mouse buttons
            return;
        }
        const event = this.getEvent(originalEvent);
        const target = this._getHitTarget(event.originalPoint, event.bbox, originalEvent);
        if (target) {
            const id = event.id;
            let dragged = false;
            eachTargets(target, (obj) => {
                const info = { id: id, value: obj };
                this._mousedown.push(info);
                if (!dragged && this._dispatchEvent("pointerdown", obj, event)) {
                    // Only dispatch the first element which matches
                    dragged = true;
                    const has = this._dragging.some((x) => {
                        return x.value === obj && x.id === id;
                    });
                    if (!has) {
                        this._dragging.push(info);
                    }
                }
                return true;
            });
        }
    }
    _dispatchGlobalMousemove(originalEvent, native) {
        const event = this.getEvent(originalEvent);
        const target = this._getHitTarget(event.originalPoint, event.bbox, originalEvent);
        event.native = native;
        if (target) {
            this._hovering.forEach((obj) => {
                if (!obj.contains(target)) {
                    this._hovering.delete(obj);
                    if (obj.cursorOverStyle) {
                        _util_Utils__WEBPACK_IMPORTED_MODULE_6__["setStyle"](document.body, "cursor", obj._replacedCursorStyle);
                    }
                    this._dispatchEvent("pointerout", obj, event);
                }
            });
            if (event.native) {
                eachTargets(target, (obj) => {
                    if (!this._hovering.has(obj)) {
                        this._hovering.add(obj);
                        if (obj.cursorOverStyle) {
                            obj._replacedCursorStyle = _util_Utils__WEBPACK_IMPORTED_MODULE_6__["getStyle"](document.body, "cursor");
                            _util_Utils__WEBPACK_IMPORTED_MODULE_6__["setStyle"](document.body, "cursor", obj.cursorOverStyle);
                        }
                        this._dispatchEvent("pointerover", obj, event);
                    }
                    return true;
                });
            }
            //} else if (target === false) {
        }
        else {
            this._hovering.forEach((obj) => {
                if (obj.cursorOverStyle) {
                    _util_Utils__WEBPACK_IMPORTED_MODULE_6__["setStyle"](document.body, "cursor", obj._replacedCursorStyle);
                }
                this._dispatchEvent("pointerout", obj, event);
            });
            this._hovering.clear();
        }
        this._dispatchEventAll("globalpointermove", event);
    }
    _dispatchGlobalMouseup(originalEvent, native) {
        const event = this.getEvent(originalEvent);
        event.native = native;
        //const target = this._getHitTarget(event.originalPoint);
        this._dispatchEventAll("globalpointerup", event);
    }
    _dispatchDragMove(originalEvent) {
        if (this._dragging.length !== 0) {
            const event = this.getEvent(originalEvent);
            const id = event.id;
            this._dragging.forEach((obj) => {
                if (obj.id === id) {
                    this._dispatchEvent("pointermove", obj.value, event);
                }
            });
        }
    }
    _dispatchDragEnd(originalEvent) {
        const button = originalEvent.button;
        let clickevent;
        if (button == 0 || button === undefined) {
            clickevent = "click";
        }
        else if (button == 2) {
            clickevent = "rightclick";
        }
        else if (button == 1) {
            clickevent = "middleclick";
        }
        else {
            // Ignore non-primary mouse buttons
            return;
        }
        const event = this.getEvent(originalEvent);
        const id = event.id;
        if (this._mousedown.length !== 0) {
            const target = this._getHitTarget(event.originalPoint, event.bbox, originalEvent);
            if (target) {
                this._mousedown.forEach((obj) => {
                    if (obj.id === id && obj.value.contains(target)) {
                        this._dispatchEvent(clickevent, obj.value, event);
                    }
                });
            }
            this._mousedown.length = 0;
        }
        if (this._dragging.length !== 0) {
            this._dragging.forEach((obj) => {
                if (obj.id === id) {
                    this._dispatchEvent("pointerup", obj.value, event);
                }
            });
            this._dragging.length = 0;
        }
    }
    _dispatchDoubleClick(originalEvent) {
        const event = this.getEvent(originalEvent);
        const target = this._getHitTarget(event.originalPoint, event.bbox, originalEvent);
        if (target) {
            eachTargets(target, (obj) => {
                if (this._dispatchEvent("dblclick", obj, event)) {
                    return false;
                }
                else {
                    return true;
                }
            });
        }
    }
    _dispatchWheel(originalEvent) {
        const event = this.getEvent(originalEvent);
        const target = this._getHitTarget(event.originalPoint, event.bbox, originalEvent);
        if (target) {
            eachTargets(target, (obj) => {
                if (this._dispatchEvent("wheel", obj, event)) {
                    return false;
                }
                else {
                    return true;
                }
            });
        }
    }
    _makeSharedEvent(key, f) {
        if (this._listeners[key] === undefined) {
            const listener = f();
            this._listeners[key] = new _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["CounterDisposer"](() => {
                delete this._listeners[key];
                listener.dispose();
            });
        }
        return this._listeners[key].increment();
    }
    _onPointerEvent(name, f) {
        let native = false;
        let timer = null;
        function clear() {
            timer = null;
            native = false;
        }
        return new _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["MultiDisposer"]([
            new _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["Disposer"](() => {
                if (timer !== null) {
                    clearTimeout(timer);
                }
                clear();
            }),
            _util_Utils__WEBPACK_IMPORTED_MODULE_6__["addEventListener"](this.view, _util_Utils__WEBPACK_IMPORTED_MODULE_6__["getRendererEvent"](name), (_) => {
                native = true;
                if (timer !== null) {
                    clearTimeout(timer);
                }
                timer = window.setTimeout(clear, 0);
            }),
            onPointerEvent(window, name, (ev) => {
                if (timer !== null) {
                    clearTimeout(timer);
                    timer = null;
                }
                f(ev, native);
                native = false;
            }),
        ]);
    }
    // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)
    _initEvent(key) {
        switch (key) {
            case "globalpointermove":
            case "pointerover":
            case "pointerout":
                return this._makeSharedEvent("pointermove", () => {
                    const listener = (events, native) => {
                        this._lastPointerMoveEvent = { events, native };
                        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](events, (event) => {
                            this._dispatchGlobalMousemove(event, native);
                        });
                    };
                    return new _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["MultiDisposer"]([
                        this._onPointerEvent("pointerdown", listener),
                        this._onPointerEvent("pointermove", listener),
                    ]);
                });
            case "globalpointerup":
                return this._makeSharedEvent("pointerup", () => {
                    var mouseup = this._onPointerEvent("pointerup", (events, native) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](events, (event) => {
                            this._dispatchGlobalMouseup(event, native);
                        });
                        this._lastPointerMoveEvent = { events, native };
                    });
                    var pointercancel = this._onPointerEvent("pointercancel", (events, native) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](events, (event) => {
                            this._dispatchGlobalMouseup(event, native);
                        });
                        this._lastPointerMoveEvent = { events, native };
                    });
                    return new _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["Disposer"](() => {
                        mouseup.dispose();
                        pointercancel.dispose();
                    });
                });
            case "click":
            case "rightclick":
            case "middleclick":
            case "pointerdown":
            /*
                return this._makeSharedEvent("pointerdown", () => {
                    return this._onPointerEvent("pointerdown", (event, native) => {
                        this._lastPointerMoveEvent = { event, native };
                        this._dispatchMousedown(event)
                    });
                });
            */
            case "pointermove":
            case "pointerup":
                return this._makeSharedEvent("pointerdown", () => {
                    //const throttler = new Throttler();
                    const mousedown = this._onPointerEvent("pointerdown", (events) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](events, (ev) => {
                            this._dispatchMousedown(ev);
                        });
                    });
                    // TODO handle throttling properly for multitouch
                    const mousemove = this._onPointerEvent("pointermove", (ev) => {
                        //throttler.throttle(() => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](ev, (ev) => {
                            this._dispatchDragMove(ev);
                        });
                        //});
                    });
                    const mouseup = this._onPointerEvent("pointerup", (ev) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](ev, (ev) => {
                            this._dispatchDragEnd(ev);
                        });
                    });
                    const pointercancel = this._onPointerEvent("pointercancel", (ev) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](ev, (ev) => {
                            this._dispatchDragEnd(ev);
                        });
                    });
                    return new _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["Disposer"](() => {
                        mousedown.dispose();
                        mousemove.dispose();
                        mouseup.dispose();
                        pointercancel.dispose();
                    });
                });
            case "dblclick":
                return this._makeSharedEvent("dblclick", () => {
                    return this._onPointerEvent("dblclick", (ev) => {
                        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](ev, (ev) => {
                            this._dispatchDoubleClick(ev);
                        });
                    });
                });
            case "wheel":
                return this._makeSharedEvent("wheel", () => {
                    return _util_Utils__WEBPACK_IMPORTED_MODULE_6__["addEventListener"](window, _util_Utils__WEBPACK_IMPORTED_MODULE_6__["getRendererEvent"]("wheel"), (event) => {
                        this._dispatchWheel(event);
                    }, { passive: false });
                });
        }
    }
    _addEvent(object, key, callback, context) {
        let events = this._events[key];
        if (events === undefined) {
            events = this._events[key] = {
                disposer: this._initEvent(key),
                callbacks: [],
                dispatching: false,
                cleanup: false,
            };
        }
        const listener = { object, context, callback, disposed: false };
        events.callbacks.push(listener);
        return new _util_Disposer__WEBPACK_IMPORTED_MODULE_4__["Disposer"](() => {
            listener.disposed = true;
            if (events.dispatching) {
                events.cleanup = true;
            }
            else {
                _util_Array__WEBPACK_IMPORTED_MODULE_7__["removeFirst"](events.callbacks, listener);
                if (events.callbacks.length === 0) {
                    events.disposer.dispose();
                    delete this._events[key];
                }
            }
        });
    }
    getCanvas(root, options) {
        // Make sure everything is rendered
        this.render(root);
        if (!options) {
            options = {};
        }
        let scale = this.resolution;
        let canvasWidth = Math.floor(this._canvasWidth * this.resolution);
        let canvasHeight = Math.floor(this._canvasHeight * this.resolution);
        // Check if we need to scale
        if (options.minWidth && (options.minWidth > canvasWidth)) {
            let minScale = options.minWidth / canvasWidth;
            if (minScale > scale) {
                scale = minScale * this.resolution;
            }
        }
        if (options.minHeight && (options.minHeight > canvasHeight)) {
            let minScale = options.minHeight / canvasHeight;
            if (minScale > scale) {
                scale = minScale * this.resolution;
            }
        }
        if (options.maxWidth && (options.maxWidth < canvasWidth)) {
            let maxScale = options.maxWidth / canvasWidth;
            if (maxScale < scale) {
                scale = maxScale * this.resolution;
            }
        }
        if (options.maxHeight && (options.maxHeight > canvasHeight)) {
            let maxScale = options.maxHeight / canvasHeight;
            if (maxScale < scale) {
                scale = maxScale * this.resolution;
            }
        }
        // Check if we need to compensate for pixel ratio
        if (options.maintainPixelRatio) {
            scale /= this.resolution;
        }
        // Init list canvases to remove from DOM after export
        const canvases = [];
        // Set up new canvas for export
        let forceRender = false;
        const canvas = document.createElement("canvas");
        if (scale != this.resolution) {
            forceRender = true;
            canvasWidth = canvasWidth * scale / this.resolution;
            canvasHeight = canvasHeight * scale / this.resolution;
        }
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        // Add to DOM so it inherits CSS
        canvas.style.position = "fixed";
        canvas.style.top = "-10000px";
        this.view.appendChild(canvas);
        canvases.push(canvas);
        // Context
        const context = canvas.getContext("2d");
        let width = 0;
        let height = 0;
        let needRerender = false;
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this.layers, (layer) => {
            if (layer && layer.visible) {
                if (layer.tainted || forceRender) {
                    needRerender = true;
                    layer.exportableView = layer.view;
                    layer.exportableContext = layer.context;
                    layer.view = document.createElement("canvas");
                    // Add to DOM so it inherits CSS
                    layer.view.style.position = "fixed";
                    layer.view.style.top = "-10000px";
                    this.view.appendChild(layer.view);
                    canvases.push(layer.view);
                    let extraX = 0;
                    let extraY = 0;
                    if (layer.margin) {
                        extraX += layer.margin.left || 0 + layer.margin.right || 0;
                        extraY += layer.margin.top || 0 + layer.margin.bottom || 0;
                    }
                    layer.view.width = canvasWidth + extraX;
                    layer.view.height = canvasHeight + extraY;
                    layer.context = layer.view.getContext("2d");
                    layer.dirty = true;
                    layer.scale = scale;
                }
            }
        });
        if (needRerender) {
            this._omitTainted = true;
            this.render(root);
            this._omitTainted = false;
        }
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](this.layers, (layer) => {
            if (layer && layer.visible) {
                // Layer is fine. Just plop it into our target canvas
                let x = 0;
                let y = 0;
                if (layer.margin) {
                    x = -(layer.margin.left || 0) * this.resolution;
                    y = -(layer.margin.top || 0) * this.resolution;
                }
                context.drawImage(layer.view, x, y);
                // Restore layer original canvas
                if (layer.exportableView) {
                    layer.view = layer.exportableView;
                    layer.exportableView = undefined;
                }
                if (layer.exportableContext) {
                    layer.context = layer.exportableContext;
                    layer.exportableContext = undefined;
                }
                if (width < layer.view.clientWidth) {
                    width = layer.view.clientWidth;
                }
                if (height < layer.view.clientHeight) {
                    height = layer.view.clientHeight;
                }
                layer.scale = undefined;
            }
        });
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](canvases, (canvas) => {
            canvas.style.position = "";
            canvas.style.top = "";
            this.view.removeChild(canvas);
        });
        return canvas;
    }
}
class GhostLayer {
    constructor() {
        Object.defineProperty(this, "view", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "margin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
            }
        });
        Object.defineProperty(this, "_width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        this.view = document.createElement("canvas");
        this.context = this.view.getContext("2d", { alpha: false, willReadFrequently: true });
        this.context.imageSmoothingEnabled = false;
        this.view.style.position = "absolute";
        this.view.style.top = "0px";
        this.view.style.left = "0px";
    }
    resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {
        canvasWidth += (this.margin.left + this.margin.right);
        canvasHeight += (this.margin.top + this.margin.bottom);
        // TODO this should take into account calculateSize
        domWidth += (this.margin.left + this.margin.right);
        domHeight += (this.margin.top + this.margin.bottom);
        this.view.style.left = -this.margin.left + "px";
        this.view.style.top = -this.margin.top + "px";
        this._width = Math.floor(canvasWidth * resolution);
        this._height = Math.floor(canvasHeight * resolution);
        this.view.width = this._width;
        this.view.style.width = domWidth + "px";
        this.view.height = this._height;
        this.view.style.height = domHeight + "px";
    }
    getImageData(point, bbox) {
        return this.context.getImageData(
        // TODO should this round ?
        Math.round(((point.x - bbox.left) / bbox.width) * this._width), Math.round(((point.y - bbox.top) / bbox.height) * this._height), 1, 1);
    }
    setMargin(layers) {
        this.margin.left = 0;
        this.margin.right = 0;
        this.margin.top = 0;
        this.margin.bottom = 0;
        _util_Array__WEBPACK_IMPORTED_MODULE_7__["each"](layers, (layer) => {
            if (layer.margin) {
                this.margin.left = Math.max(this.margin.left, layer.margin.left);
                this.margin.right = Math.max(this.margin.right, layer.margin.right);
                this.margin.top = Math.max(this.margin.top, layer.margin.top);
                this.margin.bottom = Math.max(this.margin.bottom, layer.margin.bottom);
            }
        });
    }
    clear() {
        this.context.save();
        this.context.fillStyle = '#000';
        this.context.fillRect(0, 0, this._width, this._height);
    }
}
/**
 * @ignore
 */
class CanvasLayer {
    constructor(view, context) {
        Object.defineProperty(this, "view", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tainted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "margin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "order", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "visible", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "scale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "exportableView", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exportableContext", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_width", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_height", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        this.view = view;
        this.context = context;
    }
    resize(canvasWidth, canvasHeight, domWidth, domHeight, resolution) {
        // TODO should this take into account calculateSize ?
        if (this.width != null) {
            canvasWidth = this.width;
            domWidth = this.width;
        }
        // TODO should this take into account calculateSize ?
        if (this.height != null) {
            canvasHeight = this.height;
            domHeight = this.height;
        }
        if (this.margin) {
            canvasWidth += (this.margin.left + this.margin.right);
            canvasHeight += (this.margin.top + this.margin.bottom);
            // TODO this should take into account calculateSize
            domWidth += (this.margin.left + this.margin.right);
            domHeight += (this.margin.top + this.margin.bottom);
            this.view.style.left = -this.margin.left + "px";
            this.view.style.top = -this.margin.top + "px";
        }
        else {
            this.view.style.left = "0px";
            this.view.style.top = "0px";
        }
        this._width = Math.floor(canvasWidth * resolution);
        this._height = Math.floor(canvasHeight * resolution);
        this.view.width = this._width;
        this.view.style.width = domWidth + "px";
        this.view.height = this._height;
        this.view.style.height = domHeight + "px";
    }
    clear() {
        this.context.save();
        this.context.clearRect(0, 0, this._width, this._height);
    }
}
//# sourceMappingURL=CanvasRenderer.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js ***!
  \************************************************************************************/
/*! exports provided: BlendMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlendMode", function() { return BlendMode; });
/**
 * From https://github.com/pixijs/pixi.js/blob/3dd0ff9a935f0bc13a09aefff9eb2872f02c51b9/packages/canvas/canvas-renderer/src/utils/mapCanvasBlendModesToPixi.ts#L13
 */
var BlendMode;
(function (BlendMode) {
    BlendMode["ADD"] = "lighter";
    BlendMode["COLOR"] = "color";
    BlendMode["COLOR_BURN"] = "color-burn";
    BlendMode["COLOR_DODGE"] = "color-dodge";
    BlendMode["DARKEN"] = "darken";
    BlendMode["DIFFERENCE"] = "difference";
    BlendMode["DST_OVER"] = "destination-over";
    BlendMode["EXCLUSION"] = "exclusion";
    BlendMode["HARD_LIGHT"] = "hard-light";
    BlendMode["HUE"] = "hue";
    BlendMode["LIGHTEN"] = "lighten";
    BlendMode["LUMINOSITY"] = "luminosity";
    BlendMode["MULTIPLY"] = "multiply";
    BlendMode["NORMAL"] = "source-over";
    BlendMode["OVERLAY"] = "overlay";
    BlendMode["SATURATION"] = "saturation";
    BlendMode["SCREEN"] = "screen";
    BlendMode["SOFT_LIGHT"] = "soft-light";
    BlendMode["SRC_ATOP"] = "source-atop";
    BlendMode["XOR"] = "xor";
})(BlendMode || (BlendMode = {}));
//# sourceMappingURL=Renderer.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/Gradient.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/Gradient.js ***!
  \**************************************************************************************/
/*! exports provided: Gradient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gradient", function() { return Gradient; });
/* harmony import */ var _util_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");

/**
 * Base class for gradients.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info
 */
class Gradient extends _util_Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    _afterNew() {
        // Applying themes because gradient will not have parent
        super._afterNewApplyThemes();
    }
    /**
     * @ignore
     */
    getFill(_target) {
        return {
            addColorStop: (_offset, _color) => { }
        };
    }
    _changed() {
        super._changed();
        //if (this.isDirty("target") && this.get("target")) {
        //	this.get("target")!.events.on("boundschanged", () => {
        //	});
        //}
    }
    /**
     * @ignore
     */
    getBounds(target) {
        const gradientTarget = this.get("target");
        if (gradientTarget) {
            let bounds = gradientTarget.globalBounds();
            const p0 = target.toLocal({ x: bounds.left, y: bounds.top });
            const p1 = target.toLocal({ x: bounds.right, y: bounds.top });
            const p2 = target.toLocal({ x: bounds.right, y: bounds.bottom });
            const p3 = target.toLocal({ x: bounds.left, y: bounds.bottom });
            return {
                left: Math.min(p0.x, p1.x, p2.x, p3.x),
                top: Math.min(p0.y, p1.y, p2.y, p3.y),
                right: Math.max(p0.x, p1.x, p2.x, p3.x),
                bottom: Math.max(p0.y, p1.y, p2.y, p3.y)
            };
        }
        return target._display.getLocalBounds();
    }
}
Object.defineProperty(Gradient, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Gradient"
});
Object.defineProperty(Gradient, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _util_Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"].classNames.concat([Gradient.className])
});
//# sourceMappingURL=Gradient.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/LinearGradient.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/LinearGradient.js ***!
  \********************************************************************************************/
/*! exports provided: LinearGradient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearGradient", function() { return LinearGradient; });
/* harmony import */ var _Gradient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Gradient */ "./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/Gradient.js");
/* harmony import */ var _util_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");





/**
 * Linear gradient.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info
 */
class LinearGradient extends _Gradient__WEBPACK_IMPORTED_MODULE_0__["Gradient"] {
    /**
     * @ignore
     */
    getFill(target) {
        const rotation = this.get("rotation", 0);
        let bounds = this.getBounds(target);
        let l = bounds.left || 0;
        let r = bounds.right || 0;
        let t = bounds.top || 0;
        let b = bounds.bottom || 0;
        let cos = _util_Math__WEBPACK_IMPORTED_MODULE_4__["cos"](rotation);
        let sin = _util_Math__WEBPACK_IMPORTED_MODULE_4__["sin"](rotation);
        let w = cos * (r - l);
        let h = sin * (b - t);
        let longer = Math.max(w, h);
        const gradient = this._root._renderer.createLinearGradient(l, t, l + longer * cos, t + longer * sin);
        const stops = this.get("stops");
        if (stops) {
            let i = 0;
            _util_Array__WEBPACK_IMPORTED_MODULE_2__["each"](stops, (stop) => {
                let offset = stop.offset;
                if (!_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](offset)) {
                    offset = i / (stops.length - 1);
                }
                let opacity = stop.opacity;
                if (!_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](opacity)) {
                    opacity = 1;
                }
                let color = stop.color;
                if (color) {
                    const lighten = stop.lighten;
                    if (lighten) {
                        color = _util_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].lighten(color, lighten);
                    }
                    const brighten = stop.brighten;
                    if (brighten) {
                        color = _util_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].brighten(color, brighten);
                    }
                    gradient.addColorStop(offset, 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + opacity + ')');
                }
                i++;
            });
        }
        return gradient;
    }
}
Object.defineProperty(LinearGradient, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "LinearGradient"
});
Object.defineProperty(LinearGradient, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Gradient__WEBPACK_IMPORTED_MODULE_0__["Gradient"].classNames.concat([LinearGradient.className])
});
//# sourceMappingURL=LinearGradient.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/RadialGradient.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/RadialGradient.js ***!
  \********************************************************************************************/
/*! exports provided: RadialGradient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RadialGradient", function() { return RadialGradient; });
/* harmony import */ var _Gradient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Gradient */ "./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/Gradient.js");
/* harmony import */ var _util_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _util_Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");





/**
 * Radial gradient.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info
 */
class RadialGradient extends _Gradient__WEBPACK_IMPORTED_MODULE_0__["Gradient"] {
    /**
     * @ignore
     */
    getFill(target) {
        const bounds = this.getBounds(target);
        let x = 0;
        let y = 0;
        let l = bounds.left || 0;
        let r = bounds.right || 0;
        let t = bounds.top || 0;
        let b = bounds.bottom || 0;
        const width = r - l;
        const height = b - t;
        let radius = target.get("radius");
        if (_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](radius)) {
            x = 0;
            y = 0;
        }
        else {
            radius = Math.min(width, height) / 2;
            x = width / 2;
            y = height / 2;
        }
        let ux = this.get("x");
        let uy = this.get("y");
        if (ux != null) {
            x = _util_Utils__WEBPACK_IMPORTED_MODULE_4__["relativeToValue"](ux, width);
        }
        if (uy != null) {
            y = _util_Utils__WEBPACK_IMPORTED_MODULE_4__["relativeToValue"](uy, height);
        }
        const gradient = this._root._renderer.createRadialGradient(x, y, 0, x, y, radius);
        const stops = this.get("stops");
        if (stops) {
            let i = 0;
            _util_Array__WEBPACK_IMPORTED_MODULE_2__["each"](stops, (stop) => {
                let offset = stop.offset;
                if (!_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](offset)) {
                    offset = i / (stops.length - 1);
                }
                let opacity = stop.opacity;
                if (!_util_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](opacity)) {
                    opacity = 1;
                }
                let color = stop.color;
                if (color) {
                    const lighten = stop.lighten;
                    if (lighten) {
                        color = _util_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].lighten(color, lighten);
                    }
                    const brighten = stop.brighten;
                    if (brighten) {
                        color = _util_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].brighten(color, brighten);
                    }
                    gradient.addColorStop(offset, 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + opacity + ')');
                }
                i++;
            });
        }
        return gradient;
    }
}
Object.defineProperty(RadialGradient, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "RadialGradient"
});
Object.defineProperty(RadialGradient, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Gradient__WEBPACK_IMPORTED_MODULE_0__["Gradient"].classNames.concat([RadialGradient.className])
});
//# sourceMappingURL=RadialGradient.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/CirclePattern.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/CirclePattern.js ***!
  \******************************************************************************************/
/*! exports provided: CirclePattern */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CirclePattern", function() { return CirclePattern; });
/* harmony import */ var _Pattern__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");


/**
 * Circle pattern.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
 */
class CirclePattern extends _Pattern__WEBPACK_IMPORTED_MODULE_0__["Pattern"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("gap")) {
            this._clear = true;
        }
    }
    _draw() {
        super._draw();
        const checkered = this.get("checkered", false);
        const centered = this.get("centered", true);
        const gap = this.get("gap", 0);
        const rotation = this.get("rotation", 0);
        let w = this.get("width", 100);
        let h = this.get("height", 100);
        let radius = this.get("radius", 3);
        let cellW = radius * 2 + gap;
        let cellH = radius * 2 + gap;
        let cols = Math.round(w / cellW);
        let rows = Math.round(h / cellH);
        cellW = w / cols;
        cellH = h / rows;
        if (rotation != 0) {
            // @todo this is probably not right
            this._display.x = cellW * _util_Math__WEBPACK_IMPORTED_MODULE_1__["cos"](rotation);
            this._display.y = cellH * _util_Math__WEBPACK_IMPORTED_MODULE_1__["sin"](rotation);
        }
        const color = this.get("color");
        const colorOpacity = this.get("colorOpacity");
        if (color || colorOpacity) {
            this._display.beginFill(color, colorOpacity);
        }
        for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {
            for (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {
                if (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {
                    let x = c * cellW;
                    let y = r * cellH;
                    if (centered) {
                        x += cellW + gap / 2;
                        y += cellH + gap / 2;
                    }
                    this._display.drawCircle(x - radius, y - radius, radius);
                }
            }
        }
        if (checkered) {
            w = w / 2 - gap * 2;
            h = h / 2 - gap * 2;
        }
        else {
            w -= gap;
            h -= gap;
        }
        if (color || colorOpacity) {
            this._display.endFill();
        }
    }
}
Object.defineProperty(CirclePattern, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "CirclePattern"
});
Object.defineProperty(CirclePattern, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Pattern__WEBPACK_IMPORTED_MODULE_0__["Pattern"].classNames.concat([CirclePattern.className])
});
//# sourceMappingURL=CirclePattern.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/LinePattern.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/LinePattern.js ***!
  \****************************************************************************************/
/*! exports provided: LinePattern */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinePattern", function() { return LinePattern; });
/* harmony import */ var _Pattern__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js");
/* harmony import */ var _util_Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util//Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");


/**
 * Line pattern.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
 */
class LinePattern extends _Pattern__WEBPACK_IMPORTED_MODULE_0__["Pattern"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("gap")) {
            this._clear = true;
        }
    }
    _draw() {
        super._draw();
        const w = this.get("width", 100);
        const h = this.get("height", 100);
        const gap = this.get("gap", 0);
        const strokeWidth = this.get("strokeWidth", 1);
        if (!gap) {
            this._display.moveTo(0, 0);
            this._display.lineTo(w, 0);
        }
        else {
            let step = gap + strokeWidth;
            let count = h / step;
            for (let i = -count; i < count * 2; i++) {
                const y = Math.round(i * step - step / 2) + 0.5;
                this._display.moveTo(-w, y);
                this._display.lineTo(w * 2, y);
            }
        }
        this._display.lineStyle(strokeWidth, this.get("color"), this.get("colorOpacity"));
        let strokeDasharray = this.get("strokeDasharray");
        if (_util_Type__WEBPACK_IMPORTED_MODULE_1__["isNumber"](strokeDasharray)) {
            if (strokeDasharray < 0.5) {
                strokeDasharray = [0];
            }
            else {
                strokeDasharray = [strokeDasharray];
            }
        }
        this._display.setLineDash(strokeDasharray);
        const strokeDashoffset = this.get("strokeDashoffset");
        if (strokeDashoffset) {
            this._display.setLineDashOffset(strokeDashoffset);
        }
        this._display.endStroke();
    }
}
Object.defineProperty(LinePattern, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "LinePattern"
});
Object.defineProperty(LinePattern, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Pattern__WEBPACK_IMPORTED_MODULE_0__["Pattern"].classNames.concat([LinePattern.className])
});
//# sourceMappingURL=LinePattern.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PathPattern.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PathPattern.js ***!
  \****************************************************************************************/
/*! exports provided: PathPattern */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PathPattern", function() { return PathPattern; });
/* harmony import */ var _Pattern__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js");

/**
 * A pattern that uses an SVG path.
 *
 * @since 5.2.33
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
 */
class PathPattern extends _Pattern__WEBPACK_IMPORTED_MODULE_0__["Pattern"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("svgPath")) {
            this._clear = true;
        }
    }
    _draw() {
        super._draw();
        // const checkered = this.get("checkered", false);
        // const centered = this.get("centered", true);
        // const gap = this.get("gap", 0);
        // const rotation = this.get("rotation", 0);
        // let w = this.get("width", 100);
        // let h = this.get("height", 100);
        // let rectW = this.get("maxWidth", 5);
        // let rectH = this.get("maxHeight", 5);
        // let cellW = rectW + gap;
        // let cellH = rectH + gap;
        // let cols = Math.round(w / cellW);
        // let rows = Math.round(h / cellH);
        // cellW = w / cols;
        // cellH = h / rows;
        // if (rotation != 0) {
        // 	// @todo this is probably not right
        // 	this._display.x = cellW / 2 * $math.cos(rotation);
        // 	this._display.y = -cellH / 2 * $math.sin(rotation);
        // }
        // for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {
        // 	for (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {
        // 		if (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {
        // 			let x = c * cellW;
        // 			let y = r * cellH;
        // 			if (centered) {
        // 				x += (cellW - rectW) / 2;
        // 				y += (cellH - rectH) / 2;
        // 			}
        // 			this._display.drawRect(x, y, rectW, rectH);
        // 		}
        // 	}
        // }
        // if (checkered) {
        // 	w = w / 2 - gap * 2;
        // 	h = h / 2 - gap * 2;
        // }
        // else {
        // 	w -= gap;
        // 	h -= gap;
        // }
        const svgPath = this.get("svgPath");
        if (svgPath != null) {
            this._display.svgPath(svgPath);
        }
        const color = this.get("color");
        const colorOpacity = this.get("colorOpacity");
        if (color || colorOpacity) {
            // this._display.lineStyle(strokeWidth, stroke, colorOpacity);
            // this._display.endStroke();
            this._display.beginFill(color, colorOpacity);
            this._display.endFill();
        }
    }
}
Object.defineProperty(PathPattern, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "PathPattern"
});
Object.defineProperty(PathPattern, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Pattern__WEBPACK_IMPORTED_MODULE_0__["Pattern"].classNames.concat([PathPattern.className])
});
//# sourceMappingURL=PathPattern.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js ***!
  \************************************************************************************/
/*! exports provided: Pattern */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pattern", function() { return Pattern; });
/* harmony import */ var _util_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");

/**
 * Base class for patterns.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
 */
class Pattern extends _util_Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_display", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeGraphics()
        });
        Object.defineProperty(this, "_backgroundDisplay", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._root._renderer.makeGraphics()
        });
        Object.defineProperty(this, "_clear", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_pattern", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _afterNew() {
        // Applying themes because pattern will not have parent
        super._afterNewApplyThemes();
    }
    get pattern() {
        return this._pattern;
    }
    _draw() { }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("repetition") || this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation") || this.isDirty("color") || this.isDirty("strokeWidth") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("colorOpacity") || this.isDirty("fill") || this.isDirty("fillOpacity")) {
            this._clear = true;
        }
    }
    _changed() {
        super._changed();
        if (this._clear) {
            const repetition = this.get("repetition", "");
            const width = this.get("width", 100);
            const height = this.get("height", 100);
            const fill = this.get("fill");
            const fillOpacity = this.get("fillOpacity", 1);
            this._display.clear();
            this._backgroundDisplay.clear();
            if (fill && (fillOpacity > 0)) {
                this._backgroundDisplay.beginFill(fill, fillOpacity);
                this._backgroundDisplay.drawRect(0, 0, width, height);
                this._backgroundDisplay.endFill();
            }
            this._display.angle = this.get("rotation", 0);
            //this._display.pivot = { x: width / 2, y: height / 2 };
            this._draw();
            this._pattern = this._root._renderer.createPattern(this._display, this._backgroundDisplay, repetition, width, height);
        }
    }
}
Object.defineProperty(Pattern, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Pattern"
});
Object.defineProperty(Pattern, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _util_Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"].classNames.concat([Pattern.className])
});
//# sourceMappingURL=Pattern.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PicturePattern.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PicturePattern.js ***!
  \*******************************************************************************************/
/*! exports provided: PicturePattern */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PicturePattern", function() { return PicturePattern; });
/* harmony import */ var _Pattern__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js");

/**
 * Picture pattern.
 *
 * @since 5.2.15
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
 */
class PicturePattern extends _Pattern__WEBPACK_IMPORTED_MODULE_0__["Pattern"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_image", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _beforeChanged() {
        super._beforeChanged();
        this._clear = true;
        if (this.isDirty("src")) {
            this._load();
        }
    }
    _draw() {
        super._draw();
        const image = this._image;
        if (image) {
            const patternWidth = this.get("width", 100);
            const patternHeight = this.get("height", 100);
            // Fit
            const fit = this.get("fit", "image");
            let width = 0;
            let height = 0;
            if (fit == "pattern") {
                width = patternWidth;
                height = patternHeight;
            }
            else {
                width = image.width;
                height = image.height;
                if (fit == "image") {
                    this.set("width", width);
                    this.set("height", height);
                }
            }
            // Position
            const centered = this.get("centered", true);
            let x = 0;
            let y = 0;
            if (centered) {
                x = patternWidth / 2 - width / 2;
                y = patternHeight / 2 - height / 2;
            }
            this._display.image(image, width, height, x, y);
        }
    }
    _load() {
        const src = this.get("src");
        if (src) {
            const image = new Image();
            //image.crossOrigin = "Anonymous";
            image.src = src;
            image.decode().then(() => {
                this._image = image;
                this._draw();
                if (this.events.isEnabled("loaded")) {
                    this.events.dispatch("loaded", { type: "loaded", target: this });
                }
            }).catch((_error) => {
                // TODO: maybe raise error?
            });
        }
    }
}
Object.defineProperty(PicturePattern, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "PicturePattern"
});
Object.defineProperty(PicturePattern, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Pattern__WEBPACK_IMPORTED_MODULE_0__["Pattern"].classNames.concat([PicturePattern.className])
});
//# sourceMappingURL=PicturePattern.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/RectanglePattern.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/RectanglePattern.js ***!
  \*********************************************************************************************/
/*! exports provided: RectanglePattern */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectanglePattern", function() { return RectanglePattern; });
/* harmony import */ var _Pattern__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js");
/* harmony import */ var _util_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");


/**
 * Rectangle pattern.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info
 */
class RectanglePattern extends _Pattern__WEBPACK_IMPORTED_MODULE_0__["Pattern"] {
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("gap")) {
            this._clear = true;
        }
    }
    _draw() {
        super._draw();
        const checkered = this.get("checkered", false);
        const centered = this.get("centered", true);
        const gap = this.get("gap", 0);
        const rotation = this.get("rotation", 0);
        let w = this.get("width", 100);
        let h = this.get("height", 100);
        let rectW = this.get("maxWidth", 5);
        let rectH = this.get("maxHeight", 5);
        let cellW = rectW + gap;
        let cellH = rectH + gap;
        let cols = Math.round(w / cellW);
        let rows = Math.round(h / cellH);
        cellW = w / cols;
        cellH = h / rows;
        if (rotation != 0) {
            // @todo this is probably not right
            this._display.x = cellW / 2 * _util_Math__WEBPACK_IMPORTED_MODULE_1__["cos"](rotation);
            this._display.y = -cellH / 2 * _util_Math__WEBPACK_IMPORTED_MODULE_1__["sin"](rotation);
        }
        for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {
            for (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {
                if (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {
                    let x = c * cellW;
                    let y = r * cellH;
                    if (centered) {
                        x += (cellW - rectW) / 2;
                        y += (cellH - rectH) / 2;
                    }
                    this._display.drawRect(x, y, rectW, rectH);
                }
            }
        }
        if (checkered) {
            w = w / 2 - gap * 2;
            h = h / 2 - gap * 2;
        }
        else {
            w -= gap;
            h -= gap;
        }
        const color = this.get("color");
        const colorOpacity = this.get("colorOpacity");
        if (color || colorOpacity) {
            // this._display.lineStyle(strokeWidth, stroke, colorOpacity);
            // this._display.endStroke();
            this._display.beginFill(color, colorOpacity);
            this._display.endFill();
        }
    }
}
Object.defineProperty(RectanglePattern, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "RectanglePattern"
});
Object.defineProperty(RectanglePattern, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Pattern__WEBPACK_IMPORTED_MODULE_0__["Pattern"].classNames.concat([RectanglePattern.className])
});
//# sourceMappingURL=RectanglePattern.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js ***!
  \***************************************************************************/
/*! exports provided: waitForAnimations, normalize, range, defaultInterpolate, percentInterpolate, colorInterpolate, getInterpolate, AnimationTime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waitForAnimations", function() { return waitForAnimations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultInterpolate", function() { return defaultInterpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "percentInterpolate", function() { return percentInterpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorInterpolate", function() { return colorInterpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInterpolate", function() { return getInterpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationTime", function() { return AnimationTime; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/@amcharts/amcharts5/node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");





/**
 * @ignore
 */
function waitForAnimations(animations) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"])(this, void 0, void 0, function* () {
        if (animations !== undefined) {
            const promises = [];
            _Object__WEBPACK_IMPORTED_MODULE_4__["each"](animations, (_, animation) => {
                promises.push(animation.waitForStop());
            });
            yield Promise.all(promises);
        }
    });
}
/**
 * @ignore
 */
function normalize(value, min, max) {
    if (min === max) {
        return 0;
    }
    else {
        return Math.min(Math.max((value - min) * (1 / (max - min)), 0), 1);
    }
}
/**
 * @ignore
 */
function range(diff, from, to) {
    return from + (diff * (to - from));
}
/**
 * @ignore
 */
function defaultInterpolate(diff, from, to) {
    if (diff >= 1) {
        return to;
    }
    else {
        return from;
    }
}
/**
 * @ignore
 */
function percentInterpolate(diff, from, to) {
    return new _Percent__WEBPACK_IMPORTED_MODULE_1__["Percent"](range(diff, from.percent, to.percent));
}
/**
 * @ignore
 */
function colorInterpolate(diff, from, to) {
    return _Color__WEBPACK_IMPORTED_MODULE_2__["Color"].interpolate(diff, from, to);
}
/**
 * @ignore
 */
function getInterpolate(from, to) {
    if (typeof from === "number" && typeof to === "number") {
        return range;
    }
    if (from instanceof _Percent__WEBPACK_IMPORTED_MODULE_1__["Percent"] && to instanceof _Percent__WEBPACK_IMPORTED_MODULE_1__["Percent"]) {
        return percentInterpolate;
    }
    if (from instanceof _Color__WEBPACK_IMPORTED_MODULE_2__["Color"] && to instanceof _Color__WEBPACK_IMPORTED_MODULE_2__["Color"]) {
        return colorInterpolate;
    }
    return defaultInterpolate;
}
/**
 * @ignore
 */
class AnimationTime {
    constructor(entity, duration) {
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_duration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_playingDuration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_startingTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_current", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_from", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_to", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _EventDispatcher__WEBPACK_IMPORTED_MODULE_3__["EventDispatcher"]()
        });
        Object.defineProperty(this, "easing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._entity = entity;
        this._duration = duration;
    }
    _stopEvent() {
        const type = "stopped";
        if (this.events.isEnabled(type)) {
            this.events.dispatch(type, { type: type, target: this });
        }
    }
    _runAnimation(currentTime) {
        if (this._playingDuration !== null) {
            if (this._startingTime === null) {
                this._startingTime = currentTime;
                return true;
            }
            else {
                const diff = (currentTime - this._startingTime) / this._playingDuration;
                if (diff >= 1) {
                    this._playingDuration = null;
                    this._startingTime = null;
                    this._from = this._to;
                    this._current = this._to;
                    this._entity.markDirty();
                    this._stopEvent();
                    const type = "ended";
                    if (this.events.isEnabled(type)) {
                        this.events.dispatch(type, { type: type, target: this });
                    }
                    return false;
                }
                else {
                    this._current = range(diff, this._from, this._to);
                    this._entity.markDirty();
                    const type = "progress";
                    if (this.events.isEnabled(type)) {
                        this.events.dispatch(type, { type: type, target: this, progress: diff });
                    }
                    return true;
                }
            }
        }
        else {
            return false;
        }
    }
    _play() {
        this._from = this._current;
        if (this._playingDuration === null) {
            this._entity._root._addAnimation(this);
            const type = "started";
            if (this.events.isEnabled(type)) {
                this.events.dispatch(type, { type: type, target: this });
            }
        }
        else {
            this._startingTime = null;
        }
        this._playingDuration = Math.abs(this._to - this._from) * this._duration;
    }
    get duration() {
        return this._duration;
    }
    set duration(value) {
        if (this._duration !== value) {
            this._duration = value;
            if (value === 0) {
                this.jumpTo(this._to);
            }
            else if (this._current !== this._to) {
                this._play();
            }
        }
    }
    get current() {
        if (this.easing) {
            return this.easing(this._current);
        }
        else {
            return this._current;
        }
    }
    stop() {
        this.jumpTo(this._current);
    }
    jumpTo(value) {
        if (this._current !== value) {
            this._entity.markDirty();
        }
        if (this._playingDuration !== null) {
            this._stopEvent();
        }
        this._playingDuration = null;
        this._startingTime = null;
        this._current = value;
        this._from = value;
        this._to = value;
    }
    tweenTo(value) {
        if (this._current === value || this._duration === 0) {
            this.jumpTo(value);
        }
        else {
            if (this._to !== value) {
                this._to = value;
                this._play();
            }
        }
    }
}
/*export class AnimationValue extends AnimationTime {
    public _min: number;
    public _max: number;

    constructor(entity: Entity, duration: number, min: number, max: number) {
        super(entity, duration);
        this._min = min;
        this._max = max;
    }

    public get min(): number {
        return this._min;
    }

    public set min(value: number) {
        if (this._min !== value) {
            this._min = value;
            this._entity.markDirty();
        }
    }

    public get max(): number {
        return this._max;
    }

    public set max(value: number) {
        if (this._max !== value) {
            this._max = value;
            this._entity.markDirty();
        }
    }

    public currentValue(): number {
        return range(super.currentTime(), this._min, this._max);
    }

    public jumpToValue(value: number) {
        super.jumpToTime(normalize(value, this._min, this._max));
    }

    public tweenToValue(value: number) {
        super.tweenToTime(normalize(value, this._min, this._max));
    }
}
*/
//# sourceMappingURL=Animation.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js ***!
  \***********************************************************************/
/*! exports provided: indexOf, any, map, each, eachReverse, eachContinue, shiftLeft, last, first, insert, setIndex, pushAll, remove, removeFirst, move, add, pushOne, replace, toArray, has, copy, slice, insertIndex, removeIndex, findIndex, findIndexReverse, find, findReverse, findMap, shuffle, getSortedIndex, getFirstSortedIndex, keepIf */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indexOf", function() { return indexOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "any", function() { return any; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "each", function() { return each; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eachReverse", function() { return eachReverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eachContinue", function() { return eachContinue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shiftLeft", function() { return shiftLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "last", function() { return last; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "first", function() { return first; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insert", function() { return insert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setIndex", function() { return setIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushAll", function() { return pushAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFirst", function() { return removeFirst; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "move", function() { return move; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushOne", function() { return pushOne; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replace", function() { return replace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "has", function() { return has; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertIndex", function() { return insertIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeIndex", function() { return removeIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndexReverse", function() { return findIndexReverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findReverse", function() { return findReverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findMap", function() { return findMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSortedIndex", function() { return getSortedIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFirstSortedIndex", function() { return getFirstSortedIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keepIf", function() { return keepIf; });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");

/**
 * ============================================================================
 * UTILITY FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Searches `array` for `value`.
 *
 * Returns -1 if not found.
 *
 * @param array  Source array
 * @param value  Value to search
 * @returns Index
 */
function indexOf(array, value) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        // TODO handle NaN
        if (array[i] === value) {
            return i;
        }
    }
    return -1;
}
/**
 * Calls `test` for each element in `array`.
 *
 * If `test` returns `true` then it immediately returns `true`.
 *
 * If `test` returns `false` for all of the elements in `array` then it returns `false`.
 *
 * @param array  Source array
 * @param test   Function which is called on each element
 * @returns Whether `test` returned true or not
 */
function any(array, test) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        if (test(array[i])) {
            return true;
        }
    }
    return false;
}
/**
 * Calls `fn` function for every member of array and returns a new array out
 * of all outputs.
 *
 * @param array  Source array
 * @param fn     Callback function
 * @returns New array
 */
function map(array, fn) {
    const length = array.length;
    const output = new Array(length);
    for (let i = 0; i < length; ++i) {
        output[i] = fn(array[i], i);
    }
    return output;
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function each(array, fn) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        fn(array[i], i);
    }
}
/**
 * Iterates through all items in array in reverse order and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function eachReverse(array, fn) {
    let i = array.length;
    while (i > 0) {
        --i;
        fn(array[i], i);
    }
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * If `fn` call evaluates to `false`, further iteration is cancelled.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function eachContinue(array, fn) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        if (!fn(array[i], i)) {
            break;
        }
    }
}
/**
 * Shifts an item at `index` towards beginning of the array.
 *
 * @param array  Source array
 * @param index  Target element index
 */
function shiftLeft(array, index) {
    const length = array.length;
    for (let i = index; i < length; ++i) {
        array[i - index] = array[i];
    }
    array.length = length - index;
}
/**
 * Returns the last item of the array.
 *
 * @param array  Source array
 * @returns Last item
 */
function last(array) {
    const length = array.length;
    return length ? array[length - 1] : undefined;
}
/**
 * Returns the first item of the array.
 *
 * @param array  Source array
 * @returns Last item
 */
function first(array) {
    return array[0];
}
/**
 * Inserts `element` into `array` at `index`.
 *
 * Caps `index` to be between `0` and `array.length`
 *
 * @param array    Source array
 * @param element  Item to insert
 * @param array    Index to insert item at
 */
function insert(array, element, index) {
    //if (array) {
    index = Math.max(0, Math.min(index, array.length));
    array.splice(index, 0, element);
    //}
}
/**
 * Removes all copies of `element` from `array` (if they exist) and then
 * inserts `element` at `index`.
 *
 * @param array    Source array
 * @param element  Item
 * @param array    Index to move item to
 */
function setIndex(array, element, index) {
    remove(array, element);
    insert(array, element, index);
}
/**
 * Pushes all of the elements from `input` into `array`.
 *
 * @param array  Output array
 * @param input  Input array
 */
function pushAll(array, input) {
    const length = input.length;
    for (let i = 0; i < length; ++i) {
        array.push(input[i]);
    }
}
/**
 * Removes `element` from `array`.
 *
 * If there are multiple copies of `element`, they are all removed.
 *
 * @param array    Source array
 * @param element  Item to remove
 */
function remove(array, element) {
    let found = false;
    let index = 0;
    for (;;) {
        index = array.indexOf(element, index);
        if (index === -1) {
            return found;
        }
        else {
            found = true;
            array.splice(index, 1);
        }
    }
}
function removeFirst(array, element) {
    let index = array.indexOf(element);
    if (index !== -1) {
        array.splice(index, 1);
        return true;
    }
    else {
        return false;
    }
}
/**
 * Adds an `element` to `array`.
 *
 * If array already contains and item like this, it is removed before adding
 * it again.
 *
 * Optionally `toIndex` can be specified to add element at specific index.
 *
 * @param array    Source array
 * @param element  Item to add
 * @param array    Index to move item to
 */
function move(array, element, toIndex) {
    // @todo this implementation must be the same as the List.moveValue method
    // @todo don't do anything if the desired index is the same as the current index
    let index = indexOf(array, element);
    // @todo remove all old values rather than only the first ?
    if (index !== -1) {
        removeIndex(array, index);
    }
    if (toIndex == null) {
        array.push(element);
    }
    else {
        insertIndex(array, toIndex, element);
    }
}
/**
 * Inserts `element` into `array` at `index`.
 *
 * If `index` is not provided, it will insert `element` at the end of `array`.
 *
 * @param array    Source array
 * @param element  Item to add
 * @param array    Index to add item at
 */
function add(array, element, index) {
    // Append to the end if index is not set
    if (!_Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"](index)) {
        array.push(element);
    }
    // Add to the beginning of array if index is 0
    else if (index === 0) {
        array.unshift(element);
    }
    // Add to indicated place if index is set
    else {
        array.splice(index, 0, element);
    }
}
/**
 * Pushes `element` into `array` if it doesn't already exist.
 *
 * @param array    Source array
 * @param element  Item to add
 */
function pushOne(array, element) {
    if (array.indexOf(element) === -1) {
        array.push(element);
    }
}
/**
 * Removes `element` from `array` (if it exists) and then inserts `element` at
 * `index`.
 *
 * If `index` is not provided, it will insert `element` at the end of `array`.
 *
 * @param array    Source array
 * @param element  Item to remove
 * @param array    Index to move item to
 */
function replace(array, element, index) {
    // check if exists
    let ind = array.indexOf(element);
    // remove if exists
    if (ind !== -1) {
        array.splice(ind, 1);
    }
    // add to end if index is not set
    if (!_Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"](index)) {
        array.push(element);
    }
    // add to indicated place if index is set
    else {
        array.splice(index, 0, element);
    }
}
/**
 * Wraps `input` in an array, if it isn't already an array.
 *
 * @param input  Source value
 * @return An array
 */
function toArray(input) {
    if (Array.isArray(input)) {
        return input;
    }
    else {
        return [input];
    }
}
/**
 * Returns `true` if `element` exists in `array`.
 *
 * @param array    Source array
 * @param element  Item to search for
 * @returns Item in array?
 */
function has(array, element) {
    return indexOf(array, element) !== -1;
}
/**
 * Returns a shallow copy of `array`.
 *
 * @param array  Source array
 * @returns Copy of the array
 */
function copy(array) {
    const length = array.length;
    // It's faster to create the array with a pre-defined length
    const output = new Array(length);
    for (let i = 0; i < length; ++i) {
        // Because the array has a pre-defined length, we have to assign rather than push
        // This is also faster than pushing
        output[i] = array[i];
    }
    return output;
}
/**
 * Returns a copy of `array` which contains all the elements between `start`
 * and `end`. (including `start` and excluding `end`)
 *
 * If `end` is not provided, it defaults to `array.length`.
 *
 * @param array  Source array
 * @param start  Start index
 * @param end    End index
 * @returns Part of the array
 */
function slice(array, start, end = array.length) {
    const output = new Array(end - start);
    for (let i = start; i < end; ++i) {
        output[i - start] = array[i];
    }
    return output;
}
/**
 * Inserts a value into array at specific index.
 *
 * @param array  Source array
 * @param index  Index
 * @param value  Value to insert
 */
function insertIndex(array, index, value) {
    array.splice(index, 0, value);
}
/**
 * Removes a value from array at specific index.
 *
 * @param array  Source array
 * @param index  Index
 */
function removeIndex(array, index) {
    array.splice(index, 1);
}
/**
 * Searches the array using custom function and returns index of the item if
 * found.
 *
 * Will call `matches` function on all items of the array. If return value
 * evaluates to `true`, index is returned.
 *
 * Otherwise returns -1.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Index of the item if found
 */
function findIndex(array, matches) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        if (matches(array[i], i)) {
            return i;
        }
    }
    return -1;
}
/**
 * This is the same as `findIndex` except it searches from right to left.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Index of the item if found
 */
function findIndexReverse(array, matches) {
    let i = array.length;
    while (i > 0) {
        --i;
        if (matches(array[i], i)) {
            return i;
        }
    }
    return -1;
}
/**
 * Searches the array using custom function and returns item if found.
 *
 * Will call `matches` function on all items of the array. If return value
 * evaluates to `true`, index is returned.
 *
 * Otherwise returns `undefined`.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Item if found
 */
function find(array, matches) {
    const index = findIndex(array, matches);
    if (index !== -1) {
        return array[index];
    }
}
/**
 * This is the same as `find` except it searches from right to left.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Item if found
 */
function findReverse(array, matches) {
    const index = findIndexReverse(array, matches);
    if (index !== -1) {
        return array[index];
    }
}
/**
 * Searches the array using custom function and returns item if found.
 *
 * Will call `matches` function on all items of the array. If value
 * is not `undefined`, it returns it.
 *
 * Otherwise returns `undefined`.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Item if found
 */
function findMap(array, matches) {
    const length = array.length;
    for (let i = 0; i < length; ++i) {
        const value = matches(array[i], i);
        if (value !== undefined) {
            return value;
        }
    }
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function shuffle(array) {
    // https://stackoverflow.com/a/2450976/449477
    let currentIndex = array.length, temporaryValue, randomIndex;
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
}
/**
 * Orders an array using specific `ordering` function and returns right-most index of
 * the `value`.
 *
 * @ignore Exclude from docs
 * @param array     Source array
 * @param ordering  An ordering function
 * @returns Result of the search
 */
function getSortedIndex(array, ordering) {
    let start = 0;
    let end = array.length;
    let found = false;
    while (start < end) {
        // TODO is this faster/slower than using Math.floor ?
        const pivot = (start + end) >> 1;
        const order = ordering(array[pivot]);
        // less
        if (order < 0) {
            start = pivot + 1;
            // equal
        }
        else if (order === 0) {
            found = true;
            start = pivot + 1;
            // more
        }
        else {
            end = pivot;
        }
    }
    return {
        found: found,
        index: (found ? start - 1 : start)
    };
}
/**
 * Orders an array using specific `ordering` function and returns left-most index of
 * the `value`.
 *
 * @ignore Exclude from docs
 * @param array     Source array
 * @param ordering  An ordering function
 * @returns Result of the search
 */
function getFirstSortedIndex(array, ordering) {
    let start = 0;
    let end = array.length;
    let found = false;
    while (start < end) {
        // TODO is this faster/slower than using Math.floor ?
        const pivot = (start + end) >> 1;
        const order = ordering(array[pivot]);
        // less
        if (order < 0) {
            start = pivot + 1;
            // equal
        }
        else if (order === 0) {
            found = true;
            end = pivot;
            // more
        }
        else {
            end = pivot;
        }
    }
    return {
        found: found,
        index: start
    };
}
function keepIf(array, keep) {
    let i = array.length;
    while (i > 0) {
        --i;
        if (!keep(array[i])) {
            array.splice(i, 1);
        }
    }
}
//# sourceMappingURL=Array.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Children.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Children.js ***!
  \**************************************************************************/
/*! exports provided: Children */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Children", function() { return Children; });
/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");


/**
 * A version of [[List]] to hold children of the [[Container]].
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info
 */
class Children extends _List__WEBPACK_IMPORTED_MODULE_0__["List"] {
    constructor(container) {
        super();
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_container", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._container = container;
        this._events = this.events.onAll((change) => {
            if (change.type === "clear") {
                _Array__WEBPACK_IMPORTED_MODULE_1__["each"](change.oldValues, (x) => {
                    this._onRemoved(x);
                });
            }
            else if (change.type === "push") {
                this._onInserted(change.newValue);
            }
            else if (change.type === "setIndex") {
                this._onRemoved(change.oldValue);
                this._onInserted(change.newValue, change.index);
            }
            else if (change.type === "insertIndex") {
                this._onInserted(change.newValue, change.index);
            }
            else if (change.type === "removeIndex") {
                this._onRemoved(change.oldValue);
            }
            else if (change.type === "moveIndex") {
                this._onRemoved(change.value);
                this._onInserted(change.value, change.newIndex);
            }
            else {
                throw new Error("Unknown IListEvent type");
            }
        });
    }
    _onInserted(child, index) {
        child._setParent(this._container, true);
        const childrenDisplay = this._container._childrenDisplay;
        if (index === undefined) {
            childrenDisplay.addChild(child._display);
        }
        else {
            childrenDisplay.addChildAt(child._display, index);
        }
    }
    _onRemoved(child) {
        this._container._childrenDisplay.removeChild(child._display);
        this._container.markDirtyBounds();
        this._container.markDirty();
    }
    /**
     * Returns `true` if obejct is disposed.
     */
    isDisposed() {
        return this._disposed;
    }
    /**
     * Permanently dispose this object.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this._events.dispose();
            _Array__WEBPACK_IMPORTED_MODULE_1__["each"](this.values, (child) => {
                child.dispose();
            });
        }
    }
}
//# sourceMappingURL=Children.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js ***!
  \***********************************************************************/
/*! exports provided: rgba2hex, color, Color */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgba2hex", function() { return rgba2hex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "color", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Animation */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");



/**
 * @ignore
 */
function string2hex(string) {
    //string = cssColorNames[string.toLowerCase()] || string;
    if (string[0] === "#") {
        string = string.substr(1);
    }
    if (string.length == 3) {
        string = string[0].repeat(2) + string[1].repeat(2) + string[2].repeat(2);
    }
    return parseInt(string, 16);
}
/**
 * @ignore
 */
function rgba2hex(color) {
    color = color.replace(/[ ]/g, "");
    // Init
    let matches = color.match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i);
    // Try rgb() format
    if (matches) {
        matches.push("1");
    }
    else {
        matches = color.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i);
        if (!matches) {
            return 0x000000;
        }
    }
    let hex = "";
    for (let i = 1; i <= 3; i++) {
        let val = parseInt(matches[i]).toString(16);
        if (val.length == 1) {
            val = "0" + val;
        }
        hex += val;
    }
    return string2hex(hex);
}
/**
 * Returns a new [[Color]] object base on input.
 *
 * Accepts parameters in CSS hex or rgb/rtba strings, or hex numbers.
 *
 * * `"#f00"`
 * * `"#ff0000"`
 * * `"rgb(255, 0, 0)"`
 * * `"rgba(255, 0, 0, 1)"`
 * * `0xff0000`
 *
 * @param   input  Input color
 * @return         Color
 */
function color(input) {
    return Color.fromAny(input);
}
/**
 * Wherever color needs to be specified in amCharts 5, `Color` object needs to
 * be used.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/} for more info
 * @important
 */
class Color {
    constructor(hex) {
        Object.defineProperty(this, "_hex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._hex = hex | 0;
    }
    /**
     * Color numeric value.
     */
    get hex() {
        return this._hex;
    }
    /**
     * Value of color's R channel.
     * @return R value
     */
    get r() {
        return this._hex >>> 16;
    }
    /**
     * Value of color's G channel.
     * @return G value
     */
    get g() {
        return (this._hex >> 8) & 0xFF;
    }
    /**
     * Value of color's B channel.
     * @return B value
     */
    get b() {
        return this._hex & 0xFF;
    }
    /**
     * Returns color CSS representation in form of `rgba(r, g, b, a)` string.
     *
     * @param   alpha  Opacity
     * @return         CSS string
     */
    toCSS(alpha = 1) {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + alpha + ")";
    }
    /**
     * Returns color CSS representation in form of `#rgb` string.
     *
     * @return         CSS string
     */
    toCSSHex() {
        return "#" + _Utils__WEBPACK_IMPORTED_MODULE_1__["padString"](this.r.toString(16), 2) + _Utils__WEBPACK_IMPORTED_MODULE_1__["padString"](this.g.toString(16), 2) + _Utils__WEBPACK_IMPORTED_MODULE_1__["padString"](this.b.toString(16), 2);
    }
    /**
     * Returns color's HSL info.
     * @param   alpha Opacity
     * @return        HSL info
     */
    toHSL(alpha = 1) {
        return _Utils__WEBPACK_IMPORTED_MODULE_1__["rgbToHsl"]({
            r: this.r,
            g: this.g,
            b: this.b,
            a: alpha
        });
    }
    /**
     * Converts HSL values into a new [[Color]] object.
     *
     * @param   h H value
     * @param   s S value
     * @param   l L value
     * @return    Color object
     */
    static fromHSL(h, s, l) {
        const rgb = _Utils__WEBPACK_IMPORTED_MODULE_1__["hslToRgb"]({
            h: h,
            s: s,
            l: l
        });
        return this.fromRGB(rgb.r, rgb.g, rgb.b);
    }
    toString() {
        return this.toCSSHex();
    }
    /**
     * Converts hex number into a new [[Color]] object.
     *
     * ```TypeScript
     * Color.fromHex(0xff0000) // red
     * ```
     * ```JavaScript
     * Color.fromHex(0xff0000) // red
     * ```
     *
     * @param   hex  Hex color
     * @return       Color
     */
    static fromHex(hex) {
        return new Color(hex);
    }
    /**
     * Converts RGB values to a new [[Color]] object.
     *
     * @param   r  R value
     * @param   g  G value
     * @param   b  B value
     * @return     Color
     */
    static fromRGB(r, g, b) {
        return new Color((b | 0) + (g << 8) + (r << 16));
    }
    /**
     * Converts RGB string to a new [[Color]] object.
     *
     * ```TypeScript
     * Color.fromString("#ff0000") // red
     * ```
     * ```JavaScript
     * Color.fromString("#ff0000") // red
     * ```
     *
     * @param   s  RGB string
     * @return     Color
     */
    static fromString(s) {
        return new Color(string2hex(s));
    }
    /**
     * Converts CSS rgba() syntax to a new [[Color]] object.
     *
     * ```TypeScript
     * Color.fromCSS("rgba(255, 0, 0, 1)") // red
     * ```
     * ```JavaScript
     * Color.fromCSS("rgba(255, 0, 0, 1)") // red
     * ```
     *
     * @param  {string} s [description]
     * @return {Color}    [description]
     */
    static fromCSS(s) {
        return new Color(rgba2hex(s));
    }
    /**
     * Convert to color from virtually anything.
     *
     * Will throw an exception if unable to resolve the color.
     *
     * @param   s  Source
     * @return     Color
     */
    static fromAny(s) {
        if (_Type__WEBPACK_IMPORTED_MODULE_2__["isString"](s)) {
            if (s[0] == "#") {
                return Color.fromString(s);
            }
            else if (s.substr(0, 3) == "rgb") {
                return Color.fromCSS(s);
            }
        }
        else if (_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](s)) {
            return Color.fromHex(s);
        }
        else if (s instanceof Color) {
            return Color.fromHex(s.hex);
        }
        throw new Error("Unknown color syntax: " + s);
    }
    /**
     * Returns a new [[Color]] object based on either `lightAlternative` or
     * `darkAlternative` depending on which one is more contrasting with
     * the `color`.
     *
     * @param   color             Reference color
     * @param   lightAlternative  Light color
     * @param   darkAlternative   Dark color
     * @return                    Alternative color
     */
    static alternative(color, lightAlternative, darkAlternative) {
        const rgb = _Utils__WEBPACK_IMPORTED_MODULE_1__["alternativeColor"]({ r: color.r, g: color.g, b: color.b }, lightAlternative ? { r: lightAlternative.r, g: lightAlternative.g, b: lightAlternative.b } : undefined, darkAlternative ? { r: darkAlternative.r, g: darkAlternative.g, b: darkAlternative.b } : undefined);
        return this.fromRGB(rgb.r, rgb.g, rgb.b);
    }
    /**
     * Returns an intermediate Color between two reference colors depending on
     * the progress (`diff`) between the two.
     *
     * @param   diff  Progress
     * @param   from  Source color
     * @param   to    Target color
     * @param   mode  Interpolation mode
     * @return        Color
     */
    static interpolate(diff, from, to, mode = "rgb") {
        if (mode == "hsl") {
            const fromHSL = from.toHSL();
            const toHSL = to.toHSL();
            return Color.fromHSL(Object(_Animation__WEBPACK_IMPORTED_MODULE_0__["range"])(diff, fromHSL.h, toHSL.h), Object(_Animation__WEBPACK_IMPORTED_MODULE_0__["range"])(diff, fromHSL.s, toHSL.s), Object(_Animation__WEBPACK_IMPORTED_MODULE_0__["range"])(diff, fromHSL.l, toHSL.l));
        }
        else {
            return Color.fromRGB(Object(_Animation__WEBPACK_IMPORTED_MODULE_0__["range"])(diff, from.r, to.r), Object(_Animation__WEBPACK_IMPORTED_MODULE_0__["range"])(diff, from.g, to.g), Object(_Animation__WEBPACK_IMPORTED_MODULE_0__["range"])(diff, from.b, to.b));
        }
    }
    /**
     * Returns a new [[Color]] lightened by `percent` value.
     *
     * Use negative value to darken the color.
     *
     * @param   color    Source color
     * @param   percent  Percent
     * @return           New color
     */
    static lighten(color, percent) {
        const rgb = _Utils__WEBPACK_IMPORTED_MODULE_1__["lighten"]({ r: color.r, g: color.g, b: color.b }, percent);
        return Color.fromRGB(rgb.r, rgb.g, rgb.b);
    }
    /**
     * Returns a new [[Color]] brightened by `percent` value.
     *
     * Use negative value to dim the color.
     *
     * @param   color    Source color
     * @param   percent  Percent
     * @return           New color
     */
    static brighten(color, percent) {
        const rgb = _Utils__WEBPACK_IMPORTED_MODULE_1__["brighten"]({ r: color.r, g: color.g, b: color.b }, percent);
        return Color.fromRGB(rgb.r, rgb.g, rgb.b);
    }
    /**
     * Returns a new [[Color]] saturated by `percent` value.
     *
     * Value range is between `0` (fully desaturated), to `1` (full color).
     *
     * @param   color    Source color
     * @param   percent  Percent
     * @return           New color
     */
    static saturate(color, percent) {
        const rgb = _Utils__WEBPACK_IMPORTED_MODULE_1__["saturate"]({ r: color.r, g: color.g, b: color.b }, percent);
        return Color.fromRGB(rgb.r, rgb.g, rgb.b);
    }
}
//# sourceMappingURL=Color.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js ***!
  \**************************************************************************/
/*! exports provided: ColorSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorSet", function() { return ColorSet; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");


/**
 * An object which holds list of colors and can generate new ones.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info
 */
class ColorSet extends _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    //protected _currentPass: number = 0;
    _afterNew() {
        // Applying themes because color set will not have parent
        super._afterNewApplyThemes();
        this._dirty["colors"] = false;
    }
    _beforeChanged() {
        if (this.isDirty("colors")) {
            this.reset();
        }
    }
    /**
     * @ignore
     */
    generateColors() {
        this.setPrivate("currentPass", this.getPrivate("currentPass", 0) + 1);
        const pass = this.getPrivate("currentPass");
        const colors = this.get("colors", [this.get("baseColor", _Color__WEBPACK_IMPORTED_MODULE_1__["Color"].fromHex(0xff0000))]);
        if (!this.getPrivate("numColors")) {
            this.setPrivate("numColors", colors.length);
        }
        //const len = colors.length;
        const len = this.getPrivate("numColors");
        //const start = len - this.getPrivate("numColors")!;
        const start = 0;
        const passOptions = this.get("passOptions");
        const reuse = this.get("reuse");
        for (let i = start; i < len; i++) {
            if (reuse) {
                colors.push(colors[i]);
            }
            else {
                const hsl = colors[i].toHSL();
                let h = hsl.h + (passOptions.hue || 0) * pass;
                while (h > 1)
                    h -= 1;
                let s = hsl.s + (passOptions.saturation || 0) * pass;
                //if (s > 1) s -= Math.floor(s);
                if (s > 1)
                    s = 1;
                if (s < 0)
                    s = 0;
                let l = hsl.l + (passOptions.lightness || 0) * pass;
                //if (l > 1) l -= Math.floor(l);
                while (l > 1)
                    l -= 1;
                colors.push(_Color__WEBPACK_IMPORTED_MODULE_1__["Color"].fromHSL(h, s, l));
            }
        }
    }
    /**
     * Returns a [[Color]] at specific index.
     *
     * If there's no color at this index, a new color is generated.
     *
     * @param   index  Index
     * @return         Color
     */
    getIndex(index) {
        const colors = this.get("colors", []);
        const saturation = this.get("saturation");
        if (index >= colors.length) {
            this.generateColors();
            return this.getIndex(index);
        }
        return saturation != null ? _Color__WEBPACK_IMPORTED_MODULE_1__["Color"].saturate(colors[index], saturation) : colors[index];
    }
    /**
     * Returns next [[Color]] in the list.
     *
     * If the list is out of colors, new ones are generated dynamically.
     */
    next() {
        let currentStep = this.getPrivate("currentStep", this.get("startIndex", 0));
        this.setPrivate("currentStep", currentStep + this.get("step", 1));
        return this.getIndex(currentStep);
    }
    /**
     * Resets counter to the start of the list, so the next call for `next()` will
     * return the first color.
     */
    reset() {
        this.setPrivate("currentStep", this.get("startIndex", 0));
        this.setPrivate("currentPass", 0);
    }
}
Object.defineProperty(ColorSet, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "ColorSet"
});
Object.defineProperty(ColorSet, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"].classNames.concat([ColorSet.className])
});
//# sourceMappingURL=ColorSet.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js ***!
  \**********************************************************************/
/*! exports provided: ListData, JsonData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListData", function() { return ListData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonData", function() { return JsonData; });
/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./List */ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js");

/**
 * A [[List]] that holds components data.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
 */
class ListData extends _List__WEBPACK_IMPORTED_MODULE_0__["List"] {
    constructor() {
        super(...arguments);
        /**
         * An optional processor for data.
         *
         * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Pre_processing_data} for more info
         */
        Object.defineProperty(this, "processor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    /**
     * @ignore
     */
    incrementRef() { }
    /**
     * @ignore
     */
    decrementRef() { }
    _onPush(newValue) {
        if (this.processor) {
            this.processor.processRow(newValue);
            //console.log(newValue)
        }
        super._onPush(newValue);
    }
    _onInsertIndex(index, newValue) {
        if (this.processor) {
            this.processor.processRow(newValue);
        }
        super._onInsertIndex(index, newValue);
    }
    _onSetIndex(index, oldValue, newValue) {
        if (this.processor) {
            this.processor.processRow(newValue);
        }
        super._onSetIndex(index, oldValue, newValue);
    }
}
/**
 * @deprecated
 * @todo remove
 */
class JsonData {
    constructor(value) {
        Object.defineProperty(this, "processor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._value = value;
    }
    incrementRef() { }
    decrementRef() { }
}
//# sourceMappingURL=Data.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/DataParser.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/DataParser.js ***!
  \****************************************************************************/
/*! exports provided: JSONParser, CSVParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONParser", function() { return JSONParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSVParser", function() { return CSVParser; });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");


/**
 * Tool to parse JSON string into structured data.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info
 * @important
 */
class JSONParser {
    /**
     * Parses JSON string.
     *
     * @param   input    JSON
     * @param   options  Options
     * @return           Data
     */
    static parse(input, options) {
        options = this._applyDefaults(options);
        try {
            if (_Type__WEBPACK_IMPORTED_MODULE_0__["isString"](input)) {
                let data = JSON.parse(input);
                if (options.reverse && _Type__WEBPACK_IMPORTED_MODULE_0__["isArray"](data)) {
                    data.reverse();
                }
                return data;
            }
            else if (_Type__WEBPACK_IMPORTED_MODULE_0__["isArray"](input) || _Type__WEBPACK_IMPORTED_MODULE_0__["isObject"](input)) {
                return input;
            }
            else {
                throw ("Unable to parse JSON data");
            }
        }
        catch (e) {
            return undefined;
        }
    }
    static _applyDefaults(options) {
        const normalized = {};
        const defaults = {
            reverse: false
        };
        if (!options) {
            options = {};
        }
        _Object__WEBPACK_IMPORTED_MODULE_1__["each"](defaults, (key, val) => {
            normalized[key] = options[key] || val;
        });
        return normalized;
    }
}
/**
 * Tool to parse JSON string into structured data.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info
 * @important
 */
class CSVParser {
    /**
     * Parses CSV string.
     *
     * @param   input    CSV
     * @param   options  Options
     * @return           Data
     */
    static parse(input, options) {
        options = this._applyDefaults(options);
        // Get CSV data as array
        let data = this.CSVToArray(input, options.delimiter);
        // Init resuling array
        let res = [], cols = [], col, i;
        // Skip rows
        for (i = 0; i < options.skipRows; i++) {
            data.shift();
        }
        // First row holds column names?
        if (options.useColumnNames) {
            cols = data.shift();
            // Normalize column names
            for (let x = 0; x < cols.length; x++) {
                // trim
                col = cols[x] != null ? cols[x].replace(/^\s+|\s+$/gm, "") : "";
                // Check for empty
                if ("" === col) {
                    col = "col" + x;
                }
                cols[x] = col;
            }
        }
        // Iterate through the result set
        let row;
        while (true) {
            row = options.reverse ? data.pop() : data.shift();
            if (!row) {
                break;
            }
            if (options.skipEmpty && row.length === 1 && row[0] === "") {
                continue;
            }
            let dataPoint = {};
            for (i = 0; i < row.length; i++) {
                col = undefined === cols[i] ? "col" + i : cols[i];
                dataPoint[col] = row[i];
            }
            res.push(dataPoint);
        }
        return res;
    }
    /**
     * @ignore
     */
    static CSVToArray(data, delimiter) {
        // Check to see if the delimiter is defined. If not,
        // then default to comma.
        delimiter = (delimiter || ',');
        // Create a regular expression to parse the CSV values.
        let objPattern = new RegExp((
        // Delimiters.
        "(\\" + delimiter + "|\\r?\\n|\\r|^)" +
            // Quoted fields.
            "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
            // Standard fields.
            "([^\"\\" + delimiter + "\\r\\n]*))"), "gi");
        // Create an array to hold our data. Give the array
        // a default empty first row.
        let arrData = [
            []
        ];
        // Create an array to hold our individual pattern
        // matching groups.
        let arrMatches = null;
        // Keep looping over the regular expression matches
        // until we can no longer find a match.
        while (true) {
            arrMatches = objPattern.exec(data);
            if (!arrMatches) {
                break;
            }
            // Get the delimiter that was found.
            let strMatchedDelimiter = arrMatches[1];
            // Check to see if the given delimiter has a length
            // (is not the start of string) and if it matches
            // field delimiter. If id does not, then we know
            // that this delimiter is a row delimiter.
            if (strMatchedDelimiter.length &&
                (strMatchedDelimiter !== delimiter)) {
                // Since we have reached a new row of data,
                // add an empty row to our data array.
                arrData.push([]);
            }
            // Now that we have our delimiter out of the way,
            // let's check to see which kind of value we
            // captured (quoted or unquoted).
            let strMatchedValue;
            if (arrMatches[2]) {
                // We found a quoted value. When we capture
                // this value, unescape any double quotes.
                strMatchedValue = arrMatches[2].replace(new RegExp("\"\"", "g"), "\"");
            }
            else {
                // We found a non-quoted value.
                strMatchedValue = arrMatches[3];
            }
            // Now that we have our value string, let's add
            // it to the data array.
            arrData[arrData.length - 1].push(strMatchedValue);
        }
        // Return the parsed data.
        return (arrData);
    }
    static _applyDefaults(options) {
        const normalized = {};
        const defaults = {
            delimiter: ",",
            reverse: false,
            skipRows: 0,
            skipEmpty: true,
            useColumnNames: false
        };
        if (!options) {
            options = {};
        }
        _Object__WEBPACK_IMPORTED_MODULE_1__["each"](defaults, (key, val) => {
            normalized[key] = options[key] || val;
        });
        return normalized;
    }
}
//# sourceMappingURL=DataParser.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/DataProcessor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/DataProcessor.js ***!
  \*******************************************************************************/
/*! exports provided: DataProcessor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataProcessor", function() { return DataProcessor; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");





/**
 * A tool that can process the data before it is being used in charts.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Pre_processing_data} for more info
 * @important
 */
class DataProcessor extends _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_checkDates", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_checkNumbers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_checkColors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_checkEmpty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_checkDeep", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _afterNew() {
        super._afterNew();
        this._checkFeatures();
        this.on("dateFields", () => this._checkFeatures());
        this.on("dateFormat", () => this._checkFeatures());
        this.on("numericFields", () => this._checkFeatures());
        this.on("colorFields", () => this._checkFeatures());
        this.on("emptyAs", () => this._checkFeatures());
    }
    _checkFeatures() {
        if (this.isDirty("dateFields") || this.isDirty("dateFormat")) {
            this._checkDates = this.get("dateFields") && (this.get("dateFields").length > 0);
        }
        if (this.isDirty("numericFields")) {
            this._checkNumbers = this.get("numericFields") && (this.get("numericFields").length > 0);
        }
        if (this.isDirty("colorFields")) {
            this._checkColors = this.get("colorFields") && (this.get("colorFields").length > 0);
        }
        if (this.isDirty("emptyAs")) {
            this._checkEmpty = this.get("emptyAs") != null;
        }
        this._checkDeepFeatures();
    }
    _checkDeepFeatures() {
        const deepFields = [];
        _Array__WEBPACK_IMPORTED_MODULE_4__["each"](["dateFields", "numericFields", "colorFields"], (where) => {
            _Array__WEBPACK_IMPORTED_MODULE_4__["each"](this.get(where, []), (field) => {
                const steps = field.split(".");
                steps.pop();
                while (steps.length > 0) {
                    deepFields.push(steps.join("."));
                    steps.pop();
                }
            });
        });
        this._checkDeep = deepFields.length > 0;
        this.setPrivate("deepFields", deepFields);
    }
    /**
     * Processess entire array of data.
     *
     * NOTE: calling this will modify original array!
     */
    processMany(data) {
        if (_Type__WEBPACK_IMPORTED_MODULE_2__["isArray"](data) && (this._checkDates || this._checkNumbers || this._checkColors || this._checkEmpty)) {
            _Array__WEBPACK_IMPORTED_MODULE_4__["each"](data, (row) => {
                this.processRow(row);
            });
        }
    }
    /**
     * Processes a row (object) of data.
     *
     * NOTE: calling this will modify values of the original object!
     */
    processRow(row, prefix = "") {
        _Object__WEBPACK_IMPORTED_MODULE_3__["each"](row, (key, _value) => {
            const lookupKey = prefix + key;
            if (this._checkEmpty) {
                row[key] = this._maybeToEmpty(row[key]);
            }
            if (this._checkNumbers) {
                row[key] = this._maybeToNumber(lookupKey, row[key]);
            }
            if (this._checkDates) {
                row[key] = this._maybeToDate(lookupKey, row[key]);
            }
            if (this._checkColors) {
                row[key] = this._maybeToColor(lookupKey, row[key]);
            }
            if (this._checkDeep && this.getPrivate("deepFields", []).indexOf(lookupKey) !== -1 && _Type__WEBPACK_IMPORTED_MODULE_2__["isObject"](row[key])) {
                this.processRow(row[key], lookupKey + ".");
            }
        });
    }
    _maybeToNumber(field, value) {
        if (this.get("numericFields").indexOf(field) !== -1) {
            return _Type__WEBPACK_IMPORTED_MODULE_2__["toNumber"](value);
        }
        return value;
    }
    _maybeToDate(field, value) {
        if (this.get("dateFields").indexOf(field) !== -1) {
            return this._root.dateFormatter.parse(value, this.get("dateFormat", "")).getTime();
        }
        return value;
    }
    _maybeToEmpty(value) {
        if ((value == null || value == "") && this.get("emptyAs") != null) {
            return this.get("emptyAs");
        }
        return value;
    }
    _maybeToColor(field, value) {
        if (this.get("colorFields").indexOf(field) !== -1) {
            return _Color__WEBPACK_IMPORTED_MODULE_1__["Color"].fromAny(value);
        }
        return value;
    }
}
//# sourceMappingURL=DataProcessor.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js ***!
  \*******************************************************************************/
/*! exports provided: DateFormatter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DateFormatter", function() { return DateFormatter; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _TextFormatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/* harmony import */ var _Timezone__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Timezone */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Timezone.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");





class DateFormatter extends _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    _setDefaults() {
        // Defaults
        this._setDefault("capitalize", true);
        this._setDefault("dateFormat", "yyyy-MM-dd");
        super._setDefaults();
    }
    _beforeChanged() {
        super._beforeChanged();
    }
    format(source, format) {
        // Locale?
        // TODO
        // No format passed in or it's empty
        if (typeof format === "undefined" || format === "") {
            format = this.get("dateFormat", "yyyy-MM-dd");
        }
        // Init return value
        let formatted;
        // Cast?
        // TODO: decide if we need to cast
        let date = source;
        // Is it a built-in format or Intl.DateTimeFormat
        if (_Type__WEBPACK_IMPORTED_MODULE_3__["isObject"](format)) {
            try {
                const locales = this.get("intlLocales");
                if (locales) {
                    return new Intl.DateTimeFormat(locales, format).format(date);
                }
                else {
                    return new Intl.DateTimeFormat(undefined, format).format(date);
                }
            }
            catch (e) {
                return "Invalid";
            }
        }
        // get format info (it will also deal with parser caching)
        let info = this.parseFormat(format);
        // Should we apply custom time zone?
        const timezone = this._root.timezone;
        if (timezone && !this._root.utc) {
            date = timezone.convertLocal(date);
        }
        // Check if it's a valid date
        if (!_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](date.getTime())) {
            // TODO translation
            //return this._t("Invalid date");
            return "Invalid date";
        }
        // Apply format
        formatted = this.applyFormat(date, info);
        // Capitalize
        if (this.get("capitalize")) {
            formatted = formatted.replace(/^.{1}/, formatted.substr(0, 1).toUpperCase());
        }
        // We're done
        return formatted;
    }
    /**
     * Applies format to Date.
     *
     * @param date      Date object
     * @param info      Parsed format information
     * @return Formatted date string
     */
    applyFormat(date, info) {
        // Init return value
        let res = info.template;
        // Get values
        let fullYear, month, weekday, day, hours, minutes, seconds, milliseconds, timestamp = date.getTime();
        if (this._root.utc) {
            fullYear = date.getUTCFullYear();
            month = date.getUTCMonth();
            weekday = date.getUTCDay();
            day = date.getUTCDate();
            hours = date.getUTCHours();
            minutes = date.getUTCMinutes();
            seconds = date.getUTCSeconds();
            milliseconds = date.getUTCMilliseconds();
        }
        else {
            fullYear = date.getFullYear();
            month = date.getMonth();
            weekday = date.getDay();
            day = date.getDate();
            hours = date.getHours();
            minutes = date.getMinutes();
            seconds = date.getSeconds();
            milliseconds = date.getMilliseconds();
        }
        // Go through each part and format/replace it in template
        for (let i = 0, len = info.parts.length; i < len; i++) {
            let value = "";
            switch (info.parts[i]) {
                case "G":
                    value = this._t(fullYear < 0
                        ? "_era_bc"
                        : "_era_ad");
                    break;
                case "yyyy":
                    value = Math.abs(fullYear).toString();
                    if (fullYear < 0) {
                        value += this._t("_era_bc");
                    }
                    break;
                case "yyy":
                case "yy":
                case "y":
                    value = Math.abs(fullYear).toString().substr(-info.parts[i].length);
                    if (fullYear < 0) {
                        value += this._t("_era_bc");
                    }
                    break;
                case "YYYY":
                case "YYY":
                case "YY":
                case "Y":
                    let year = _Utils__WEBPACK_IMPORTED_MODULE_4__["getWeekYear"](date, this._root.utc);
                    if (info.parts[i] == "YYYY") {
                        value = Math.abs(year).toString();
                    }
                    else {
                        value = Math.abs(year).toString().substr(-info.parts[i].length);
                    }
                    if (year < 0) {
                        value += this._t("_era_bc");
                    }
                    break;
                case "u":
                    // @todo
                    break;
                case "q":
                    value = "" + Math.ceil((date.getMonth() + 1) / 3);
                    break;
                case "MMMMM":
                    value = this._t(this._getMonth(month)).substr(0, 1);
                    break;
                case "MMMM":
                    value = this._t(this._getMonth(month));
                    break;
                case "MMM":
                    value = this._t(this._getShortMonth(month));
                    break;
                case "MM":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](month + 1, 2, "0");
                    break;
                case "M":
                    value = (month + 1).toString();
                    break;
                case "ww":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](_Utils__WEBPACK_IMPORTED_MODULE_4__["getWeek"](date, this._root.utc), 2, "0");
                    break;
                case "w":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["getWeek"](date, this._root.utc).toString();
                    break;
                case "W":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["getMonthWeek"](date, this._root.utc).toString();
                    break;
                case "dd":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](day, 2, "0");
                    break;
                case "d":
                    value = day.toString();
                    break;
                case "DD":
                case "DDD":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](_Utils__WEBPACK_IMPORTED_MODULE_4__["getYearDay"](date, this._root.utc).toString(), info.parts[i].length, "0");
                    break;
                case "D":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["getYearDay"](date, this._root.utc).toString();
                    break;
                case "F":
                    // @todo
                    break;
                case "g":
                    // @todo
                    break;
                case "t":
                    value = this._root.language.translateFunc("_dateOrd").call(this, day);
                    break;
                case "E":
                    value = (weekday || 7).toString();
                    break;
                case "EE":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"]((weekday || 7).toString(), 2, "0");
                    break;
                case "EEE":
                case "eee":
                    value = this._t(this._getShortWeekday(weekday));
                    break;
                case "EEEE":
                case "eeee":
                    value = this._t(this._getWeekday(weekday));
                    break;
                case "EEEEE":
                case "eeeee":
                    value = this._t(this._getShortWeekday(weekday)).substr(0, 1);
                    break;
                case "e":
                case "ee":
                    value = (weekday - (this._root.locale.firstDayOfWeek || 1) + 1).toString();
                    if (info.parts[i] == "ee") {
                        value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](value, 2, "0");
                    }
                    break;
                case "a":
                    if (hours >= 12) {
                        value = this._t("PM");
                    }
                    else {
                        value = this._t("AM");
                    }
                    break;
                case "aa":
                    if (hours >= 12) {
                        value = this._t("P.M.");
                    }
                    else {
                        value = this._t("A.M.");
                    }
                    break;
                case "aaa":
                    if (hours >= 12) {
                        value = this._t("P");
                    }
                    else {
                        value = this._t("A");
                    }
                    break;
                case "h":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["get12Hours"](hours).toString();
                    break;
                case "hh":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](_Utils__WEBPACK_IMPORTED_MODULE_4__["get12Hours"](hours), 2, "0");
                    break;
                case "H":
                    value = hours.toString();
                    break;
                case "HH":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](hours, 2, "0");
                    break;
                case "K":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["get12Hours"](hours, 0).toString();
                    break;
                case "KK":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](_Utils__WEBPACK_IMPORTED_MODULE_4__["get12Hours"](hours, 0), 2, "0");
                    break;
                case "k":
                    value = (hours + 1).toString();
                    break;
                case "kk":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](hours + 1, 2, "0");
                    break;
                case "m":
                    value = minutes.toString();
                    break;
                case "mm":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](minutes, 2, "0");
                    break;
                case "s":
                    value = seconds.toString();
                    break;
                case "ss":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](seconds, 2, "0");
                    break;
                case "S":
                case "SS":
                case "SSS":
                    value = Math.round((milliseconds / 1000) * Math.pow(10, info.parts[i].length)).toString();
                    break;
                case "x":
                    value = timestamp.toString();
                    break;
                case "n":
                case "nn":
                case "nnn":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](milliseconds, info.parts[i].length, "0");
                    break;
                case "z":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["getTimeZone"](date, false, false, this._root.utc);
                    break;
                case "zz":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["getTimeZone"](date, true, false, this._root.utc);
                    break;
                case "zzz":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["getTimeZone"](date, false, true, this._root.utc);
                    break;
                case "zzzz":
                    value = _Utils__WEBPACK_IMPORTED_MODULE_4__["getTimeZone"](date, true, true, this._root.utc);
                    break;
                case "Z":
                case "ZZ":
                    let timezone = this._root.utc ? "UTC" : this._root.timezone;
                    if (timezone instanceof _Timezone__WEBPACK_IMPORTED_MODULE_2__["Timezone"]) {
                        timezone = timezone.name;
                    }
                    const offset = timezone ? _Utils__WEBPACK_IMPORTED_MODULE_4__["getTimezoneOffset"](timezone) : date.getTimezoneOffset();
                    let tz = Math.abs(offset) / 60;
                    let tzh = Math.floor(tz);
                    let tzm = tz * 60 - tzh * 60;
                    if (this._root.utc) {
                        tzh = 0;
                        tzm = 0;
                    }
                    if (info.parts[i] == "Z") {
                        value = "GMT";
                        value += offset > 0 ? "-" : "+";
                        value += _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](tzh, 2) + ":" + _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](tzm, 2);
                    }
                    else {
                        value = offset > 0 ? "-" : "+";
                        value += _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](tzh, 2) + _Utils__WEBPACK_IMPORTED_MODULE_4__["padString"](tzm, 2);
                    }
                    break;
                case "i":
                    value = date.toISOString();
                    break;
                case "I":
                    value = date.toUTCString();
                    break;
            }
            res = res.replace(_Type__WEBPACK_IMPORTED_MODULE_3__["PLACEHOLDER"], value);
        }
        return res;
    }
    /**
     * Parses format into structured infromation.
     *
     * @param format Format template
     */
    parseFormat(format) {
        // Check cache
        // TODO: implement caching of the parsed format
        // Init format parse info holder
        let info = {
            "template": "",
            "parts": []
        };
        // Let TextFormatter split into chunks
        let chunks = _TextFormatter__WEBPACK_IMPORTED_MODULE_1__["TextFormatter"].chunk(format, true);
        for (let i = 0; i < chunks.length; i++) {
            let chunk = chunks[i];
            if (chunk.type === "value") {
                // Just "Date"?
                if (chunk.text.match(/^date$/i)) {
                    let dateFormat = this.get("dateFormat", "yyyy-MM-dd");
                    if (!_Type__WEBPACK_IMPORTED_MODULE_3__["isString"](dateFormat)) {
                        dateFormat = "yyyy-MM-dd";
                    }
                    chunk.text = dateFormat;
                }
                // Find all possible parts
                let matches = chunk.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);
                // Found?
                if (matches) {
                    // Populate template
                    for (let x = 0; x < matches.length; x++) {
                        info.parts.push(matches[x]);
                        chunk.text = chunk.text.replace(matches[x], _Type__WEBPACK_IMPORTED_MODULE_3__["PLACEHOLDER"]);
                    }
                }
            }
            // Apply to template
            info.template += chunk.text;
        }
        // Save cache
        // TODO
        return info;
    }
    _months() {
        return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    }
    _getMonth(index) {
        return this._months()[index];
    }
    _shortMonths() {
        return ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    }
    _getShortMonth(index) {
        return this._shortMonths()[index];
    }
    _weekdays() {
        return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    }
    _getWeekday(index) {
        return this._weekdays()[index];
    }
    _shortWeekdays() {
        return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    }
    _getShortWeekday(index) {
        return this._shortWeekdays()[index];
    }
    parse(source, format) {
        // Is it already a Date
        if (source instanceof Date) {
            return source;
        }
        // Is it a numeric timestamp
        if (_Type__WEBPACK_IMPORTED_MODULE_3__["isNumber"](source)) {
            return new Date(source);
        }
        // No? Let's check if it's string, and try converting to it if nec
        if (!_Type__WEBPACK_IMPORTED_MODULE_3__["isString"](source)) {
            source = source.toString();
        }
        // Init return value
        let res;
        // Init RegEx for parsing
        let reg = "";
        // Clean format
        format = _Utils__WEBPACK_IMPORTED_MODULE_4__["cleanFormat"](format);
        // Clip format to length of the source string
        format = format.substr(0, source.length);
        // Parse format
        let info = this.parseFormat(format);
        // Init parsed items holder
        let parsedIndexes = {
            "year": -1,
            "year3": -1,
            "year2": -1,
            "year1": -1,
            "month": -1,
            "monthShort": -1,
            "monthLong": -1,
            "weekdayShort": -1,
            "weekdayLong": -1,
            "day": -1,
            "yearDay": -1,
            "week": -1,
            "hourBase0": -1,
            "hour12Base0": -1,
            "hourBase1": -1,
            "hour12Base1": -1,
            "minute": -1,
            "second": -1,
            "millisecond": -1,
            "millisecondDigits": -1,
            "am": -1,
            "zone": -1,
            "timestamp": -1,
            "iso": -1
        };
        // Init values
        let resValues = {
            "year": 1970,
            "month": 0,
            "day": 1,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "millisecond": 0,
            "timestamp": null,
            "offset": 0,
            "utc": this._root.utc
        };
        // Index adjuster
        let indexAdjust = 0;
        let index = 0;
        // Iterate through all of the parts
        for (let i = 0; i < info.parts.length; i++) {
            // Set current match index
            index = i + indexAdjust + 1;
            switch (info.parts[i]) {
                case "yyyy":
                case "YYYY":
                    reg += "([0-9]{4})";
                    parsedIndexes.year = index;
                    break;
                case "yyy":
                case "YYY":
                    reg += "([0-9]{3})";
                    parsedIndexes.year3 = index;
                    break;
                case "yy":
                case "YY":
                    reg += "([0-9]{2})";
                    parsedIndexes.year2 = index;
                    break;
                case "y":
                case "Y":
                    reg += "([0-9]{1})";
                    parsedIndexes.year1 = index;
                    break;
                case "MMMM":
                    reg += "(" + this.getStringList(this._months()).join("|") + ")";
                    parsedIndexes.monthLong = index;
                    break;
                case "MMM":
                    reg += "(" + this.getStringList(this._shortMonths()).join("|") + ")";
                    parsedIndexes.monthShort = index;
                    break;
                case "MM":
                case "M":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.month = index;
                    break;
                case "ww":
                case "w":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.week = index;
                    break;
                case "dd":
                case "d":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.day = index;
                    break;
                case "DDD":
                case "DD":
                case "D":
                    reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                    parsedIndexes.yearDay = index;
                    break;
                case "dddd":
                    reg += "(" + this.getStringList(this._weekdays()).join("|") + ")";
                    parsedIndexes.weekdayLong = index;
                    break;
                case "ddd":
                    reg += "(" + this.getStringList(this._shortWeekdays()).join("|") + ")";
                    parsedIndexes.weekdayShort = index;
                    break;
                case "aaa":
                case "aa":
                case "a":
                    // TODO: fix (escape regex)
                    reg += "(" + this.getStringList(["AM", "PM", "A\.M\.", "P\.M\.", "A", "P"]).join("|") + ")";
                    parsedIndexes.am = index;
                    break;
                case "hh":
                case "h":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hour12Base1 = index;
                    break;
                case "HH":
                case "H":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hourBase0 = index;
                    break;
                case "KK":
                case "K":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hour12Base0 = index;
                    break;
                case "kk":
                case "k":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hourBase1 = index;
                    break;
                case "mm":
                case "m":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.minute = index;
                    break;
                case "ss":
                case "s":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.second = index;
                    break;
                case "SSS":
                case "SS":
                case "S":
                    reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                    parsedIndexes.millisecond = index;
                    parsedIndexes.millisecondDigits = info.parts[i].length;
                    break;
                case "nnn":
                case "nn":
                case "n":
                    reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                    parsedIndexes.millisecond = index;
                    break;
                case "x":
                    reg += "([0-9]{1,})";
                    parsedIndexes.timestamp = index;
                    break;
                case "Z":
                    reg += "GMT([-+]+[0-9]{2}:[0-9]{2})";
                    parsedIndexes.zone = index;
                    break;
                case "ZZ":
                    reg += "([\\-+]+[0-9]{2}[0-9]{2})";
                    parsedIndexes.zone = index;
                    break;
                case "i":
                    reg += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\.?([0-9]{0,3})([zZ]|[+\\-][0-9]{2}:?[0-9]{2}|$)";
                    parsedIndexes.iso = index;
                    indexAdjust += 7;
                    break;
                case "G":
                case "YYYY":
                case "YYY":
                case "YY":
                case "Y":
                case "MMMMM":
                case "W":
                case "EEEEE":
                case "EEEE":
                case "EEE":
                case "EE":
                case "E":
                case "eeeee":
                case "eeee":
                case "eee":
                case "ee":
                case "e":
                case "zzzz":
                case "zzz":
                case "zz":
                case "z":
                case "t":
                    // Ignore
                    indexAdjust--;
                    break;
            }
            reg += "[^0-9]*";
        }
        // Try matching
        let regex = new RegExp(reg);
        let matches = source.match(regex);
        if (matches) {
            // Populate the date object
            // Full year
            if (parsedIndexes.year > -1) {
                resValues.year = parseInt(matches[parsedIndexes.year]);
            }
            // 3-digit year
            if (parsedIndexes.year3 > -1) {
                let val = parseInt(matches[parsedIndexes.year3]);
                val += 1000;
                resValues.year = val;
            }
            // 2-digit year
            if (parsedIndexes.year2 > -1) {
                let val = parseInt(matches[parsedIndexes.year2]);
                if (val > 50) {
                    val += 1000;
                }
                else {
                    val += 2000;
                }
                resValues.year = val;
            }
            // 1-digit year
            if (parsedIndexes.year1 > -1) {
                let val = parseInt(matches[parsedIndexes.year1]);
                val = Math.floor((new Date().getFullYear()) / 10) * 10 + val;
                resValues.year = val;
            }
            // Full month
            if (parsedIndexes.monthLong > -1) {
                resValues.month = this.resolveMonth(matches[parsedIndexes.monthLong]);
            }
            // Short month
            if (parsedIndexes.monthShort > -1) {
                resValues.month = this.resolveShortMonth(matches[parsedIndexes.monthShort]);
            }
            // Numeric month
            if (parsedIndexes.month > -1) {
                resValues.month = parseInt(matches[parsedIndexes.month]) - 1;
            }
            // Weekday
            // @todo
            // Week
            if ((parsedIndexes.week > -1) && (parsedIndexes.day === -1)) {
                // We parse weeks ONLY if day is not explicitly set
                // TODO: this needs work
                // (but maybe later - I can hardly imagine anyone passing their dates in weeks)
                resValues.month = 0;
                resValues.day = _Utils__WEBPACK_IMPORTED_MODULE_4__["getDayFromWeek"](parseInt(matches[parsedIndexes.week]), resValues.year, 1, this._root.utc);
            }
            // Day
            if (parsedIndexes.day > -1) {
                resValues.day = parseInt(matches[parsedIndexes.day]);
            }
            // Year day
            if (parsedIndexes.yearDay > -1) {
                resValues.month = 0;
                resValues.day = parseInt(matches[parsedIndexes.yearDay]);
            }
            // 24 Hour (0-23)
            if (parsedIndexes.hourBase0 > -1) {
                resValues.hour = parseInt(matches[parsedIndexes.hourBase0]);
            }
            // 24 Hour (1-24)
            if (parsedIndexes.hourBase1 > -1) {
                resValues.hour = parseInt(matches[parsedIndexes.hourBase1]) - 1;
            }
            // 12 Hour (0-11)
            if (parsedIndexes.hour12Base0 > -1) {
                let val = parseInt(matches[parsedIndexes.hour12Base0]);
                if (val == 11) {
                    val = 0;
                }
                if ((parsedIndexes.am > -1) && !this.isAm(matches[parsedIndexes.am])) {
                    val += 12;
                }
                resValues.hour = val;
            }
            // 12 Hour (1-12)
            if (parsedIndexes.hour12Base1 > -1) {
                let val = parseInt(matches[parsedIndexes.hour12Base1]);
                if (val == 12) {
                    val = 0;
                }
                if ((parsedIndexes.am > -1) && !this.isAm(matches[parsedIndexes.am])) {
                    val += 12;
                }
                resValues.hour = val;
            }
            // Minute
            if (parsedIndexes.minute > -1) {
                resValues.minute = parseInt(matches[parsedIndexes.minute]);
            }
            // Second
            if (parsedIndexes.second > -1) {
                resValues.second = parseInt(matches[parsedIndexes.second]);
            }
            // Millisecond
            if (parsedIndexes.millisecond > -1) {
                let val = parseInt(matches[parsedIndexes.millisecond]);
                if (parsedIndexes.millisecondDigits == 2) {
                    val *= 10;
                }
                else if (parsedIndexes.millisecondDigits == 1) {
                    val *= 100;
                }
                resValues.millisecond = val;
            }
            // Timestamp
            if (parsedIndexes.timestamp > -1) {
                resValues.timestamp = parseInt(matches[parsedIndexes.timestamp]);
                const ts = new Date(resValues.timestamp);
                resValues.year = ts.getUTCFullYear();
                resValues.month = ts.getUTCMonth();
                resValues.day = ts.getUTCDate();
                resValues.hour = ts.getUTCHours();
                resValues.minute = ts.getUTCMinutes();
                resValues.second = ts.getUTCSeconds();
                resValues.millisecond = ts.getUTCMilliseconds();
            }
            // Adjust time zone
            if (parsedIndexes.zone > -1) {
                resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.zone]);
            }
            // ISO
            if (parsedIndexes.iso > -1) {
                resValues.year = _Type__WEBPACK_IMPORTED_MODULE_3__["toNumber"](matches[parsedIndexes.iso + 0]);
                resValues.month = _Type__WEBPACK_IMPORTED_MODULE_3__["toNumber"](matches[parsedIndexes.iso + 1]) - 1;
                resValues.day = _Type__WEBPACK_IMPORTED_MODULE_3__["toNumber"](matches[parsedIndexes.iso + 2]);
                resValues.hour = _Type__WEBPACK_IMPORTED_MODULE_3__["toNumber"](matches[parsedIndexes.iso + 3]);
                resValues.minute = _Type__WEBPACK_IMPORTED_MODULE_3__["toNumber"](matches[parsedIndexes.iso + 4]);
                resValues.second = _Type__WEBPACK_IMPORTED_MODULE_3__["toNumber"](matches[parsedIndexes.iso + 5]);
                resValues.millisecond = _Type__WEBPACK_IMPORTED_MODULE_3__["toNumber"](matches[parsedIndexes.iso + 6]);
                if (matches[parsedIndexes.iso + 7] == "Z" || matches[parsedIndexes.iso + 7] == "z") {
                    resValues.utc = true;
                }
                else if (matches[parsedIndexes.iso + 7] != "") {
                    resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.iso + 7]);
                }
            }
            // Create Date object
            if (resValues.utc) {
                res = new Date(Date.UTC(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond));
            }
            else {
                res = new Date(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute + resValues.offset, resValues.second, resValues.millisecond);
            }
        }
        else {
            // Didn't match anything
            // Let's try dropping it into Date constructor and hope for the best
            res = new Date(source);
        }
        return res;
    }
    resolveTimezoneOffset(date, zone) {
        let value = zone.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/);
        if (value) {
            let match = zone.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/);
            let dir = match[1];
            let hour = match[2];
            let minute = match[3];
            let offset = parseInt(hour) * 60 + parseInt(minute);
            // Adjust offset
            // Making it negative does not seem to make sense, but it's right
            // because of how JavaScript calculates GMT offsets
            if (dir == "+") {
                offset *= -1;
            }
            // Check the difference in offset
            let originalOffset = (date || new Date()).getTimezoneOffset();
            let diff = offset - originalOffset;
            return diff;
        }
        return 0;
    }
    /**
     * Resolves month name (i.e. "December") into a month number (11).
     *
     * @param value  Month name
     * @return Month number
     */
    resolveMonth(value) {
        // Let's try English first
        let month = this._months().indexOf(value);
        if (month > -1) {
            return month;
        }
        // Try the translation
        if (!this._root.language.isDefault()) {
            month = this._root.language.translateAll(this._months()).indexOf(value);
            if (month > -1) {
                return month;
            }
        }
        return 0;
    }
    /**
     * Resolves short month name (i.e. "Dec") into a month number.
     *
     * @param value  Short month name
     * @return Month number
     */
    resolveShortMonth(value) {
        // Let's try English first
        let month = this._shortMonths().indexOf(value);
        if (month > -1) {
            return month;
        }
        // Maybe long month (workaround for May)
        month = this._months().indexOf(value);
        if (month > -1) {
            return month;
        }
        // Try the translation
        if (this._root.language && !this._root.language.isDefault()) {
            month = this._root.language.translateAll(this._shortMonths()).indexOf(value);
            if (month > -1) {
                return month;
            }
        }
        return 0;
    }
    /**
     * Checks if passed in string represents AM/PM notation in many of its
     * versions.
     *
     * @param value  Source string
     * @return Is it AM/PM?
     */
    isAm(value) {
        let list = this.getStringList(["AM", "A.M.", "A"]);
        return list.indexOf(value.toUpperCase()) > -1;
    }
    /**
     * Translates list of strings.
     *
     * @param list  Source strings
     * @return Translated strings
     */
    getStringList(list) {
        let res = [];
        for (let i = 0; i < list.length; i++) {
            // translate?
            if (this._root.language) {
                res.push(_Utils__WEBPACK_IMPORTED_MODULE_4__["escapeForRgex"](this._t(list[i])));
            }
            else {
                res.push(_Utils__WEBPACK_IMPORTED_MODULE_4__["escapeForRgex"](list[i]));
            }
        }
        return res;
    }
}
//# sourceMappingURL=DateFormatter.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js ***!
  \**************************************************************************/
/*! exports provided: DisposerClass, Disposer, ArrayDisposer, MultiDisposer, MutableValueDisposer, CounterDisposer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisposerClass", function() { return DisposerClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Disposer", function() { return Disposer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayDisposer", function() { return ArrayDisposer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiDisposer", function() { return MultiDisposer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MutableValueDisposer", function() { return MutableValueDisposer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CounterDisposer", function() { return CounterDisposer; });
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * A base class for disposable objects.
 *
 * @ignore Exclude from docs
 */
class DisposerClass {
    /**
     * Constructor.
     */
    constructor() {
        /**
         * Is object disposed?
         */
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._disposed = false;
    }
    /**
     * Checks if object is disposed.
     *
     * @return Disposed?
     */
    isDisposed() {
        return this._disposed;
    }
    /**
     * Disposes the object.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this._dispose();
        }
    }
}
/**
 * A class for creating an IDisposer.
 *
 * @ignore Exclude from docs
 */
class Disposer {
    /**
     * Constructor.
     *
     * @param dispose  Function that disposes object
     */
    constructor(dispose) {
        /**
         * Is object disposed?
         */
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Method that disposes the object.
         */
        Object.defineProperty(this, "_dispose", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._disposed = false;
        this._dispose = dispose;
    }
    /**
     * Checks if object is disposed.
     *
     * @return Disposed?
     */
    isDisposed() {
        return this._disposed;
    }
    /**
     * Disposes the object.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this._dispose();
        }
    }
}
/**
 * This can be extended by other classes to add a `_disposers` property.
 *
 * @ignore Exclude from docs
 */
class ArrayDisposer extends DisposerClass {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    _dispose() {
        _Array__WEBPACK_IMPORTED_MODULE_0__["each"](this._disposers, (x) => {
            x.dispose();
        });
    }
}
/**
 * A collection of related disposers that can be disposed in one go.
 *
 * @ignore Exclude from docs
 */
class MultiDisposer extends DisposerClass {
    constructor(disposers) {
        super();
        Object.defineProperty(this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._disposers = disposers;
    }
    _dispose() {
        _Array__WEBPACK_IMPORTED_MODULE_0__["each"](this._disposers, (x) => {
            x.dispose();
        });
    }
}
/**
 * A special kind of Disposer that has attached value set.
 *
 * If a new value is set using `set()` method, the old disposer value is
 * disposed.
 *
 * @ignore Exclude from docs
 * @todo Description
 */
class MutableValueDisposer extends DisposerClass {
    constructor() {
        super(...arguments);
        /**
         * Current disposer.
         */
        Object.defineProperty(this, "_disposer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Current value.
         */
        Object.defineProperty(this, "_value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    _dispose() {
        if (this._disposer != null) {
            this._disposer.dispose();
            this._disposer = undefined;
        }
    }
    /**
     * Returns current value.
     *
     * @return Value
     */
    get() {
        return this._value;
    }
    /**
     * Sets value and disposes previous disposer if it was set.
     *
     * @param value     New value
     * @param disposer  Disposer
     */
    set(value, disposer) {
        if (this._disposer != null) {
            this._disposer.dispose();
        }
        this._disposer = disposer;
        this._value = value;
    }
    /**
     * Resets the disposer value.
     */
    reset() {
        this.set(undefined, undefined);
    }
}
/**
 * @ignore Exclude from docs
 * @todo Description
 */
class CounterDisposer extends Disposer {
    constructor() {
        super(...arguments);
        /**
         * [_counter description]
         *
         * @todo Description
         */
        Object.defineProperty(this, "_counter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    /**
     * [increment description]
     *
     * @todo Description
     */
    increment() {
        // TODO throw an error if it is disposed
        ++this._counter;
        // TODO make this more efficient
        return new Disposer(() => {
            --this._counter;
            if (this._counter === 0) {
                this.dispose();
            }
        });
    }
}
//# sourceMappingURL=Disposer.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Draw.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Draw.js ***!
  \**********************************************************************/
/*! exports provided: segmentedLine, line, moveTo, clear, smoothedSegmentedline, smoothedLine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "segmentedLine", function() { return segmentedLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "line", function() { return line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moveTo", function() { return moveTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smoothedSegmentedline", function() { return smoothedSegmentedline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smoothedLine", function() { return smoothedLine; });
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/** @ignore */ /** */

/**
 * @ignore
 */
function segmentedLine(display, segments) {
    for (let s = 0, len = segments.length; s < len; s++) {
        const groups = segments[s];
        if (groups.length > 0) {
            let firstGroup = groups[0];
            if (firstGroup.length > 0) {
                let firstPoint = firstGroup[0];
                display.moveTo(firstPoint.x, firstPoint.y);
                for (let g = 0, len = groups.length; g < len; g++) {
                    line(display, groups[g]);
                }
            }
        }
    }
}
/**
 * @ignore
 */
function line(display, points) {
    for (let p = 0, len = points.length; p < len; p++) {
        const point = points[p];
        display.lineTo(point.x, point.y);
    }
}
/**
 * @ignore
 */
function moveTo(display, point) {
    display.moveTo(point.x, point.y);
}
/**
 * @ignore
 */
function clear(display) {
    display.clear();
}
/**
 * @ignore
 */
function smoothedSegmentedline(display, segments, tensionX, tensionY) {
    for (let s = 0, len = segments.length; s < len; s++) {
        const groups = segments[s];
        if (groups.length > 0) {
            let firstGroup = groups[0];
            if (firstGroup.length > 0) {
                let firstPoint = firstGroup[0];
                display.moveTo(firstPoint.x, firstPoint.y);
                for (let g = 0, len = groups.length; g < len; g++) {
                    const points = groups[g];
                    if (points.length > 0) {
                        display.lineTo(points[0].x, points[0].y);
                    }
                    smoothedLine(display, points, tensionX, tensionY);
                }
            }
        }
    }
}
/**
 * @ignore
 */
function smoothedLine(display, points, tensionX, tensionY) {
    for (let i = points.length - 1; i > 0; i--) {
        let p0 = points[i];
        let p1 = points[i - 1];
        if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {
            points.splice(i - 1, 1);
        }
    }
    if (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {
        line(display, points);
        return;
    }
    tensionX = 1 - tensionX + 0.00001;
    tensionY = 1 - tensionY + 0.00001;
    let first = points[0];
    let last = points[points.length - 1];
    let closed = false;
    if (_Math__WEBPACK_IMPORTED_MODULE_0__["round"](first.x, 3) == _Math__WEBPACK_IMPORTED_MODULE_0__["round"](last.x) && _Math__WEBPACK_IMPORTED_MODULE_0__["round"](first.y) == _Math__WEBPACK_IMPORTED_MODULE_0__["round"](last.y)) {
        closed = true;
    }
    // Can't moveTo here, as it wont be possible to have fill then.
    let path = "";
    for (let i = 0, len = points.length - 1; i < len; i++) {
        let p0 = points[i - 1];
        let p1 = points[i];
        let p2 = points[i + 1];
        let p3 = points[i + 2];
        if (i === 0) {
            if (closed) {
                p0 = points[len - 2];
            }
            else {
                p0 = points[0];
            }
        }
        else if (i == len - 1) {
            if (closed) {
                p3 = points[1];
            }
            else {
                p3 = p2;
            }
        }
        let controlPointA = _Math__WEBPACK_IMPORTED_MODULE_0__["getCubicControlPointA"](p0, p1, p2, tensionX, tensionY);
        let controlPointB = _Math__WEBPACK_IMPORTED_MODULE_0__["getCubicControlPointB"](p1, p2, p3, tensionX, tensionY);
        display.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);
    }
    return path;
}
//# sourceMappingURL=Draw.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js ***!
  \***********************************************************************************/
/*! exports provided: DurationFormatter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DurationFormatter", function() { return DurationFormatter; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _TextFormatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");





/**
 * A class used to format numberic values as time duration.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-durations/} for more info
 */
class DurationFormatter extends _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    constructor() {
        super(...arguments);
        /**
         * Collection of aliases for units.
         */
        Object.defineProperty(this, "_unitAliases", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                "Y": "y",
                "D": "d",
                "H": "h",
                "K": "h",
                "k": "h",
                "n": "S"
            }
        });
    }
    _setDefaults() {
        const dmillisecond = "_duration_millisecond";
        const dsecond = "_duration_second";
        const dminute = "_duration_minute";
        const dhour = "_duration_hour";
        const dday = "_duration_day";
        const dweek = "_duration_week";
        const dmonth = "_duration_month";
        const dyear = "_duration_year";
        const asecond = "_second";
        const aminute = "_minute";
        const ahour = "_hour";
        const aday = "_day";
        const aweek = "_week";
        const amonth = "_week";
        const ayear = "_year";
        // Defaults
        this._setDefault("negativeBase", 0);
        this._setDefault("baseUnit", "second");
        this._setDefault("durationFormats", {
            "millisecond": {
                "millisecond": this._t(dmillisecond),
                "second": this._t((dmillisecond + asecond)),
                "minute": this._t((dmillisecond + aminute)),
                "hour": this._t((dmillisecond + ahour)),
                "day": this._t((dmillisecond + aday)),
                "week": this._t((dmillisecond + aweek)),
                "month": this._t((dmillisecond + amonth)),
                "year": this._t((dmillisecond + ayear))
            },
            "second": {
                "second": this._t((dsecond)),
                "minute": this._t((dsecond + aminute)),
                "hour": this._t((dsecond + ahour)),
                "day": this._t((dsecond + aday)),
                "week": this._t((dsecond + aweek)),
                "month": this._t((dsecond + amonth)),
                "year": this._t((dsecond + ayear))
            },
            "minute": {
                "minute": this._t((dminute)),
                "hour": this._t((dminute + ahour)),
                "day": this._t((dminute + aday)),
                "week": this._t((dminute + aweek)),
                "month": this._t((dminute + amonth)),
                "year": this._t((dminute + ayear))
            },
            "hour": {
                "hour": this._t((dhour)),
                "day": this._t((dhour + aday)),
                "week": this._t((dhour + aweek)),
                "month": this._t((dhour + amonth)),
                "year": this._t((dhour + ayear))
            },
            "day": {
                "day": this._t((dday)),
                "week": this._t((dday + aweek)),
                "month": this._t((dday + amonth)),
                "year": this._t((dday + ayear))
            },
            "week": {
                "week": this._t((dweek)),
                "month": this._t((dweek + amonth)),
                "year": this._t((dweek + ayear))
            },
            "month": {
                "month": this._t((dmonth)),
                "year": this._t((dmonth + ayear))
            },
            "year": {
                "year": this._t(dyear)
            }
        });
        super._setDefaults();
    }
    _beforeChanged() {
        super._beforeChanged();
    }
    /**
     * Formats the number as duration.
     *
     * For example `1000` (base unit seconds) would be converted to `16:40` as in
     * 16 minutes and 40 seconds.
     *
     * @param value   Value to format
     * @param format  Format to apply
     * @param base    Override base unit
     * @return Formatted number
     */
    format(value, format, base) {
        // no base unit?
        let baseUnit = base || this.get("baseUnit");
        // no format passed in or empty
        if (typeof format === "undefined" || format === "") {
            if (this.get("durationFormat") != null) {
                format = this.get("durationFormat");
            }
            else {
                format = this.getFormat(_Type__WEBPACK_IMPORTED_MODULE_4__["toNumber"](value), undefined, baseUnit);
            }
        }
        // Clean format
        format = _Utils__WEBPACK_IMPORTED_MODULE_3__["cleanFormat"](format);
        // get format info (it will also deal with parser caching)
        let info = this.parseFormat(format, baseUnit);
        // cast to number just in case
        // TODO: maybe use better casting
        let source = Number(value);
        // format and replace the number
        let details;
        if (source > this.get("negativeBase")) {
            details = info.positive;
        }
        else if (source < this.get("negativeBase")) {
            details = info.negative;
        }
        else {
            details = info.zero;
        }
        // Format
        let formatted = this.applyFormat(source, details);
        // Apply color?
        if (details.color !== "") {
            formatted = "[" + details.color + "]" + formatted + "[/]";
        }
        return formatted;
    }
    /**
     * Parses supplied format into structured object which can be used to format
     * the number.
     *
     * @param format  Format string, i.e. "#,###.00"
     * @param base    Override base unit
     * @return Parsed information
     */
    parseFormat(format, base) {
        // Check cache
        // TODO
        // let cached = this.getCache(format);
        // if (cached != null) {
        // 	return cached;
        // }
        // no base unit?
        let baseUnit = base || this.get("baseUnit");
        // Initialize duration parsing info
        let info = {
            "positive": {
                "color": "",
                "template": "",
                "parts": [],
                "source": "",
                "baseUnit": baseUnit,
                "parsed": false,
                "absolute": false
            },
            "negative": {
                "color": "",
                "template": "",
                "parts": [],
                "source": "",
                "baseUnit": baseUnit,
                "parsed": false,
                "absolute": false
            },
            "zero": {
                "color": "",
                "template": "",
                "parts": [],
                "source": "",
                "baseUnit": baseUnit,
                "parsed": false,
                "absolute": false
            }
        };
        // Escape double vertical bars (that mean display one vertical bar)
        format = format.replace("||", _Type__WEBPACK_IMPORTED_MODULE_4__["PLACEHOLDER2"]);
        // Split it up and deal with different formats
        let parts = format.split("|");
        info.positive.source = parts[0];
        if (typeof parts[2] === "undefined") {
            info.zero = info.positive;
        }
        else {
            info.zero.source = parts[2];
        }
        if (typeof parts[1] === "undefined") {
            info.negative = info.positive;
        }
        else {
            info.negative.source = parts[1];
        }
        // Parse each
        _Object__WEBPACK_IMPORTED_MODULE_2__["each"](info, (_part, item) => {
            // Already parsed
            if (item.parsed) {
                return;
            }
            // Check cached
            // TODO
            // if (typeof this.getCache(item.source) !== "undefined") {
            // 	info[part] = this.getCache(item.source);
            // 	return;
            // }
            // Begin parsing
            let partFormat = item.source;
            // Check for [] directives
            let dirs = [];
            dirs = item.source.match(/^\[([^\]]*)\]/);
            if (dirs && dirs.length && dirs[0] !== "") {
                partFormat = item.source.substr(dirs[0].length);
                item.color = dirs[1];
            }
            // Let TextFormatter split into chunks
            let chunks = _TextFormatter__WEBPACK_IMPORTED_MODULE_1__["TextFormatter"].chunk(partFormat, true);
            for (let i = 0; i < chunks.length; i++) {
                let chunk = chunks[i];
                // replace back double vertical bar
                chunk.text = chunk.text.replace(_Type__WEBPACK_IMPORTED_MODULE_4__["PLACEHOLDER2"], "|");
                if (chunk.type === "value") {
                    // Just "Duration"?
                    // if (chunk.text.toLowerCase() === "duration") {
                    // 	chunk.text = durationFormat;
                    // }
                    // Check for "a" (absolute) modifier
                    if (chunk.text.match(/[yYMdDwhHKkmsSn]+a/)) {
                        item.absolute = true;
                        chunk.text = chunk.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1");
                    }
                    // Find all possible parts
                    let matches = chunk.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);
                    if (matches) {
                        // Populate template
                        for (let x = 0; x < matches.length; x++) {
                            // Is it an alias?
                            if (matches[x] == null) {
                                matches[x] = this._unitAliases[matches[x]];
                            }
                            item.parts.push(matches[x]);
                            chunk.text = chunk.text.replace(matches[x], _Type__WEBPACK_IMPORTED_MODULE_4__["PLACEHOLDER"]);
                        }
                    }
                }
                // Apply to template
                item.template += chunk.text;
            }
            // Apply style formatting
            //item.template = TextFormatter.format(item.template, this.outputFormat);
            // Save cache
            // TODO
            //this.setCache(item.source, item);
            // Mark this as parsed
            item.parsed = true;
        });
        // Save cache (the whole thing)
        // TODO
        //this.setCache(format, info);
        return info;
    }
    /**
     * Applies parsed format to a numeric value.
     *
     * @param value    Value
     * @param details  Parsed format as returned by {parseFormat}
     * @return Formatted duration
     */
    applyFormat(value, details) {
        // Use absolute values
        let negative = !details.absolute && (value < this.get("negativeBase"));
        value = Math.abs(value);
        // Recalculate to milliseconds
        let tstamp = this.toTimeStamp(value, details.baseUnit);
        // Init return value
        let res = details.template;
        // Iterate through duration parts
        for (let i = 0, len = details.parts.length; i < len; i++) {
            // Gather the part
            let part = details.parts[i];
            let unit = this._toTimeUnit(part.substr(0, 1));
            let digits = part.length;
            // Calculate current unit value
            let ints = Math.floor(tstamp / this._getUnitValue(unit));
            res = res.replace(_Type__WEBPACK_IMPORTED_MODULE_4__["PLACEHOLDER"], _Utils__WEBPACK_IMPORTED_MODULE_3__["padString"](ints, digits, "0"));
            // Reduce timestamp
            tstamp -= ints * this._getUnitValue(unit);
        }
        // Reapply negative sign
        if (negative) {
            res = "-" + res;
        }
        return res;
    }
    /**
     * Converts numeric value to timestamp in milliseconds.
     *
     * @param value     A source value
     * @param baseUnit  Base unit the source value is in: "q", "s", "i", "h", "d", "w", "m", "y"
     * @return Value representation as a timestamp in milliseconds
     */
    toTimeStamp(value, baseUnit) {
        return value * this._getUnitValue(baseUnit);
    }
    _toTimeUnit(code) {
        switch (code) {
            case "S":
                return "millisecond";
            case "s":
                return "second";
            case "m":
                return "minute";
            case "h":
                return "hour";
            case "d":
                return "day";
            case "w":
                return "week";
            case "M":
                return "month";
            case "y":
                return "year";
        }
        ;
    }
    /**
     * Returns appropriate default format for the value.
     *
     * If `maxValue` is sepcified, it will use that value to determine the time
     * unit for the format.
     *
     * For example if your `baseUnit` is `"second"` and you pass in `10`, you
     * will get `"10"`.
     *
     * However, you might want it to be formatted in the context of bigger scale,
     * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all
     * values, including small ones will use format with minutes, e.g.:
     * `00:10`, `00:50`, `12: 30`, etc.
     *
     * @param value     Value to format
     * @param maxValue  Maximum value to be used to determine format
     * @param baseUnit  Base unit of the value
     * @return Format
     */
    getFormat(value, maxValue, baseUnit) {
        // Is format override set?
        if (this.get("durationFormat") != null) {
            return this.get("durationFormat");
        }
        // Get base unit
        if (!baseUnit) {
            baseUnit = this.get("baseUnit");
        }
        if (maxValue != null && value != maxValue) {
            value = Math.abs(value);
            maxValue = Math.abs(maxValue);
            let maxUnit = this.getValueUnit(Math.max(value, maxValue), baseUnit);
            //let diffUnit = this.getValueUnit(Math.abs(maxValue - value), baseUnit);
            //console.log(maxUnit, diffUnit);
            return this.get("durationFormats")[baseUnit][maxUnit];
        }
        else {
            let unit = this.getValueUnit(value, baseUnit);
            return this.get("durationFormats")[baseUnit][unit];
        }
    }
    /**
     * Returns value's closest denominator time unit, e.g 100 seconds is
     * `"minute"`, while 59 seconds would still be `second`.
     *
     * @param value     Source duration value
     * @param baseUnit  Base unit
     * @return Denominator
     */
    getValueUnit(value, baseUnit) {
        // Get base unit
        if (!baseUnit) {
            baseUnit = this.get("baseUnit");
        }
        // Convert to milliseconds
        let currentUnit;
        let ms = this.getMilliseconds(value, baseUnit);
        _Object__WEBPACK_IMPORTED_MODULE_2__["eachContinue"](this._getUnitValues(), (key, val) => {
            if (key == baseUnit || currentUnit) {
                let num = ms / val;
                if (num <= 1) {
                    if (!currentUnit) {
                        currentUnit = key;
                    }
                    return false;
                }
                currentUnit = key;
            }
            return true;
        });
        return currentUnit;
    }
    /**
     * Converts value to milliseconds according to `baseUnit`.
     *
     * @param value     Source duration value
     * @param baseUnit  Base unit
     * @return Value in milliseconds
     */
    getMilliseconds(value, baseUnit) {
        // Get base unit
        if (!baseUnit) {
            baseUnit = this.get("baseUnit");
        }
        return value * this._getUnitValue(baseUnit);
    }
    _getUnitValue(timeUnit) {
        return this._getUnitValues()[timeUnit];
    }
    _getUnitValues() {
        return {
            "millisecond": 1,
            "second": 1000,
            "minute": 60000,
            "hour": 3600000,
            "day": 86400000,
            "week": 604800000,
            "month": 2592000000,
            "year": 31536000000,
        };
    }
}
//# sourceMappingURL=DurationFormatter.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js ***!
  \**********************************************************************/
/*! exports provided: linear, quad, cubic, pow, exp, sine, circle, yoyo, out, inOut, bounce, elastic */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quad", function() { return quad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubic", function() { return cubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sine", function() { return sine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circle", function() { return circle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yoyo", function() { return yoyo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "out", function() { return out; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inOut", function() { return inOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounce", function() { return bounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elastic", function() { return elastic; });
/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/**
 * A collection of easing functions
 *
 * Parts of this collection are taken from D3.js library (https://d3js.org/)
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * The functions below are from D3.js library (https://d3js.org/)
 *
 * ----------------------------------------------------------------------------
 * Copyright 2017 Mike Bostock
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *	this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	this list of conditions and the following disclaimer in the documentation
 *	and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *	contributors may be used to endorse or promote products derived from this
 *	software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ----------------------------------------------------------------------------
 * @hidden
 */
/**
 */
function linear(t) {
    return t;
}
function quad(t) {
    return t * t;
}
function cubic(t) {
    return t * t * t;
}
function pow(t, e) {
    return Math.pow(t, e);
}
function exp(t) {
    return Math.pow(2, 10 * t - 10);
}
function sine(t) {
    return 1 - Math.cos(t * _Math__WEBPACK_IMPORTED_MODULE_0__["HALFPI"]);
}
function circle(t) {
    return 1 - Math.sqrt(1 - t * t);
}
/**
 * ============================================================================
 * TRANSFORMERS
 * ============================================================================
 * @hidden
 */
/**
 */
function yoyo(ease) {
    return function (t) {
        if (t < 0.5) {
            return ease(t * 2.0);
        }
        else {
            return ease((1.0 - t) * 2.0);
        }
    };
}
function out(ease) {
    return function (t) {
        return 1.0 - ease(1.0 - t);
    };
}
function inOut(ease) {
    return function (t) {
        if (t <= 0.5) {
            return ease(t * 2.0) / 2.0;
        }
        else {
            return 1.0 - (ease((1.0 - t) * 2.0) / 2.0);
        }
    };
}
/**
 * ============================================================================
 * BOUNCE
 * ============================================================================
 * @hidden
 */
let b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
function bounce(t) {
    return 1 - bounceOut(1 - t);
}
/**
 * @ignore
 */
function bounceOut(t) {
    t = t;
    if (t < b1) {
        return b0 * t * t;
    }
    else if (t < b3) {
        return b0 * (t -= b2) * t + b4;
    }
    else if (t < b6) {
        return b0 * (t -= b5) * t + b7;
    }
    else {
        return b0 * (t -= b8) * t + b9;
    }
}
/**
 * ============================================================================
 * ELASTIC
 * ============================================================================
 * @hidden
 */
/**
 * @ignore
 */
let tau = 2 * Math.PI;
/**
 * @ignore
 */
let amplitude = 1;
/**
 * @ignore
 */
let period = 0.3 / tau;
/**
 * @ignore
 */
let s = Math.asin(1 / amplitude) * period;
function elastic(t) {
    let v = t;
    return amplitude * Math.pow(2, 10 * --v) * Math.sin((s - v) / period);
}
//# sourceMappingURL=Ease.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js ***!
  \************************************************************************/
/*! exports provided: Adapters, Animation, Settings, Entity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Adapters", function() { return Adapters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return Animation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Settings", function() { return Settings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Entity", function() { return Entity; });
/* harmony import */ var _Disposer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Animation */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js");
/* harmony import */ var _States__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./States */ "./node_modules/@amcharts/amcharts5/.internal/core/util/States.js");
/* harmony import */ var _Registry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Registry */ "./node_modules/@amcharts/amcharts5/.internal/core/Registry.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Ease__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Ease */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Order__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Order */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js");









/**
 * Allows to dynamically modify setting value of its target element.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
 */
class Adapters {
    constructor(entity) {
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_callbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_disabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._entity = entity;
    }
    /**
     * Add a function (`callback`) that will modify value for setting `key`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
     */
    add(key, callback) {
        let callbacks = this._callbacks[key];
        if (callbacks === undefined) {
            callbacks = this._callbacks[key] = [];
        }
        callbacks.push(callback);
        this._entity._markDirtyKey(key);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_0__["Disposer"](() => {
            if (_Array__WEBPACK_IMPORTED_MODULE_7__["removeFirst"](callbacks, callback)) {
                this._entity._markDirtyKey(key);
            }
        });
    }
    /**
     * Removes all adapters for the specific key.
     *
     * @since 5.1.0
     */
    remove(key) {
        const callbacks = this._callbacks[key];
        if (callbacks !== undefined) {
            delete this._callbacks[key];
            if (callbacks.length !== 0) {
                this._entity._markDirtyKey(key);
            }
        }
    }
    /**
     * Enables (previously disabled) adapters for specific key.
     *
     * @since 5.1.0
     */
    enable(key) {
        if (this._disabled[key]) {
            delete this._disabled[key];
            this._entity._markDirtyKey(key);
        }
    }
    /**
     * Disables all adapters for specific key.
     *
     * @since 5.1.0
     */
    disable(key) {
        if (!this._disabled[key]) {
            this._disabled[key] = true;
            this._entity._markDirtyKey(key);
        }
    }
    /**
     * @ignore
     */
    fold(key, value) {
        if (!this._disabled[key]) {
            const callbacks = this._callbacks[key];
            if (callbacks !== undefined) {
                for (let i = 0, len = callbacks.length; i < len; ++i) {
                    value = callbacks[i](value, this._entity, key);
                }
            }
        }
        return value;
    }
}
/**
 * Animation object.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/} for more info
 */
class Animation {
    constructor(animation, from, to, duration, easing, loops, startingTime) {
        Object.defineProperty(this, "_animation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_from", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_to", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_duration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_easing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_loops", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_interpolate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_oldTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_time", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_stopped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "_playing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__["EventDispatcher"]()
        });
        this._animation = animation;
        this._from = from;
        this._to = to;
        this._duration = duration;
        this._easing = easing;
        this._loops = loops;
        this._interpolate = Object(_Animation__WEBPACK_IMPORTED_MODULE_2__["getInterpolate"])(from, to);
        this._oldTime = startingTime;
    }
    get to() {
        return this._to;
    }
    get from() {
        return this._from;
    }
    get playing() {
        return this._playing;
    }
    get stopped() {
        return this._stopped;
    }
    stop() {
        if (!this._stopped) {
            this._stopped = true;
            this._playing = false;
            if (this.events.isEnabled("stopped")) {
                this.events.dispatch("stopped", {
                    type: "stopped",
                    target: this,
                });
            }
        }
    }
    pause() {
        this._playing = false;
        this._oldTime = null;
    }
    play() {
        if (!this._stopped && !this._playing) {
            this._playing = true;
            this._animation._startAnimation();
        }
    }
    get percentage() {
        return this._time / this._duration;
    }
    waitForStop() {
        return new Promise((resolve, _reject) => {
            if (this._stopped) {
                resolve();
            }
            else {
                const listener = () => {
                    stopped.dispose();
                    resolve();
                };
                const stopped = this.events.on("stopped", listener);
            }
        });
    }
    _checkEnded() {
        if (this._loops > 1) {
            --this._loops;
            return false;
        }
        else {
            return true;
        }
    }
    _run(currentTime) {
        if (this._oldTime !== null) {
            this._time += currentTime - this._oldTime;
            if (this._time > this._duration) {
                this._time = this._duration;
            }
        }
        this._oldTime = currentTime;
    }
    _reset(currentTime) {
        this._oldTime = currentTime;
        this._time = 0;
    }
    _value(diff) {
        return this._interpolate(this._easing(diff), this._from, this._to);
    }
}
/**
 * @ignore
 */
let counter = 0;
/**
 * Base class for [[Entity]] objects that support Settings.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
 */
class Settings {
    constructor(settings) {
        /**
         * Unique ID.
         */
        Object.defineProperty(this, "uid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ++counter
        });
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_privateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_settingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_privateSettingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_prevSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_prevPrivateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_animatingSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_animatingPrivateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // TODO move this into Entity
        Object.defineProperty(this, "_userProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._settings = settings;
    }
    _checkDirty() {
        _Object__WEBPACK_IMPORTED_MODULE_5__["keys"](this._settings).forEach((key) => {
            this._userProperties[key] = true;
            this._markDirtyKey(key);
        });
    }
    /**
     * @ignore
     */
    resetUserSettings() {
        this._userProperties = {};
    }
    _runAnimation(currentTime) {
        if (!this.isDisposed()) {
            let playing = false;
            _Object__WEBPACK_IMPORTED_MODULE_5__["each"](this._animatingSettings, (key, animation) => {
                if (animation._stopped) {
                    this._stopAnimation(key);
                }
                else if (animation._playing) {
                    animation._run(currentTime);
                    const diff = animation.percentage;
                    if (diff >= 1) {
                        if (animation._checkEnded()) {
                            this.set(key, animation._value(1));
                        }
                        else {
                            playing = true;
                            animation._reset(currentTime);
                            this._set(key, animation._value(1));
                        }
                    }
                    else {
                        playing = true;
                        this._set(key, animation._value(diff));
                    }
                }
            });
            _Object__WEBPACK_IMPORTED_MODULE_5__["each"](this._animatingPrivateSettings, (key, animation) => {
                if (animation._stopped) {
                    this._stopAnimationPrivate(key);
                }
                else if (animation._playing) {
                    animation._run(currentTime);
                    const diff = animation.percentage;
                    if (diff >= 1) {
                        if (animation._checkEnded()) {
                            this.setPrivate(key, animation._value(1));
                        }
                        else {
                            playing = true;
                            animation._reset(currentTime);
                            this._setPrivate(key, animation._value(1));
                        }
                    }
                    else {
                        playing = true;
                        this._setPrivate(key, animation._value(diff));
                    }
                }
            });
            return playing;
        }
        else {
            return false;
        }
    }
    _markDirtyKey(_key) {
        this.markDirty();
    }
    _markDirtyPrivateKey(_key) {
        this.markDirty();
    }
    /**
     * Sets a callback function to invoke when specific key of settings changes
     * or is set.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
     * @param   key       Settings key
     * @param   callback  Callback
     * @return            Disposer for event
     */
    on(key, callback) {
        let events = this._settingEvents[key];
        if (events === undefined) {
            events = this._settingEvents[key] = [];
        }
        events.push(callback);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_0__["Disposer"](() => {
            _Array__WEBPACK_IMPORTED_MODULE_7__["removeFirst"](events, callback);
            if (events.length === 0) {
                delete this._settingEvents[key];
            }
        });
    }
    /**
     * Sets a callback function to invoke when specific key of private settings
     * changes or is set.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
     * @ignore
     * @param   key       Private settings key
     * @param   callback  Callback
     * @return            Disposer for event
     */
    onPrivate(key, callback) {
        let events = this._privateSettingEvents[key];
        if (events === undefined) {
            events = this._privateSettingEvents[key] = [];
        }
        events.push(callback);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_0__["Disposer"](() => {
            _Array__WEBPACK_IMPORTED_MODULE_7__["removeFirst"](events, callback);
            if (events.length === 0) {
                delete this._privateSettingEvents[key];
            }
        });
    }
    /**
     * @ignore
     */
    getRaw(key, fallback) {
        const value = this._settings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    get(key, fallback) {
        return this.getRaw(key, fallback);
    }
    _sendKeyEvent(key, value) {
        const events = this._settingEvents[key];
        if (events !== undefined) {
            _Array__WEBPACK_IMPORTED_MODULE_7__["each"](events, (callback) => {
                callback(value, this, key);
            });
        }
    }
    _sendPrivateKeyEvent(key, value) {
        const events = this._privateSettingEvents[key];
        if (events !== undefined) {
            _Array__WEBPACK_IMPORTED_MODULE_7__["each"](events, (callback) => {
                callback(value, this, key);
            });
        }
    }
    /**
     * @ignore
     */
    _setRaw(key, old, value) {
        this._prevSettings[key] = old;
        this._sendKeyEvent(key, value);
    }
    /**
     * @ignore
     */
    setRaw(key, value) {
        const old = this._settings[key];
        this._settings[key] = value;
        if (old !== value) {
            this._setRaw(key, old, value);
        }
    }
    /**
     * @ignore
     */
    _set(key, value) {
        const old = this._settings[key];
        this._settings[key] = value;
        if (old !== value) {
            this._setRaw(key, old, value);
            this._markDirtyKey(key);
        }
    }
    _stopAnimation(key) {
        const animation = this._animatingSettings[key];
        if (animation) {
            delete this._animatingSettings[key];
            animation.stop();
        }
    }
    /**
     * Sets a setting `value` for the specified `key`, and returns the same `value`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    set(key, value) {
        this._set(key, value);
        this._stopAnimation(key);
        return value;
    }
    /**
     * Removes a setting value for the specified `key`;
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     */
    remove(key) {
        if (key in this._settings) {
            this._prevSettings[key] = this._settings[key];
            delete this._settings[key];
            this._sendKeyEvent(key, undefined);
            this._markDirtyKey(key);
        }
        this._stopAnimation(key);
    }
    /**
     * Removes all keys;
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     */
    removeAll() {
        _Array__WEBPACK_IMPORTED_MODULE_7__["each"](_Object__WEBPACK_IMPORTED_MODULE_5__["keys"](this._settings), (key) => {
            this.remove(key);
        });
    }
    /**
     * Returns a value of a private setting.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/#Private_settings} for more info
     */
    getPrivate(key, fallback) {
        const value = this._privateSettings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    /**
     * @ignore
     */
    _setPrivateRaw(key, old, value) {
        this._prevPrivateSettings[key] = old;
        this._sendPrivateKeyEvent(key, value);
    }
    /**
     * @ignore
     */
    setPrivateRaw(key, value) {
        const old = this._privateSettings[key];
        this._privateSettings[key] = value;
        if (old !== value) {
            this._setPrivateRaw(key, old, value);
        }
    }
    /**
     * @ignore
     */
    _setPrivate(key, value) {
        const old = this._privateSettings[key];
        this._privateSettings[key] = value;
        if (old !== value) {
            this._setPrivateRaw(key, old, value);
            this._markDirtyPrivateKey(key);
        }
    }
    _stopAnimationPrivate(key) {
        const animation = this._animatingPrivateSettings[key];
        if (animation) {
            animation.stop();
            delete this._animatingPrivateSettings[key];
        }
    }
    /**
     * @ignore
     */
    setPrivate(key, value) {
        this._setPrivate(key, value);
        this._stopAnimationPrivate(key);
        return value;
    }
    /**
     * @ignore
     */
    removePrivate(key) {
        if (key in this._privateSettings) {
            this._prevPrivateSettings[key] = this._privateSettings[key];
            delete this._privateSettings[key];
            this._markDirtyPrivateKey(key);
        }
        this._stopAnimationPrivate(key);
    }
    /**
     * Sets multiple settings at once.
     *
     * `settings` must be an object with key: value pairs.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param settings Settings
     */
    setAll(settings) {
        _Object__WEBPACK_IMPORTED_MODULE_5__["each"](settings, (key, value) => {
            this.set(key, value);
        });
    }
    /**
     * Animates setting values from current/start values to new ones.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Animating_settings} for more info
     * @param   options  Animation options
     * @return           Animation object
     */
    animate(options) {
        const key = options.key;
        const to = options.to;
        const duration = options.duration || 0;
        const loops = options.loops || 1;
        const from = (options.from === undefined ? this.get(key) : options.from);
        const easing = (options.easing === undefined ? _Ease__WEBPACK_IMPORTED_MODULE_6__["linear"] : options.easing);
        if (duration === 0) {
            this.set(key, to);
        }
        else {
            if (from === undefined || from === to) {
                this.set(key, to);
            }
            else {
                this.set(key, from);
                const animation = this._animatingSettings[key] = new Animation(this, from, to, duration, easing, loops, this._animationTime());
                this._startAnimation();
                return animation;
            }
        }
        const animation = new Animation(this, from, to, duration, easing, loops, null);
        animation.stop();
        return animation;
    }
    /**
     * @ignore
     */
    animatePrivate(options) {
        const key = options.key;
        const to = options.to;
        const duration = options.duration || 0;
        const loops = options.loops || 1;
        const from = (options.from === undefined ? this.getPrivate(key) : options.from);
        const easing = (options.easing === undefined ? _Ease__WEBPACK_IMPORTED_MODULE_6__["linear"] : options.easing);
        if (duration === 0) {
            this.setPrivate(key, to);
        }
        else {
            if (from === undefined || from === to) {
                this.setPrivate(key, to);
            }
            else {
                this.setPrivate(key, from);
                const animation = this._animatingPrivateSettings[key] = new Animation(this, from, to, duration, easing, loops, this._animationTime());
                this._startAnimation();
                return animation;
            }
        }
        const animation = new Animation(this, from, to, duration, easing, loops, null);
        animation.stop();
        return animation;
    }
    _dispose() { }
    /**
     * Returns `true` if this element is disposed.
     *
     * @return Disposed
     */
    isDisposed() {
        return this._disposed;
    }
    /**
     * Disposes this object.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this._dispose();
        }
    }
}
/**
 * Base class.
 *
 * @important
 */
class Entity extends Settings {
    /**
     * IMPORTANT! Do not instantiate this class via `new Class()` syntax.
     *
     * Use static method `Class.new()` instead.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @ignore
     */
    constructor(root, settings, isReal, templates = []) {
        super(settings);
        Object.defineProperty(this, "_root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_user_id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        }); // for testing purposes
        Object.defineProperty(this, "states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _States__WEBPACK_IMPORTED_MODULE_3__["States"](this)
        });
        Object.defineProperty(this, "adapters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Adapters(this)
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._createEvents()
        });
        Object.defineProperty(this, "_userPrivateProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_dirtyPrivate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Templates for the themes
        Object.defineProperty(this, "_templates", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Internal templates which can be overridden by the user's templates
        Object.defineProperty(this, "_internalTemplates", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Default themes which can be overridden by the user's themes
        Object.defineProperty(this, "_defaultThemes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Disposers for all of the templates
        Object.defineProperty(this, "_templateDisposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_disposers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        // Whether the template setup function should be run
        Object.defineProperty(this, "_runSetup", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_disposerProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        this._root = root;
        this._internalTemplates = templates;
        if (settings.id) {
            this._registerId(settings.id);
        }
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   root      Root element
     * @param   settings  Settings
     * @param   template  Template
     * @return            Instantiated object
     */
    static new(root, settings, template) {
        const x = (new this(root, settings, true));
        x._template = template;
        x._afterNew();
        return x;
    }
    static _new(root, settings, templates = []) {
        const x = (new this(root, settings, true, templates));
        x._afterNew();
        return x;
    }
    _afterNew() {
        this._checkDirty();
        let shouldApply = false;
        const template = this._template;
        if (template) {
            shouldApply = true;
            template._setObjectTemplate(this);
        }
        _Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._internalTemplates, (template) => {
            shouldApply = true;
            template._setObjectTemplate(this);
        });
        if (shouldApply) {
            this._applyTemplates(false);
        }
        this.states.create("default", {});
        this._setDefaults();
    }
    // This is the same as _afterNew, except it also applies the themes.
    // This should only be used for classes which don't have a parent (because they extend from Entity and not Sprite).
    _afterNewApplyThemes() {
        this._checkDirty();
        const template = this._template;
        if (template) {
            template._setObjectTemplate(this);
        }
        _Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._internalTemplates, (template) => {
            template._setObjectTemplate(this);
        });
        this.states.create("default", {});
        this._setDefaults();
        this._applyThemes();
    }
    _createEvents() {
        return new _EventDispatcher__WEBPACK_IMPORTED_MODULE_1__["EventDispatcher"]();
    }
    /**
     * @ignore
     */
    get classNames() {
        return this.constructor.classNames;
    }
    /**
     * @ignore
     */
    get className() {
        return this.constructor.className;
    }
    _setDefaults() {
    }
    _setDefault(key, value) {
        if (!(key in this._settings)) {
            super.set(key, value);
        }
    }
    _setRawDefault(key, value) {
        if (!(key in this._settings)) {
            super.setRaw(key, value);
        }
    }
    _clearDirty() {
        _Object__WEBPACK_IMPORTED_MODULE_5__["keys"](this._dirty).forEach((key) => {
            this._dirty[key] = false;
        });
        _Object__WEBPACK_IMPORTED_MODULE_5__["keys"](this._dirtyPrivate).forEach((key) => {
            this._dirtyPrivate[key] = false;
        });
    }
    /**
     * @ignore
     */
    isDirty(key) {
        return !!this._dirty[key];
    }
    /**
     * @ignore
     */
    isPrivateDirty(key) {
        return !!this._dirtyPrivate[key];
    }
    _markDirtyKey(key) {
        this._dirty[key] = true;
        super._markDirtyKey(key);
    }
    _markDirtyPrivateKey(key) {
        this._dirtyPrivate[key] = true;
        super._markDirtyKey(key);
    }
    /**
     * Checks if element is of certain class (or inherits one).
     *
     * @param   type  Class name to check
     * @return {boolean} Is of class?
     */
    isType(type) {
        return this.classNames.indexOf(type) !== -1;
    }
    _pushPropertyDisposer(key, disposer) {
        let disposers = this._disposerProperties[key];
        if (disposers === undefined) {
            disposers = this._disposerProperties[key] = [];
        }
        disposers.push(disposer);
        return disposer;
    }
    _disposeProperty(key) {
        const disposers = this._disposerProperties[key];
        if (disposers !== undefined) {
            _Array__WEBPACK_IMPORTED_MODULE_7__["each"](disposers, (disposer) => {
                disposer.dispose();
            });
            delete this._disposerProperties[key];
        }
    }
    /**
     * @todo needs description
     * @param  value  Template
     */
    set template(value) {
        const template = this._template;
        if (template !== value) {
            this._template = value;
            if (template) {
                template._removeObjectTemplate(this);
            }
            if (value) {
                value._setObjectTemplate(this);
            }
            this._applyTemplates();
        }
    }
    get template() {
        return this._template;
    }
    /**
     * @ignore
     */
    markDirty() {
        this._root._addDirtyEntity(this);
    }
    _startAnimation() {
        this._root._addAnimation(this);
    }
    _animationTime() {
        return this._root.animationTime;
    }
    _applyState(_name) { }
    _applyStateAnimated(_name, _duration) { }
    get(key, fallback) {
        const value = this.adapters.fold(key, this._settings[key]);
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    /**
     * @ignore
     */
    isUserSetting(key) {
        return this._userProperties[key] || false;
    }
    /**
     * Sets a setting `value` for the specified `key`, and returns the same `value`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    set(key, value) {
        this._userProperties[key] = true;
        return super.set(key, value);
    }
    /**
     * @ignore
     */
    setRaw(key, value) {
        this._userProperties[key] = true;
        super.setRaw(key, value);
    }
    /**
     * Sets a setting `value` for the specified `key` only if the value for this key was not set previously using set method, and returns the same `value`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    _setSoft(key, value) {
        if (!this._userProperties[key]) {
            return super.set(key, value);
        }
        return value;
    }
    /**
     * Removes a setting value for the specified `key`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     */
    remove(key) {
        delete this._userProperties[key];
        this._removeTemplateProperty(key);
    }
    /**
     * @ignore
     */
    setPrivate(key, value) {
        this._userPrivateProperties[key] = true;
        return super.setPrivate(key, value);
    }
    /**
     * @ignore
     */
    setPrivateRaw(key, value) {
        this._userPrivateProperties[key] = true;
        super.setPrivateRaw(key, value);
    }
    /**
     * @ignore
     */
    removePrivate(key) {
        delete this._userPrivateProperties[key];
        this._removeTemplatePrivateProperty(key);
    }
    _setTemplateProperty(template, key, value) {
        if (!this._userProperties[key]) {
            const match = this._findTemplateByKey(key);
            if (template === match) {
                super.set(key, value);
            }
        }
    }
    _setTemplatePrivateProperty(template, key, value) {
        if (!this._userPrivateProperties[key]) {
            const match = this._findTemplateByPrivateKey(key);
            if (template === match) {
                super.setPrivate(key, value);
            }
        }
    }
    _removeTemplateProperty(key) {
        if (!this._userProperties[key]) {
            const match = this._findTemplateByKey(key);
            if (match) {
                // TODO don't stop the animation if the property didn't change
                super.set(key, match._settings[key]);
            }
            else {
                super.remove(key);
            }
        }
    }
    _removeTemplatePrivateProperty(key) {
        if (!this._userPrivateProperties[key]) {
            const match = this._findTemplateByPrivateKey(key);
            if (match) {
                // TODO don't stop the animation if the property didn't change
                super.setPrivate(key, match._privateSettings[key]);
            }
            else {
                super.removePrivate(key);
            }
        }
    }
    _walkParents(f) {
        f(this._root._rootContainer);
        f(this);
    }
    // TODO faster version of this method which is specialized to just 1 key
    _applyStateByKey(name) {
        const other = this.states.create(name, {});
        const seen = {};
        this._eachTemplate((template) => {
            const state = template.states.lookup(name);
            if (state) {
                state._apply(other, seen);
            }
        });
        _Object__WEBPACK_IMPORTED_MODULE_5__["each"](other._settings, (key) => {
            if (!seen[key] && !other._userSettings[key]) {
                other.remove(key);
            }
        });
    }
    _applyTemplate(template, state) {
        this._templateDisposers.push(template._apply(this, state));
        _Object__WEBPACK_IMPORTED_MODULE_5__["each"](template._settings, (key, value) => {
            if (!state.settings[key] && !this._userProperties[key]) {
                state.settings[key] = true;
                super.set(key, value);
            }
        });
        _Object__WEBPACK_IMPORTED_MODULE_5__["each"](template._privateSettings, (key, value) => {
            if (!state.privateSettings[key] && !this._userPrivateProperties[key]) {
                state.privateSettings[key] = true;
                super.setPrivate(key, value);
            }
        });
        if (this._runSetup && template.setup) {
            this._runSetup = false;
            template.setup(this);
        }
    }
    /**
     * Calls the closure with each template and returns the first template which is true
     */
    _findStaticTemplate(f) {
        if (this._template) {
            if (f(this._template)) {
                return this._template;
            }
        }
    }
    _eachTemplate(f) {
        this._findStaticTemplate((template) => {
            f(template);
            return false;
        });
        // _internalTemplates is sorted with most specific to the right
        _Array__WEBPACK_IMPORTED_MODULE_7__["eachReverse"](this._internalTemplates, f);
        // _templates is sorted with most specific to the left
        _Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._templates, f);
    }
    _applyTemplates(remove = true) {
        if (remove) {
            this._disposeTemplates();
        }
        const state = {
            settings: {},
            privateSettings: {},
            states: {},
        };
        this._eachTemplate((template) => {
            this._applyTemplate(template, state);
        });
        if (remove) {
            _Object__WEBPACK_IMPORTED_MODULE_5__["each"](this._settings, (key) => {
                if (!this._userProperties[key] && !state.settings[key]) {
                    super.remove(key);
                }
            });
            _Object__WEBPACK_IMPORTED_MODULE_5__["each"](this._privateSettings, (key) => {
                if (!this._userPrivateProperties[key] && !state.privateSettings[key]) {
                    super.removePrivate(key);
                }
            });
        }
    }
    _findTemplate(f) {
        const value = this._findStaticTemplate(f);
        if (value === undefined) {
            // _internalTemplates is sorted with most specific to the right
            const value = _Array__WEBPACK_IMPORTED_MODULE_7__["findReverse"](this._internalTemplates, f);
            if (value === undefined) {
                // _templates is sorted with most specific to the left
                return _Array__WEBPACK_IMPORTED_MODULE_7__["find"](this._templates, f);
            }
            else {
                return value;
            }
        }
        else {
            return value;
        }
    }
    _findTemplateByKey(key) {
        return this._findTemplate((template) => {
            return key in template._settings;
        });
    }
    _findTemplateByPrivateKey(key) {
        return this._findTemplate((template) => {
            return key in template._privateSettings;
        });
    }
    _disposeTemplates() {
        _Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._templateDisposers, (disposer) => {
            disposer.dispose();
        });
        this._templateDisposers.length = 0;
    }
    _removeTemplates() {
        _Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._templates, (template) => {
            template._removeObjectTemplate(this);
        });
        this._templates.length = 0;
    }
    _applyThemes() {
        let isConnected = false;
        const defaults = [];
        let themes = [];
        const themeTags = new Set();
        const tags = this.get("themeTagsSelf");
        if (tags) {
            _Array__WEBPACK_IMPORTED_MODULE_7__["each"](tags, (tag) => {
                themeTags.add(tag);
            });
        }
        this._walkParents((entity) => {
            if (entity === this._root._rootContainer) {
                isConnected = true;
            }
            if (entity._defaultThemes.length > 0) {
                defaults.push(entity._defaultThemes);
            }
            const theme = entity.get("themes");
            if (theme) {
                themes.push(theme);
            }
            const tags = entity.get("themeTags");
            if (tags) {
                _Array__WEBPACK_IMPORTED_MODULE_7__["each"](tags, (tag) => {
                    themeTags.add(tag);
                });
            }
        });
        themes = defaults.concat(themes);
        this._removeTemplates();
        if (isConnected) {
            _Array__WEBPACK_IMPORTED_MODULE_7__["eachReverse"](this.classNames, (name) => {
                const allRules = [];
                _Array__WEBPACK_IMPORTED_MODULE_7__["each"](themes, (themes) => {
                    _Array__WEBPACK_IMPORTED_MODULE_7__["each"](themes, (theme) => {
                        const rules = theme._lookupRules(name);
                        if (rules) {
                            _Array__WEBPACK_IMPORTED_MODULE_7__["eachReverse"](rules, (rule) => {
                                const matches = rule.tags.every((tag) => {
                                    return themeTags.has(tag);
                                });
                                if (matches) {
                                    const result = _Array__WEBPACK_IMPORTED_MODULE_7__["getFirstSortedIndex"](allRules, (x) => {
                                        const order = _Order__WEBPACK_IMPORTED_MODULE_8__["compare"](rule.tags.length, x.tags.length);
                                        if (order === 0) {
                                            return _Order__WEBPACK_IMPORTED_MODULE_8__["compareArray"](rule.tags, x.tags, _Order__WEBPACK_IMPORTED_MODULE_8__["compare"]);
                                        }
                                        else {
                                            return order;
                                        }
                                    });
                                    allRules.splice(result.index, 0, rule);
                                }
                            });
                        }
                    });
                });
                _Array__WEBPACK_IMPORTED_MODULE_7__["each"](allRules, (rule) => {
                    this._templates.push(rule.template);
                    rule.template._setObjectTemplate(this);
                });
            });
        }
        this._applyTemplates();
        if (isConnected) {
            // This causes it to only run the setup function the first time that the themes are applied
            this._runSetup = false;
        }
        return isConnected;
    }
    _changed() { }
    _beforeChanged() {
        if (this.isDirty("id")) {
            const id = this.get("id");
            if (id) {
                this._registerId(id);
            }
            const prevId = this._prevSettings.id;
            if (prevId) {
                delete _Registry__WEBPACK_IMPORTED_MODULE_4__["registry"].entitiesById[prevId];
            }
        }
    }
    _registerId(id) {
        if (_Registry__WEBPACK_IMPORTED_MODULE_4__["registry"].entitiesById[id] && _Registry__WEBPACK_IMPORTED_MODULE_4__["registry"].entitiesById[id] !== this) {
            throw new Error("An entity with id \"" + id + "\" already exists.");
        }
        _Registry__WEBPACK_IMPORTED_MODULE_4__["registry"].entitiesById[id] = this;
    }
    _afterChanged() { }
    /**
     * @ignore
     */
    addDisposer(disposer) {
        this._disposers.push(disposer);
        return disposer;
    }
    _dispose() {
        super._dispose();
        const template = this._template;
        if (template) {
            template._removeObjectTemplate(this);
        }
        _Array__WEBPACK_IMPORTED_MODULE_7__["each"](this._internalTemplates, (template) => {
            template._removeObjectTemplate(this);
        });
        this._removeTemplates();
        this._disposeTemplates();
        this.events.dispose();
        this._disposers.forEach((x) => {
            x.dispose();
        });
        _Object__WEBPACK_IMPORTED_MODULE_5__["each"](this._disposerProperties, (_, disposers) => {
            _Array__WEBPACK_IMPORTED_MODULE_7__["each"](disposers, (disposer) => {
                disposer.dispose();
            });
        });
        const id = this.get("id");
        if (id) {
            delete _Registry__WEBPACK_IMPORTED_MODULE_4__["registry"].entitiesById[id];
        }
    }
    /**
     * Creates and returns a "disposable" timeout.
     *
     * @param   fn     Callback
     * @param   delay  Delay in milliseconds
     * @return         Timeout disposer
     */
    setTimeout(fn, delay) {
        const id = setTimeout(() => {
            this.removeDispose(disposer);
            fn();
        }, delay);
        const disposer = new _Disposer__WEBPACK_IMPORTED_MODULE_0__["Disposer"](() => {
            clearTimeout(id);
        });
        this._disposers.push(disposer);
        return disposer;
    }
    /**
     * @ignore
     */
    removeDispose(target) {
        if (!this.isDisposed()) {
            let index = _Array__WEBPACK_IMPORTED_MODULE_7__["indexOf"](this._disposers, target);
            if (index > -1) {
                this._disposers.splice(index, 1);
            }
        }
        target.dispose();
    }
    /**
     * @ignore
     */
    hasTag(tag) {
        return _Array__WEBPACK_IMPORTED_MODULE_7__["indexOf"](this.get("themeTags", []), tag) !== -1;
    }
    /**
     * @ignore
     */
    addTag(tag) {
        if (!this.hasTag(tag)) {
            const tags = this.get("themeTags", []);
            tags.push(tag);
            this.set("themeTags", tags);
        }
    }
    /**
     * @ignore
     */
    removeTag(tag) {
        if (this.hasTag(tag)) {
            const tags = this.get("themeTags", []);
            _Array__WEBPACK_IMPORTED_MODULE_7__["remove"](tags, tag);
            this.set("themeTags", tags);
        }
    }
    _t(text, locale, ...rest) {
        return this._root.language.translate(text, locale, ...rest);
    }
    /**
     * An instance of [[Root]] object.
     *
     * @readonly
     * @since 5.0.6
     * @return Root object
     */
    get root() {
        return this._root;
    }
}
Object.defineProperty(Entity, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Entity"
});
Object.defineProperty(Entity, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: ["Entity"]
});
//# sourceMappingURL=Entity.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js ***!
  \*********************************************************************************/
/*! exports provided: EventDispatcher, TargetedEventDispatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TargetedEventDispatcher", function() { return TargetedEventDispatcher; });
/* harmony import */ var _Disposer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/**
 * Event Dispatcher module is used for registering listeners and dispatching
 * events across amCharts system.
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * Universal Event Dispatcher.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info
 */
class EventDispatcher {
    /**
     * Constructor
     */
    constructor() {
        Object.defineProperty(this, "_listeners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_killed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_disabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_iterating", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_enabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._listeners = [];
        this._killed = [];
        this._disabled = {};
        this._iterating = 0;
        this._enabled = true;
        this._disposed = false;
    }
    /**
     * Returns if this object has been already disposed.
     *
     * @return Disposed?
     */
    isDisposed() {
        return this._disposed;
    }
    /**
     * Dispose (destroy) this object.
     */
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            const a = this._listeners;
            this._iterating = 1;
            this._listeners = null;
            this._disabled = null;
            try {
                _Array__WEBPACK_IMPORTED_MODULE_1__["each"](a, (x) => {
                    x.disposer.dispose();
                });
            }
            finally {
                this._killed = null;
                this._iterating = null;
            }
        }
    }
    /**
     * Checks if this particular event dispatcher has any listeners set.
     *
     * @return Has listeners?
     */
    hasListeners() {
        return this._listeners.length !== 0;
    }
    /**
     * Checks if this particular event dispatcher has any particular listeners set.
     *
     * @return Has particular event listeners?
     */
    hasListenersByType(type) {
        return _Array__WEBPACK_IMPORTED_MODULE_1__["any"](this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);
    }
    /**
     * Enable dispatching of events if they were previously disabled by
     * `disable()`.
     */
    enable() {
        this._enabled = true;
    }
    /**
     * Disable dispatching of events until re-enabled by `enable()`.
     */
    disable() {
        this._enabled = false;
    }
    /**
     * Enable dispatching particular event, if it was disabled before by
     * `disableType()`.
     *
     * @param type Event type
     */
    enableType(type) {
        delete this._disabled[type];
    }
    /**
     * Disable dispatching of events for a certain event type.
     *
     * Optionally, can set how many dispatches to skip before automatically
     * re-enabling the dispatching.
     *
     * @param type    Event type
     * @param amount  Number of event dispatches to skip
     */
    disableType(type, amount = Infinity) {
        this._disabled[type] = amount;
    }
    /**
     * Removes listener from dispatcher.
     *
     * Will throw an exception if such listener does not exists.
     *
     * @param listener Listener to remove
     */
    _removeListener(listener) {
        if (this._iterating === 0) {
            const index = this._listeners.indexOf(listener);
            if (index === -1) {
                throw new Error("Invalid state: could not remove listener");
            }
            this._listeners.splice(index, 1);
        }
        else {
            this._killed.push(listener);
        }
    }
    /**
     * Removes existing listener by certain parameters.
     *
     * @param once         Listener's once setting
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     */
    _removeExistingListener(once, type, callback, context) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        this._eachListener((info) => {
            if (info.once === once && // TODO is this correct ?
                info.type === type &&
                (callback === undefined || info.callback === callback) &&
                info.context === context) {
                info.disposer.dispose();
            }
        });
    }
    /**
     * Checks if dispatching for particular event type is enabled.
     *
     * @param type  Event type
     * @return Enabled?
     */
    isEnabled(type) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        // TODO is this check correct ?
        return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;
    }
    /**
     * Removes all listeners of a particular event type
     *
     * @param type  Listener's type
     */
    removeType(type) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        this._eachListener((info) => {
            if (info.type === type) {
                info.disposer.dispose();
            }
        });
    }
    /**
     * Checks if there's already a listener with specific parameters.
     *
     * @param type      Listener's type
     * @param callback  Callback function
     * @param context   Callback context
     * @return Has listener?
     */
    has(type, callback, context) {
        const index = _Array__WEBPACK_IMPORTED_MODULE_1__["findIndex"](this._listeners, (info) => {
            return info.once !== true && // Ignoring "once" listeners
                info.type === type &&
                (callback === undefined || info.callback === callback) &&
                info.context === context;
        });
        return index !== -1;
    }
    /**
     * Checks whether event of the particular type should be dispatched.
     *
     * @param type  Event type
     * @return Dispatch?
     */
    _shouldDispatch(type) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        const count = this._disabled[type];
        if (!_Type__WEBPACK_IMPORTED_MODULE_2__["isNumber"](count)) {
            return this._enabled;
        }
        else {
            if (count <= 1) {
                delete this._disabled[type];
            }
            else {
                --this._disabled[type];
            }
            return false;
        }
    }
    /**
     * [_eachListener description]
     *
     * All of this extra code is needed when a listener is removed while iterating
     *
     * @todo Description
     * @param fn [description]
     */
    _eachListener(fn) {
        ++this._iterating;
        try {
            _Array__WEBPACK_IMPORTED_MODULE_1__["each"](this._listeners, fn);
        }
        finally {
            --this._iterating;
            // TODO should this be inside or outside the finally ?
            if (this._iterating === 0 && this._killed.length !== 0) {
                // Remove killed listeners
                _Array__WEBPACK_IMPORTED_MODULE_1__["each"](this._killed, (killed) => {
                    this._removeListener(killed);
                });
                this._killed.length = 0;
            }
        }
    }
    /**
     * Dispatches an event immediately without waiting for next cycle.
     *
     * @param type   Event type
     * @param event  Event object
     * @todo automatically add in type and target properties if they are missing
     */
    dispatch(type, event) {
        if (this._shouldDispatch(type)) {
            // TODO check if it's faster to use an object of listeners rather than a single big array
            // TODO if the function throws, maybe it should keep going ?
            this._eachListener((listener) => {
                if (!listener.killed && (listener.type === null || listener.type === type)) {
                    listener.dispatch(type, event);
                }
            });
        }
    }
    /**
     * Shelves the event to be dispatched within next update cycle.
     *
     * @param type   Event type
     * @param event  Event object
     * @todo automatically add in type and target properties if they are missing
     */
    /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {
        if (this._shouldDispatch(type)) {
            this._eachListener((listener) => {
                // TODO check if it's faster to use an object of listeners rather than a single big array
                if (!listener.killed && (listener.type === null || listener.type === type)) {
                    // TODO if the function throws, maybe it should keep going ?
                    // TODO dispatch during the update cycle, rather than using whenIdle
                    $async.whenIdle(() => {
                        if (!listener.killed) {
                            listener.dispatch(type, event);
                        }
                    });
                }
            });
        }
    }*/
    /**
     * Creates, catalogs and returns an [[EventListener]].
     *
     * Event listener can be disposed.
     *
     * @param once         Listener's once setting
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @param dispatch
     * @returns An event listener
     */
    _on(once, type, callback, context, shouldClone, dispatch) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        this._removeExistingListener(once, type, callback, context);
        const info = {
            type: type,
            callback: callback,
            context: context,
            shouldClone: shouldClone,
            dispatch: dispatch,
            killed: false,
            once: once,
            disposer: new _Disposer__WEBPACK_IMPORTED_MODULE_0__["Disposer"](() => {
                info.killed = true;
                this._removeListener(info);
            })
        };
        this._listeners.push(info);
        return info;
    }
    /**
     * Creates an event listener to be invoked on **any** event.
     *
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     */
    onAll(callback, context, shouldClone = true) {
        return this._on(false, null, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;
    }
    /**
     * Creates an event listener to be invoked on a specific event type.
     *
     * ```TypeScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     * ```JavaScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     *
     * The above will invoke our custom event handler whenever series we put
     * event on is hidden.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     */
    on(type, callback, context, shouldClone = true) {
        return this._on(false, type, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;
    }
    /**
     * Creates an event listener to be invoked on a specific event type once.
     *
     * Once the event listener is invoked, it is automatically disposed.
     *
     * ```TypeScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     * ```JavaScript
     * button.events.once("click", (ev) => {
     *   console.log("Button clicked");
     * }, this);
     * ```
     *
     * The above will invoke our custom event handler the first time series we
     * put event on is hidden.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     */
    once(type, callback, context, shouldClone = true) {
        const x = this._on(true, type, callback, context, shouldClone, (_type, event) => {
            x.disposer.dispose();
            callback.call(context, event);
        });
        // TODO maybe this should return a different Disposer ?
        return x.disposer;
    }
    /**
     * Removes the event listener with specific parameters.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     */
    off(type, callback, context) {
        this._removeExistingListener(false, type, callback, context);
    }
    /**
     * Copies all dispatcher parameters, including listeners, from another event
     * dispatcher.
     *
     * @param source Source event dispatcher
     * @ignore
     */
    copyFrom(source) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        if (source === this) {
            throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
        }
        const disposers = [];
        _Array__WEBPACK_IMPORTED_MODULE_1__["each"](source._listeners, (x) => {
            // TODO is this correct ?
            if (!x.killed && x.shouldClone) {
                if (x.type === null) {
                    disposers.push(this.onAll(x.callback, x.context));
                }
                else if (x.once) {
                    disposers.push(this.once(x.type, x.callback, x.context));
                }
                else {
                    disposers.push(this.on(x.type, x.callback, x.context));
                }
            }
        });
        return new _Disposer__WEBPACK_IMPORTED_MODULE_0__["MultiDisposer"](disposers);
    }
}
/**
 * A version of the [[EventDispatcher]] that dispatches events for a specific
 * target object.
 *
 * @ignore
 */
class TargetedEventDispatcher extends EventDispatcher {
    /**
     * Constructor
     *
     * @param target Event dispatcher target
     */
    constructor(target) {
        super();
        /**
         * A target object which is originating events using this dispatcher.
         */
        Object.defineProperty(this, "target", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.target = target;
    }
    /**
     * Copies all dispatcher parameters, including listeners, from another event
     * dispatcher.
     *
     * @param source Source event dispatcher
     * @ignore
     */
    copyFrom(source) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        if (source === this) {
            throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
        }
        const disposers = [];
        _Array__WEBPACK_IMPORTED_MODULE_1__["each"](source._listeners, (x) => {
            // TODO very hacky
            if (x.context === source.target) {
                return;
            }
            // TODO is this correct ?
            if (!x.killed && x.shouldClone) {
                if (x.type === null) {
                    disposers.push(this.onAll(x.callback, x.context));
                }
                else if (x.once) {
                    disposers.push(this.once(x.type, x.callback, x.context));
                }
                else {
                    disposers.push(this.on(x.type, x.callback, x.context));
                }
            }
        });
        return new _Disposer__WEBPACK_IMPORTED_MODULE_0__["MultiDisposer"](disposers);
    }
}
//# sourceMappingURL=EventDispatcher.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js ***!
  \*********************************************************************************/
/*! exports provided: InterfaceColors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterfaceColors", function() { return InterfaceColors; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");

/**
 * Presets for common UI elements.
 */
class InterfaceColors extends _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
}
Object.defineProperty(InterfaceColors, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "InterfaceColors"
});
Object.defineProperty(InterfaceColors, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"].classNames.concat([InterfaceColors.className])
});
//# sourceMappingURL=InterfaceColors.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Language.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Language.js ***!
  \**************************************************************************/
/*! exports provided: Language */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Language", function() { return Language; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _locales_en__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../locales/en */ "./node_modules/@amcharts/amcharts5/locales/en.js");




;
/**
 * Add localization functionality.
 */
class Language extends _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    _setDefaults() {
        this.setPrivate("defaultLocale", _locales_en__WEBPACK_IMPORTED_MODULE_3__["default"]);
        super._setDefaults();
    }
    /**
     * Returns a prompt translation.
     *
     * @param   prompt   Prompt to translate
     * @param   locale   Target locale
     * @param   ...rest  Parameters
     * @return           Translation
     */
    translate(prompt, locale, ...rest) {
        // Get langauge
        if (!locale) {
            locale = this._root.locale || this.getPrivate("defaultLocale");
        }
        // Init translation
        let translation = prompt;
        let value = locale[prompt];
        // Try to look for the translation
        if (value === null) {
            translation = "";
        }
        else if (value != null) {
            // It might be an empty string
            if (value) {
                translation = value;
            }
        }
        else if (locale !== this.getPrivate("defaultLocale")) {
            // Try to look in default language
            return this.translate(prompt, this.getPrivate("defaultLocale"), ...rest);
        }
        // Replace %1, %2, etc params
        if (rest.length) {
            for (let len = rest.length, i = 0; i < len; ++i) {
                translation = translation.split("%" + (i + 1)).join(rest[i]);
            }
        }
        // Return the translation
        return translation;
    }
    /**
     * Returns a prompt translation, including custom prompts.
     *
     * @param   prompt   Prompt to translate
     * @param   locale   Target locale
     * @param   ...rest  Parameters
     * @return           Translation
     */
    translateAny(prompt, locale, ...rest) {
        return this.translate(prompt, locale, ...rest);
    }
    /**
     * Add a custom prompt to locale.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
     * @param  prompt       Source prompt
     * @param  translation  Tanslation
     * @param  locale       Target locale
     */
    setTranslationAny(prompt, translation, locale) {
        const localeTarget = locale || this._root.locale;
        localeTarget[prompt] = translation;
    }
    /**
     * Add a batch of custom prompts.
     *
     * @since 5.3.3
     * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
     * @param  translations  Translations
     * @param  locale        Target locale
     */
    setTranslationsAny(translations, locale) {
        _Object__WEBPACK_IMPORTED_MODULE_2__["each"](translations, (key, val) => {
            this.setTranslationAny(key, val, locale);
        });
    }
    translateEmpty(prompt, locale, ...rest) {
        let translation = this.translate(prompt, locale, ...rest);
        return translation == prompt ? "" : translation;
    }
    translateFunc(prompt, locale) {
        if (this._root.locale[prompt]) {
            return this._root.locale[prompt];
        }
        // Try to look in default language
        if (locale !== this.getPrivate("defaultLocale")) {
            return this.translateFunc(prompt, this.getPrivate("defaultLocale"));
        }
        // Fail - return empty function
        return () => {
            return "";
        };
    }
    /**
     * Translates a btach of prompts.
     *
     * @param  list    Array of prompts to translate
     * @param  locale  Target locale
     * @return         Array of translations
     */
    translateAll(list, locale) {
        // Translate all items in the list
        if (!this.isDefault()) {
            return _Array__WEBPACK_IMPORTED_MODULE_1__["map"](list, (x) => this.translate(x, locale));
        }
        else {
            return list;
        }
    }
    /**
     * Returns `true` if the currently selected locale is a default locale.
     *
     * @return `true` if locale is default; `false` if it is not.
     */
    isDefault() {
        return this.getPrivate("defaultLocale") === this._root.locale;
    }
}
//# sourceMappingURL=Language.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/List.js ***!
  \**********************************************************************/
/*! exports provided: List, ListAutoDispose, ListTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "List", function() { return List; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListAutoDispose", function() { return ListAutoDispose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ListTemplate", function() { return ListTemplate; });
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");


/**
 * Checks if specific index fits into length.
 *
 * @param index  Index
 * @param len    Length
 * @ignore
 */
function checkBounds(index, len) {
    if (!(index >= 0 && index < len)) {
        throw new Error("Index out of bounds: " + index);
    }
}
/**
 * A List class is used to hold a number of indexed items of the same type.
 */
class List {
    /**
     * Constructor
     *
     * @param initial  Inital list of values to add to list
     */
    constructor(initial = []) {
        /**
         * List values.
         */
        Object.defineProperty(this, "_values", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"]()
        });
        this._values = initial;
    }
    /**
     * An array of values in the list.
     *
     * Do not use this property to add values. Rather use dedicated methods, like
     * `push()`, `removeIndex()`, etc.
     *
     * @readonly
     * @return List values
     */
    get values() {
        return this._values;
    }
    /**
     * Checks if list contains specific item reference.
     *
     * @param item  Item to search for
     * @return `true` if found, `false` if not found
     */
    contains(value) {
        return this._values.indexOf(value) !== -1;
    }
    /**
     * Removes specific item from the list.
     *
     * @param item An item to remove
     */
    removeValue(value) {
        let i = 0;
        let length = this._values.length;
        while (i < length) {
            // TODO handle NaN
            if (this._values[i] === value) {
                this.removeIndex(i);
                --length;
            }
            else {
                ++i;
            }
        }
    }
    /**
     * Searches the list for specific item and returns its index.
     *
     * @param item  An item to search for
     * @return Index or -1 if not found
     */
    indexOf(value) {
        return _Array__WEBPACK_IMPORTED_MODULE_1__["indexOf"](this._values, value);
    }
    /**
     * Number of items in list.
     *
     * @readonly
     * @return Number of items
     */
    get length() {
        return this._values.length;
    }
    /**
     * Checks if there's a value at specific index.
     *
     * @param index  Index
     * @return Value exists?
     */
    hasIndex(index) {
        return index >= 0 && index < this._values.length;
    }
    /**
     * Returns an item at specified index.
     *
     * @param index  Index
     * @return List item
     */
    getIndex(index) {
        return this._values[index];
    }
    _onPush(newValue) {
        if (this.events.isEnabled("push")) {
            this.events.dispatch("push", {
                type: "push",
                target: this,
                newValue
            });
        }
    }
    _onInsertIndex(index, newValue) {
        if (this.events.isEnabled("insertIndex")) {
            this.events.dispatch("insertIndex", {
                type: "insertIndex",
                target: this,
                index,
                newValue
            });
        }
    }
    _onSetIndex(index, oldValue, newValue) {
        if (this.events.isEnabled("setIndex")) {
            this.events.dispatch("setIndex", {
                type: "setIndex",
                target: this,
                index,
                oldValue,
                newValue
            });
        }
    }
    _onRemoveIndex(index, oldValue) {
        if (this.events.isEnabled("removeIndex")) {
            this.events.dispatch("removeIndex", {
                type: "removeIndex",
                target: this,
                index,
                oldValue
            });
        }
    }
    _onMoveIndex(oldIndex, newIndex, value) {
        if (this.events.isEnabled("moveIndex")) {
            this.events.dispatch("moveIndex", {
                type: "moveIndex",
                target: this,
                oldIndex,
                newIndex,
                value,
            });
        }
    }
    _onClear(oldValues) {
        if (this.events.isEnabled("clear")) {
            this.events.dispatch("clear", {
                type: "clear",
                target: this,
                oldValues
            });
        }
    }
    /**
     * Sets value at specific index.
     *
     * If there's already a value at the index, it is overwritten.
     *
     * @param index  Index
     * @param value  New value
     * @return New value
     */
    setIndex(index, value) {
        checkBounds(index, this._values.length);
        const oldValue = this._values[index];
        // Do nothing if the old value and the new value are the same
        if (oldValue !== value) {
            this._values[index] = value;
            this._onSetIndex(index, oldValue, value);
        }
        return oldValue;
    }
    /**
     * Adds an item to the list at a specific index, which pushes all the other
     * items further down the list.
     *
     * @param index Index
     * @param item  An item to add
     */
    insertIndex(index, value) {
        checkBounds(index, this._values.length + 1);
        _Array__WEBPACK_IMPORTED_MODULE_1__["insertIndex"](this._values, index, value);
        this._onInsertIndex(index, value);
        return value;
    }
    /**
     * Swaps indexes of two items in the list.
     *
     * @param a  Item 1
     * @param b  Item 2
     */
    swap(a, b) {
        const len = this._values.length;
        checkBounds(a, len);
        checkBounds(b, len);
        if (a !== b) {
            const value_a = this._values[a];
            const value_b = this._values[b];
            this._values[a] = value_b;
            this._onSetIndex(a, value_a, value_b);
            this._values[b] = value_a;
            this._onSetIndex(b, value_b, value_a);
        }
    }
    /**
     * Removes a value at specific index.
     *
     * @param index  Index of value to remove
     * @return Removed value
     */
    removeIndex(index) {
        checkBounds(index, this._values.length);
        const oldValue = this._values[index];
        _Array__WEBPACK_IMPORTED_MODULE_1__["removeIndex"](this._values, index);
        this._onRemoveIndex(index, oldValue);
        return oldValue;
    }
    /**
     * Moves an item to a specific index within the list.
     *
     * If the index is not specified it will move the item to the end of the
     * list.
     *
     * @param value  Item to move
     * @param index  Index to place item at
     */
    moveValue(value, toIndex) {
        // TODO don't do anything if the desired index is the same as the current index
        let index = this.indexOf(value);
        // TODO remove all old values rather than only the first ?
        if (index !== -1) {
            _Array__WEBPACK_IMPORTED_MODULE_1__["removeIndex"](this._values, index);
            if (toIndex == null) {
                const toIndex = this._values.length;
                this._values.push(value);
                this._onMoveIndex(index, toIndex, value);
            }
            else {
                _Array__WEBPACK_IMPORTED_MODULE_1__["insertIndex"](this._values, toIndex, value);
                this._onMoveIndex(index, toIndex, value);
            }
        }
        else if (toIndex == null) {
            this._values.push(value);
            this._onPush(value);
        }
        else {
            _Array__WEBPACK_IMPORTED_MODULE_1__["insertIndex"](this._values, toIndex, value);
            this._onInsertIndex(toIndex, value);
        }
        return value;
    }
    /**
     * Adds an item to the end of the list.
     *
     * @param item  An item to add
     */
    push(value) {
        this._values.push(value);
        this._onPush(value);
        return value;
    }
    /**
     * Adds an item as a first item in the list.
     *
     * @param item  An item to add
     */
    unshift(value) {
        this.insertIndex(0, value);
        return value;
    }
    /**
     * Adds multiple items to the list.
     *
     * @param items  An Array of items to add
     */
    pushAll(values) {
        _Array__WEBPACK_IMPORTED_MODULE_1__["each"](values, (value) => {
            this.push(value);
        });
    }
    /**
     * Copies and adds items from abother list.
     *
     * @param source  A list top copy items from
     */
    copyFrom(source) {
        this.pushAll(source._values);
    }
    /**
     * Returns the last item from the list, and removes it.
     *
     * @return Item
     */
    pop() {
        let index = this._values.length - 1;
        return index < 0 ? undefined : this.removeIndex(this._values.length - 1);
    }
    /**
     * Returns the first item from the list, and removes it.
     *
     * @return Item
     */
    shift() {
        return this._values.length ? this.removeIndex(0) : undefined;
    }
    /**
     * Sets multiple items to the list.
     *
     * All current items are removed.
     *
     * @param newArray  New items
     */
    setAll(newArray) {
        const old = this._values;
        this._values = [];
        this._onClear(old);
        _Array__WEBPACK_IMPORTED_MODULE_1__["each"](newArray, (value) => {
            this._values.push(value);
            this._onPush(value);
        });
    }
    /**
     * Removes all items from the list.
     */
    clear() {
        this.setAll([]);
    }
    /**
     * Returns an ES6 iterator for the list.
     */
    *[Symbol.iterator]() {
        const length = this._values.length;
        for (let i = 0; i < length; ++i) {
            yield this._values[i];
        }
    }
    /**
     * Calls `f` for each element in the list.
     *
     * `f` should have at least one parameter defined which will get a current
     * item, with optional second argument - index.
     */
    each(f) {
        _Array__WEBPACK_IMPORTED_MODULE_1__["each"](this._values, f);
    }
    /**
     * Calls `f` for each element in the list, from right to left.
     *
     * `f` should have at least one parameter defined which will get a current
     * item, with optional second argument - index.
     */
    eachReverse(f) {
        _Array__WEBPACK_IMPORTED_MODULE_1__["eachReverse"](this._values, f);
    }
}
/**
 * A version of a [[List]] where the elements are disposed automatically when
 * removed from the list, unless `autoDispose` is set to `false`.
 */
class ListAutoDispose extends List {
    constructor() {
        super(...arguments);
        /**
         * Automatically disposes elements that are removed from the list.
         *
         * @default true
         */
        Object.defineProperty(this, "autoDispose", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    _onSetIndex(index, oldValue, newValue) {
        if (this.autoDispose) {
            oldValue.dispose();
        }
        super._onSetIndex(index, oldValue, newValue);
    }
    _onRemoveIndex(index, oldValue) {
        if (this.autoDispose) {
            oldValue.dispose();
        }
        super._onRemoveIndex(index, oldValue);
    }
    _onClear(oldValues) {
        if (this.autoDispose) {
            _Array__WEBPACK_IMPORTED_MODULE_1__["each"](oldValues, (x) => {
                x.dispose();
            });
        }
        super._onClear(oldValues);
    }
    isDisposed() {
        return this._disposed;
    }
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            if (this.autoDispose) {
                _Array__WEBPACK_IMPORTED_MODULE_1__["each"](this._values, (x) => {
                    x.dispose();
                });
            }
        }
    }
}
/**
 * A version of a [[List]] that is able to create new elements as well as
 * apply additional settings to newly created items.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/list-templates/} for more info
 */
class ListTemplate extends ListAutoDispose {
    constructor(template, make) {
        super();
        Object.defineProperty(this, "template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "make", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.template = template;
        this.make = make;
    }
}
//# sourceMappingURL=List.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js ***!
  \**********************************************************************/
/*! exports provided: PI, HALFPI, RADIANS, DEGREES, round, ceil, getCubicControlPointA, getCubicControlPointB, fitToRange, sin, tan, cos, normalizeAngle, getArcBounds, getArcPoint, mergeBounds, fitAngleToRange, inBounds, getAngle, getPointOnQuadraticCurve, getPointOnLine, closest, boundsOverlap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PI", function() { return PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HALFPI", function() { return HALFPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIANS", function() { return RADIANS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEGREES", function() { return DEGREES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCubicControlPointA", function() { return getCubicControlPointA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCubicControlPointB", function() { return getCubicControlPointB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitToRange", function() { return fitToRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeAngle", function() { return normalizeAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArcBounds", function() { return getArcBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArcPoint", function() { return getArcPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeBounds", function() { return mergeBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitAngleToRange", function() { return fitAngleToRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inBounds", function() { return inBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngle", function() { return getAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointOnQuadraticCurve", function() { return getPointOnQuadraticCurve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointOnLine", function() { return getPointOnLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closest", function() { return closest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundsOverlap", function() { return boundsOverlap; });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");

/**
 * ============================================================================
 * CONSTANTS
 * ============================================================================
 * @hidden
 */
const PI = Math.PI;
const HALFPI = PI / 2;
const RADIANS = PI / 180;
const DEGREES = 180 / PI;
/**
 * Rounds the numeric value to whole number or specific precision of set.
 *
 * @param value      Value
 * @param precision  Precision (number of decimal points)
 * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.
 * @return Rounded value
 */
function round(value, precision, floor) {
    if (!Object(_Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(precision) || precision <= 0) {
        let rounded = Math.round(value);
        if (floor) {
            if (rounded - value == 0.5) {
                rounded--;
            }
        }
        return rounded;
    }
    else {
        let d = Math.pow(10, precision);
        return Math.round(value * d) / d;
    }
}
/**
 * Ceils the numeric value to whole number or specific precision of set.
 *
 * @param value      Value
 * @param precision  Precision (number of decimal points)
 * @return Rounded value
 */
function ceil(value, precision) {
    if (!Object(_Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(precision) || precision <= 0) {
        return Math.ceil(value);
    }
    else {
        let d = Math.pow(10, precision);
        return Math.ceil(value * d) / d;
    }
}
/**
 * [getCubicControlPointA description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param p0        [description]
 * @param p1        [description]
 * @param p2        [description]
 * @param p3        [description]
 * @param tensionX  [description]
 * @param tensionY  [description]
 * @return [description]
 */
function getCubicControlPointA(p0, p1, p2, tensionX, tensionY) {
    return { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };
}
/**
 * [getCubicControlPointB description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param p0        [description]
 * @param p1        [description]
 * @param p2        [description]
 * @param p3        [description]
 * @param tensionX  [description]
 * @param tensionY  [description]
 * @return [description]
 */
function getCubicControlPointB(p1, p2, p3, tensionX, tensionY) {
    return { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };
}
function fitToRange(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
/**
 * Returns sine of an angle specified in degrees.
 *
 * @param value  Value
 * @return Sine
 */
function sin(angle) {
    return Math.sin(RADIANS * angle);
}
/**
 * Returns tan of an angle specified in degrees.
 *
 * @param value  Value
 * @return Sine
 */
function tan(angle) {
    return Math.tan(RADIANS * angle);
}
/**
 * Returns cosine of an angle specified in degrees.
 *
 * @param value  Value
 * @return Cosine
 */
function cos(angle) {
    return Math.cos(RADIANS * angle);
}
// 0 to 360
function normalizeAngle(value) {
    value = value % 360;
    if (value < 0) {
        value += 360;
    }
    return value;
}
// TODO this doesn't work properly for skewing, and it's probably broken for rotation too
function getArcBounds(cx, cy, startAngle, endAngle, radius) {
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxX = -Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    let bpoints = [];
    bpoints.push(getArcPoint(radius, startAngle));
    bpoints.push(getArcPoint(radius, endAngle));
    let fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);
    let toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);
    for (let angle = fromAngle; angle <= toAngle; angle += 90) {
        if (angle >= startAngle && angle <= endAngle) {
            bpoints.push(getArcPoint(radius, angle));
        }
    }
    for (let i = 0; i < bpoints.length; i++) {
        let pt = bpoints[i];
        if (pt.x < minX) {
            minX = pt.x;
        }
        if (pt.y < minY) {
            minY = pt.y;
        }
        if (pt.x > maxX) {
            maxX = pt.x;
        }
        if (pt.y > maxY) {
            maxY = pt.y;
        }
    }
    return ({ left: cx + minX, top: cy + minY, right: cx + maxX, bottom: cy + maxY });
}
/**
 * Returns point on arc
 *
 * @param center point
 * @param radius
 * @param arc
 * @return {boolean}
 */
function getArcPoint(radius, arc) {
    return ({ x: radius * cos(arc), y: radius * sin(arc) });
}
function mergeBounds(bounds) {
    const len = bounds.length;
    if (len > 0) {
        let bound = bounds[0];
        let left = bound.left;
        let top = bound.top;
        let right = bound.right;
        let bottom = bound.bottom;
        if (len > 1) {
            for (let i = 1; i < len; i++) {
                bound = bounds[i];
                left = Math.min(bound.left, left);
                right = Math.max(bound.right, right);
                top = Math.min(bound.top, top);
                bottom = Math.max(bound.bottom, bottom);
            }
        }
        return { left, right, top, bottom };
    }
    return { left: 0, right: 0, top: 0, bottom: 0 };
}
function fitAngleToRange(value, startAngle, endAngle) {
    if (startAngle > endAngle) {
        let temp = startAngle;
        startAngle = endAngle;
        endAngle = temp;
    }
    value = normalizeAngle(value);
    let count = (startAngle - normalizeAngle(startAngle)) / 360;
    if (value < startAngle) {
        value += 360 * (count + 1);
    }
    let maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;
    let maxStart = startAngle + (endAngle - startAngle) / 2 - 180;
    if (value > endAngle) {
        if (value - 360 > startAngle) {
            value -= 360;
        }
        else {
            if (value < maxEnd) {
                value = endAngle;
            }
            else {
                value = startAngle;
            }
        }
    }
    if (value < startAngle) {
        if (value > maxStart) {
            value = startAngle;
        }
        else {
            value = endAngle;
        }
    }
    return value;
}
function inBounds(point, bounds) {
    if (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {
        return true;
    }
    return false;
}
function getAngle(point1, point2) {
    if (!point2) {
        point2 = { x: point1.x * 2, y: point1.y * 2 };
    }
    let diffX = point2.x - point1.x;
    let diffY = point2.y - point1.y;
    let angle = Math.atan2(diffY, diffX) * DEGREES;
    if (angle < 0) {
        angle += 360;
    }
    return normalizeAngle(angle);
}
/**
 * [getPointOnQuadraticCurve description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param pointA        [description]
 * @param pointB        [description]
 * @param controlPoint  [description]
 * @param position      [description]
 * @return [description]
 */
function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {
    let x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;
    let y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;
    return { x: x, y: y };
}
function getPointOnLine(pointA, pointB, position) {
    return { x: pointA.x + (pointB.x - pointA.x) * position, y: pointA.y + (pointB.y - pointA.y) * position };
}
/**
 * Returns the closest value from the array of values to the reference value.
 *
 * @param values  Array of values
 * @param value   Reference value
 * @return Closes value from the array
 */
function closest(values, referenceValue) {
    return values.reduce(function (prev, curr) {
        return (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);
    });
}
function boundsOverlap(bounds1, bounds2) {
    return !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);
}
//# sourceMappingURL=Math.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Matrix.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Matrix.js ***!
  \************************************************************************/
/*! exports provided: Matrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix", function() { return Matrix; });
/**
 * Modified from Pixi:
 *
 * The MIT License
 *
 * Copyright (c) 2013-2017 Mathew Groves, Chad Engler
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @ignore
 */
class Matrix {
    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
        Object.defineProperty(this, "a", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "b", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "c", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "d", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    }
    /**
     * Sets the matrix based on all the available properties
     */
    setTransform(x, y, pivotX, pivotY, rotation, scale = 1) {
        this.a = Math.cos(rotation) * scale;
        this.b = Math.sin(rotation) * scale;
        this.c = -Math.sin(rotation) * scale;
        this.d = Math.cos(rotation) * scale;
        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));
        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));
    }
    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     */
    apply(origin) {
        return {
            x: (this.a * origin.x) + (this.c * origin.y) + this.tx,
            y: (this.b * origin.x) + (this.d * origin.y) + this.ty
        };
    }
    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     */
    applyInverse(origin) {
        const id = 1 / ((this.a * this.d) + (this.c * -this.b));
        return {
            x: (this.d * id * origin.x) + (-this.c * id * origin.y) + (((this.ty * this.c) - (this.tx * this.d)) * id),
            y: (this.a * id * origin.y) + (-this.b * id * origin.x) + (((-this.ty * this.a) + (this.tx * this.b)) * id)
        };
    }
    /**
     * Appends the given Matrix to this Matrix.
     */
    append(matrix) {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        this.a = (matrix.a * a1) + (matrix.b * c1);
        this.b = (matrix.a * b1) + (matrix.b * d1);
        this.c = (matrix.c * a1) + (matrix.d * c1);
        this.d = (matrix.c * b1) + (matrix.d * d1);
        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;
        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;
    }
    /**
     * Prepends the given Matrix to this Matrix.
     */
    prepend(matrix) {
        const tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            const a1 = this.a;
            const c1 = this.c;
            this.a = (a1 * matrix.a) + (this.b * matrix.c);
            this.b = (a1 * matrix.b) + (this.b * matrix.d);
            this.c = (c1 * matrix.a) + (this.d * matrix.c);
            this.d = (c1 * matrix.b) + (this.d * matrix.d);
        }
        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;
        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;
    }
    /**
     * Copies the other matrix's properties into this matrix
     */
    copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
    }
}
//# sourceMappingURL=Matrix.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Modal.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Modal.js ***!
  \***********************************************************************/
/*! exports provided: Modal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Modal", function() { return Modal; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _core_util_Disposer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../core/util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");




/**
 * @ignore
 */
let rules;
/**
 * @ignore
 */
function modalCSS(element, root, _prefix) {
    const ic = root.interfaceColors;
    const active = ic.get("secondaryButton").toCSS();
    const text = ic.get("text").toCSS();
    const shadow = ic.get("alternativeBackground").toCSS(0.45);
    //const altbg = ic.get("alternativeBackground")!.toCSS();
    if (!rules) {
        const disposer = new _core_util_Disposer__WEBPACK_IMPORTED_MODULE_2__["MultiDisposer"]([
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal", {
                "width": "100%",
                "height": "100%",
                "position": "absolute",
                "z-index": "100000",
                "top": "0",
                "left": "0"
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-curtain", {
                "top": "0",
                "left": "0",
                "width": "100%",
                "height": "100%",
                "position": "absolute",
                "background": ic.get("background").toCSS(0.5),
                "z-index": "100"
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-wrapper", {
                "top": "0",
                "left": "0",
                "width": "100%",
                "height": "100%",
                "position": "absolute",
                "text-align": "center",
                "white-space": "nowrap",
                "background": ic.get("background").toCSS(0.5),
                "z-index": "101"
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-wrapper:before", {
                "content": "''",
                "display": "inline-block",
                "height": "100%",
                "vertical-align": "middle",
                "margin-right": "-0.25em"
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-content", {
                "display": "inline-block",
                "padding": "1.2em",
                "vertical-align": "middle",
                "text-align": "left",
                "white-space": "normal",
                "background": ic.get("background").toCSS(),
                //"border": "1px solid " + ic.get("alternativeBackground")!.toCSS(),
                "border-radius": "4px",
                "-webkit-box-shadow": "0px 0px 36px 0px " + shadow,
                "box-shadow": "0px 0px 36px 0px " + shadow,
                "color": text
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-content h1", {
                "font-size": "1em",
                "margin": "0 0 0.5em 0"
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-table", {
                "display": "table",
                "margin": "1em 0"
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-table-row", {
                "display": "table-row"
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-table-heading", {
                "display": "table-heading",
                "padding": "3px 10px 3px 0",
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-table-cell", {
                "display": "table-cell",
                "padding": "3px 0 3px 0",
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-table-cell > *", {
                "vertical-align": "middle"
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-content input[type=text], .am5-modal-content input[type=number], .am5-modal-content select", {
                "border": "1px solid " + active,
                "border-radius": "4px",
                "padding": "3px 5px",
                "margin": "2px"
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-input-narrow", {
                "width": "50px"
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-button", {
                "font-weight": "400",
                "color": ic.get("secondaryButtonText").toCSS(),
                "line-height": "1.5",
                "text-align": "center",
                "text-decoration": "none",
                "vertical-align": "middle",
                "cursor": "pointer",
                "padding": "0.2em 0.8em",
                "font-size": "1em",
                "border-radius": "0.25em",
                "margin": "0 0.25em 0 0",
                "border": "1px solid " + ic.get("secondaryButtonStroke").toCSS(),
                "background": ic.get("secondaryButton").toCSS()
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-button:hover", {
                "background": ic.get("secondaryButtonHover").toCSS()
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-button.am5-modal-primary", {
                "color": ic.get("primaryButtonText").toCSS(),
                "border": "1px solid " + ic.get("primaryButtonStroke").toCSS(),
                "background": ic.get("primaryButton").toCSS()
            }),
            new _Utils__WEBPACK_IMPORTED_MODULE_1__["StyleRule"](element, ".am5-modal-button.am5-modal-primary:hover", {
                "background": ic.get("primaryButtonHover").toCSS()
            }),
        ]);
        rules = new _core_util_Disposer__WEBPACK_IMPORTED_MODULE_2__["CounterDisposer"](() => {
            rules = undefined;
            disposer.dispose();
        });
    }
    return rules.increment();
}
/**
 * Used to display a modal dialog with HTML content.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/modal-popups/} for more info
 */
class Modal extends _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    //protected _currentPass: number = 0;
    _afterNew() {
        // Applying themes because this will not have parents
        super._afterNewApplyThemes();
        // Defaults
        this._setRawDefault("deactivateRoot", true);
        // Load CSS
        modalCSS(_Utils__WEBPACK_IMPORTED_MODULE_1__["getShadowRoot"](this._root.dom), this._root);
        // Create elements
        const container = document.createElement("div");
        container.className = "am5-modal";
        container.style.display = "none";
        this.root._inner.appendChild(container);
        this.setPrivate("container", container);
        const curtain = document.createElement("div");
        curtain.className = "am5-modal-curtain";
        container.appendChild(curtain);
        this.setPrivate("curtain", curtain);
        _Utils__WEBPACK_IMPORTED_MODULE_1__["addEventListener"](curtain, "click", () => {
            this.cancel();
        });
        const wrapper = document.createElement("div");
        wrapper.className = "am5-modal-wrapper";
        container.appendChild(wrapper);
        this.setPrivate("wrapper", wrapper);
        const content = document.createElement("div");
        content.className = "am5-modal-content";
        wrapper.appendChild(content);
        this.setPrivate("content", content);
        const html = this.get("content");
        if (html) {
            content.innerHTML = html;
        }
        // Close on ESC
        if (_Utils__WEBPACK_IMPORTED_MODULE_1__["supports"]("keyboardevents")) {
            this._disposers.push(_Utils__WEBPACK_IMPORTED_MODULE_1__["addEventListener"](document, "keydown", (ev) => {
                if (this.isOpen() && ev.keyCode == 27) {
                    this.cancel();
                }
            }));
        }
    }
    _beforeChanged() {
        super._beforeChanged();
        if (this.isDirty("content")) {
            this.getPrivate("content").innerHTML = this.get("content", "");
        }
    }
    /**
     * Returns `true` if modal is currently open.
     *
     * @return  Modal open?
     */
    isOpen() {
        return this.getPrivate("container").style.display != "none";
    }
    /**
     * Opens modal.
     */
    open() {
        this.getPrivate("container").style.display = "block";
        if (this.get("deactivateRoot")) {
            this.setTimeout(() => {
                this._root._renderer.interactionsEnabled = false;
            }, 10);
        }
        this.events.dispatch("opened", {
            type: "opened",
            target: this
        });
    }
    /**
     * Closes modal.
     */
    close() {
        this.getPrivate("container").style.display = "none";
        if (this.get("deactivateRoot")) {
            this._root._renderer.interactionsEnabled = true;
        }
        this.events.dispatch("closed", {
            type: "closed",
            target: this
        });
    }
    /**
     * Closes modal and invokes `cancelled` event.
     */
    cancel() {
        this.getPrivate("container").style.display = "none";
        if (this.get("deactivateRoot")) {
            this._root._renderer.interactionsEnabled = true;
        }
        this.events.dispatch("cancelled", {
            type: "cancelled",
            target: this
        });
    }
    /**
     * Disposes modal.
     */
    dispose() {
        super.dispose();
        this.root.dom.removeChild(this.getPrivate("container"));
    }
}
Object.defineProperty(Modal, "className", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "Modal"
});
Object.defineProperty(Modal, "classNames", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"].classNames.concat([Modal.className])
});
//# sourceMappingURL=Modal.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Net.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Net.js ***!
  \*********************************************************************/
/*! exports provided: load, readBlob */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "load", function() { return load; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readBlob", function() { return readBlob; });
/**
 * A collection of network-related functions
 */
/**
 * Loads an external file via its URL.
 *
 * Please note that this is an asynchronous function.
 *
 * It will not return the result, but rather a `Promise`.
 *
 * You can use the `await` notion, or `then()`.
 *
 * ```TypeScript
 * // Using await
 * let response = await Net.load( "http://www.my.com/data.json" );
 * console.log( response.response );
 *
 * // Using then()
 * Net.load( "http://www.my.com/data.json" ).then( ( response ) => {
 *   console.log( response.response );
 * } );
 * ```
 * ```JavaScript
 * // Using then()
 * Net.load( "http://www.my.com/data.json" ).then( function( response ) {
 *   console.log( response.response );
 * } );
 * ```
 *
 * @async
 * @see {@link https://www.amcharts.com/docs/v5/concepts/data/net-load-utility/} for more info
 * @param url      URL for the file to load
 * @param target   A target element that is requesting the net load
 * @param options  Request options
 * @return Result (Promise)
 */
function load(url, target, options) {
    return new Promise((success, error) => {
        // Is return type Blob?
        let isBlob = options != null && options.responseType == "blob";
        // Create request and set up handlers
        let xhr = new XMLHttpRequest();
        xhr.onload = () => {
            if (xhr.status === 200) {
                let response;
                let blob;
                if (isBlob) {
                    blob = xhr.response;
                    readBlob(blob).then((response) => {
                        let output = {
                            xhr: xhr,
                            error: false,
                            response: response,
                            blob: blob,
                            type: xhr.getResponseHeader("Content-Type"),
                            target: target
                        };
                        success(output);
                    });
                    return;
                }
                else {
                    response = xhr.responseText || xhr.response;
                }
                let output = {
                    xhr: xhr,
                    error: false,
                    response: response,
                    blob: blob,
                    type: xhr.getResponseHeader("Content-Type"),
                    target: target
                };
                success(output);
            }
            else {
                error({
                    xhr: xhr,
                    error: true,
                    type: xhr.getResponseHeader("Content-Type"),
                    target: target
                });
            }
        };
        xhr.onerror = () => {
            error({
                xhr: xhr,
                error: true,
                type: xhr.getResponseHeader("Content-Type"),
                target: target
            });
        };
        // Open request
        xhr.open("GET", url, true);
        if (options && options.withCredentials) {
            xhr.withCredentials = true;
        }
        // Process options
        if (options != null) {
            if (options.requestHeaders != null) {
                for (let i = 0; i < options.requestHeaders.length; i++) {
                    let header = options.requestHeaders[i];
                    xhr.setRequestHeader(header.key, header.value);
                }
            }
            if (options.responseType != null) {
                xhr.responseType = options.responseType;
            }
        }
        // Send request
        xhr.send();
    });
}
/**
 * Returns textual representation of a Blob object.
 *
 * @param   blob  Target blob
 * @return        Text promise
 */
function readBlob(blob) {
    return new Promise((success, error) => {
        const reader = new FileReader();
        reader.onload = _event => {
            success(reader.result);
        };
        reader.onerror = (e) => {
            error(e);
        };
        reader.readAsText(blob);
    });
}
//# sourceMappingURL=Net.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js ***!
  \*********************************************************************************/
/*! exports provided: NumberFormatter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberFormatter", function() { return NumberFormatter; });
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony import */ var _TextFormatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");





/**
 * Number formatter
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info
 * @important
 */
class NumberFormatter extends _Entity__WEBPACK_IMPORTED_MODULE_0__["Entity"] {
    _setDefaults() {
        // Defaults
        this._setDefault("negativeBase", 0);
        this._setDefault("numberFormat", "#,###.#####");
        this._setDefault("smallNumberThreshold", 1.00);
        const bns = "_big_number_suffix_";
        const sns = "_small_number_suffix_";
        const bs = "_byte_suffix_";
        this._setDefault("bigNumberPrefixes", [
            { "number": 1e+3, "suffix": this._t(bns + "3") },
            { "number": 1e+6, "suffix": this._t(bns + "6") },
            { "number": 1e+9, "suffix": this._t(bns + "9") },
            { "number": 1e+12, "suffix": this._t(bns + "12") },
            { "number": 1e+15, "suffix": this._t(bns + "15") },
            { "number": 1e+18, "suffix": this._t(bns + "18") },
            { "number": 1e+21, "suffix": this._t(bns + "21") },
            { "number": 1e+24, "suffix": this._t(bns + "24") }
        ]);
        this._setDefault("smallNumberPrefixes", [
            { "number": 1e-24, "suffix": this._t(sns + "24") },
            { "number": 1e-21, "suffix": this._t(sns + "21") },
            { "number": 1e-18, "suffix": this._t(sns + "18") },
            { "number": 1e-15, "suffix": this._t(sns + "15") },
            { "number": 1e-12, "suffix": this._t(sns + "12") },
            { "number": 1e-9, "suffix": this._t(sns + "9") },
            { "number": 1e-6, "suffix": this._t(sns + "6") },
            { "number": 1e-3, "suffix": this._t(sns + "3") }
        ]);
        this._setDefault("bytePrefixes", [
            { "number": 1, suffix: this._t(bs + "B") },
            { "number": 1024, suffix: this._t(bs + "KB") },
            { "number": 1048576, suffix: this._t(bs + "MB") },
            { "number": 1073741824, suffix: this._t(bs + "GB") },
            { "number": 1099511627776, suffix: this._t(bs + "TB") },
            { "number": 1125899906842624, suffix: this._t(bs + "PB") }
        ]);
        super._setDefaults();
    }
    _beforeChanged() {
        super._beforeChanged();
    }
    /**
     * Formats the number according to specific format.
     *
     * @param value   Value to format
     * @param format  Format to apply
     * @return Formatted number
     */
    format(value, format, precision) {
        // no format passed in or "Number"
        if (format == null || (_Type__WEBPACK_IMPORTED_MODULE_4__["isString"](format) && format.toLowerCase() === "number")) {
            format = this.get("numberFormat", "");
        }
        // Init return value
        let formatted;
        // Cast to number just in case
        // TODO: maybe use better casting
        let source = Number(value);
        // Is it a built-in format or Intl.NumberFormatOptions
        if (_Type__WEBPACK_IMPORTED_MODULE_4__["isObject"](format)) {
            try {
                if (this.get("intlLocales")) {
                    return new Intl.NumberFormat(this.get("intlLocales"), format).format(source);
                }
                else {
                    return new Intl.NumberFormat(undefined, format).format(source);
                }
            }
            catch (e) {
                return "Invalid";
            }
        }
        else {
            // Clean format
            format = _Utils__WEBPACK_IMPORTED_MODULE_3__["cleanFormat"](format);
            // Get format info (it will also deal with parser caching)
            let info = this.parseFormat(format, this._root.language);
            // format and replace the number
            let details;
            if (source > this.get("negativeBase")) {
                details = info.positive;
            }
            else if (source < this.get("negativeBase")) {
                details = info.negative;
            }
            else {
                details = info.zero;
            }
            // Adjust precision
            if (precision != null && !details.mod) {
                details = _Object__WEBPACK_IMPORTED_MODULE_2__["copy"](details);
                details.decimals.active = source == 0 ? 0 : precision;
            }
            // Format
            formatted = details.template.split(_Type__WEBPACK_IMPORTED_MODULE_4__["PLACEHOLDER"]).join(this.applyFormat(source, details));
        }
        return formatted;
    }
    /**
     * Parses supplied format into structured object which can be used to format
     * the number.
     *
     * @param format Format string, i.e. "#,###.00"
     * @param language Language
     * @ignore
     */
    parseFormat(format, language) {
        // Check cache
        // TODO
        // let cached = this.getCache(format);
        // if (cached != null) {
        // 	return cached;
        // }
        const thousandSeparator = language.translateEmpty("_thousandSeparator");
        const decimalSeparator = language.translateEmpty("_decimalSeparator");
        // init format parse info holder
        let info = {
            "positive": {
                "thousands": {
                    "active": -1,
                    "passive": -1,
                    "interval": -1,
                    "separator": thousandSeparator
                },
                "decimals": {
                    "active": -1,
                    "passive": -1,
                    "separator": decimalSeparator
                },
                "template": "",
                "source": "",
                "parsed": false
            },
            "negative": {
                "thousands": {
                    "active": -1,
                    "passive": -1,
                    "interval": -1,
                    "separator": thousandSeparator
                },
                "decimals": {
                    "active": -1,
                    "passive": -1,
                    "separator": decimalSeparator
                },
                "template": "",
                "source": "",
                "parsed": false
            },
            "zero": {
                "thousands": {
                    "active": -1,
                    "passive": -1,
                    "interval": -1,
                    "separator": thousandSeparator
                },
                "decimals": {
                    "active": -1,
                    "passive": -1,
                    "separator": decimalSeparator
                },
                "template": "",
                "source": "",
                "parsed": false
            }
        };
        // Escape double vertical bars (that mean display one vertical bar)
        format = format.replace("||", _Type__WEBPACK_IMPORTED_MODULE_4__["PLACEHOLDER2"]);
        // Split it up and deal with different formats
        let parts = format.split("|");
        info.positive.source = parts[0];
        if (typeof parts[2] === "undefined") {
            info.zero = info.positive;
        }
        else {
            info.zero.source = parts[2];
        }
        if (typeof parts[1] === "undefined") {
            info.negative = info.positive;
        }
        else {
            info.negative.source = parts[1];
        }
        // Parse each
        _Object__WEBPACK_IMPORTED_MODULE_2__["each"](info, (_part, item) => {
            // Already parsed
            if (item.parsed) {
                return;
            }
            // Check cached
            // TODO
            // if (typeof this.getCache(item.source) !== "undefined") {
            // 	info[part] = this.getCache(item.source);
            // 	return;
            // }
            // Begin parsing
            let partFormat = item.source;
            // Just "Number"?
            if (partFormat.toLowerCase() === "number") {
                partFormat = this.get("numberFormat", "#,###.#####");
            }
            // Let TextFormatter split into chunks
            let chunks = _TextFormatter__WEBPACK_IMPORTED_MODULE_1__["TextFormatter"].chunk(partFormat, true);
            for (let i = 0; i < chunks.length; i++) {
                let chunk = chunks[i];
                // replace back double vertical bar
                chunk.text = chunk.text.replace(_Type__WEBPACK_IMPORTED_MODULE_4__["PLACEHOLDER2"], "|");
                if (chunk.type === "value") {
                    // Parse format
                    // Look for codes
                    let matches = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);
                    if (matches) {
                        if (matches === null || matches[0] === "") {
                            // no codes here - assume string
                            // nothing to do here
                            item.template += chunk.text;
                        }
                        else {
                            // look for the format modifiers at the end
                            let mods = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);
                            if (mods) {
                                item.mod = mods[0].toLowerCase();
                                item.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;
                            }
                            // break the format up
                            let a = matches[0].split(".");
                            // Deal with thousands
                            if (a[0] === "") {
                                // No directives for thousands
                                // Leave default settings (no formatting)
                            }
                            else {
                                // Counts
                                item.thousands.active = (a[0].match(/0/g) || []).length;
                                item.thousands.passive = (a[0].match(/\#/g) || []).length + item.thousands.active;
                                // Separator interval
                                let b = a[0].split(",");
                                if (b.length === 1) {
                                    // No thousands separators
                                    // Do nothing
                                }
                                else {
                                    // Use length fo the last chunk as thousands length
                                    item.thousands.interval = (b.pop() || "").length;
                                    if (item.thousands.interval === 0) {
                                        item.thousands.interval = -1;
                                    }
                                }
                            }
                            // Deal with decimals
                            if (typeof (a[1]) === "undefined") {
                                // No directives for decimals
                                // Leave at defaults (no formatting)
                            }
                            else {
                                // Counts
                                item.decimals.active = (a[1].match(/0/g) || []).length;
                                item.decimals.passive = (a[1].match(/\#/g) || []).length + item.decimals.active;
                            }
                            // Add special code to template
                            item.template += chunk.text.split(matches[0]).join(_Type__WEBPACK_IMPORTED_MODULE_4__["PLACEHOLDER"]);
                        }
                    }
                }
                else {
                    // Quoted string - take it as it is
                    item.template += chunk.text;
                }
            }
            // Apply style formatting
            //item.template = getTextFormatter().format(item.template, this.outputFormat);
            // Save cache
            // TODO
            //this.setCache(item.source, item);
            // Mark this as parsed
            item.parsed = true;
        });
        // Save cache (the whole thing)
        // TODO
        //this.setCache(format, info);
        return info;
    }
    /**
     * Applies parsed format to a numeric value.
     *
     * @param value    Value
     * @param details  Parsed format as returned by parseFormat()
     * @return Formatted number
     * @ignore
     */
    applyFormat(value, details) {
        // Use absolute values
        let negative = value < 0;
        value = Math.abs(value);
        // Recalculate according to modifier
        let prefix = "", suffix = "";
        let mods = details.mod ? details.mod.split("") : [];
        if (mods.indexOf("b") !== -1) {
            let a = this.applyPrefix(value, this.get("bytePrefixes"), mods.indexOf("!") !== -1);
            value = a[0];
            prefix = a[1];
            suffix = a[2];
            if (details.modSpacing) {
                suffix = " " + suffix;
            }
        }
        else if (mods.indexOf("a") !== -1) {
            let a = this.applyPrefix(value, value < this.get("smallNumberThreshold") ? this.get("smallNumberPrefixes") : this.get("bigNumberPrefixes"), mods.indexOf("!") !== -1);
            value = a[0];
            prefix = a[1];
            suffix = a[2];
            if (details.modSpacing) {
                suffix = " " + suffix;
            }
        }
        else if (mods.indexOf("p") !== -1) {
            let ol = Math.min(value.toString().length + 2, 21);
            //value *= 100;
            value = parseFloat(value.toPrecision(ol));
            prefix = this._root.language.translate("_percentPrefix");
            suffix = this._root.language.translate("_percentSuffix");
            if (prefix == "" && suffix == "") {
                suffix = "%";
            }
        }
        else if (mods.indexOf("%") !== -1) {
            let ol = Math.min(value.toString().length + 2, 21);
            value *= 100;
            value = parseFloat(value.toPrecision(ol));
            suffix = "%";
        }
        else if (mods.indexOf("‰") !== -1) {
            let ol = Math.min(value.toString().length + 3, 21);
            value *= 1000;
            value = parseFloat(value.toPrecision(ol));
            suffix = "‰";
        }
        // Round to passive
        if (mods.indexOf("e") !== -1) {
            // convert the value to exponential
            let exp;
            if (details.decimals.passive >= 0) {
                exp = value.toExponential(details.decimals.passive).split("e");
            }
            else {
                exp = value.toExponential().split("e");
            }
            value = Number(exp[0]);
            suffix = "e" + exp[1];
            if (details.modSpacing) {
                suffix = " " + suffix;
            }
        }
        else if (details.decimals.passive === 0) {
            value = Math.round(value);
        }
        else if (details.decimals.passive > 0) {
            let d = Math.pow(10, details.decimals.passive);
            value = Math.round(value * d) / d;
        }
        // Init return value
        let res = "";
        // Calc integer and decimal parts
        let a = _Type__WEBPACK_IMPORTED_MODULE_4__["numberToString"](value).split(".");
        // Format integers
        let ints = a[0];
        // Pad integers to active length
        if (ints.length < details.thousands.active) {
            ints = Array(details.thousands.active - ints.length + 1).join("0") + ints;
        }
        // Insert thousands separators
        if (details.thousands.interval > 0) {
            let ip = [];
            let intsr = ints.split("").reverse().join("");
            for (let i = 0, len = ints.length; i <= len; i += details.thousands.interval) {
                let c = intsr.substr(i, details.thousands.interval).split("").reverse().join("");
                if (c !== "") {
                    ip.unshift(c);
                }
            }
            ints = ip.join(details.thousands.separator);
        }
        // Add integers
        res += ints;
        // Add decimals
        if (a.length === 1) {
            a.push("");
        }
        let decs = a[1];
        // Fill zeros?
        if (decs.length < details.decimals.active) {
            decs += Array(details.decimals.active - decs.length + 1).join("0");
        }
        if (decs !== "") {
            res += details.decimals.separator + decs;
        }
        // Can't have empty return value
        if (res === "") {
            res = "0";
        }
        // Add minus sign back
        if (value !== 0 && negative && (mods.indexOf("s") === -1)) {
            res = "-" + res;
        }
        // Add suffixes/prefixes
        if (prefix) {
            res = prefix + res;
        }
        if (suffix) {
            res += suffix;
        }
        return res;
    }
    applyPrefix(value, prefixes, force = false) {
        let newvalue = value;
        let prefix = "";
        let suffix = "";
        let applied = false;
        let k = 1;
        for (let i = 0, len = prefixes.length; i < len; i++) {
            if (prefixes[i].number <= value) {
                if (prefixes[i].number === 0) {
                    newvalue = 0;
                }
                else {
                    newvalue = value / prefixes[i].number;
                    k = prefixes[i].number;
                }
                prefix = prefixes[i].prefix;
                suffix = prefixes[i].suffix;
                applied = true;
            }
        }
        if (!applied && force && prefixes.length && value != 0) {
            // Prefix was not applied. Use the first prefix.
            newvalue = value / prefixes[0].number;
            prefix = prefixes[0].prefix;
            suffix = prefixes[0].suffix;
            applied = true;
        }
        if (applied) {
            newvalue = parseFloat(newvalue.toPrecision(Math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, "").length, 21)));
        }
        return [newvalue, prefix, suffix];
    }
    /**
     * Replaces brackets with temporary placeholders.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Escaped text
     */
    escape(text) {
        return text.replace("||", _Type__WEBPACK_IMPORTED_MODULE_4__["PLACEHOLDER2"]);
    }
    /**
     * Replaces placeholders back to brackets.
     *
     * @ignore Exclude from docs
     * @param text  Escaped text
     * @return Unescaped text
     */
    unescape(text) {
        return text.replace(_Type__WEBPACK_IMPORTED_MODULE_4__["PLACEHOLDER2"], "|");
    }
}
//# sourceMappingURL=NumberFormatter.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js ***!
  \************************************************************************/
/*! exports provided: keys, keysOrdered, copy, each, eachContinue, eachOrdered, hasKey, softCopyProperties */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return keys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keysOrdered", function() { return keysOrdered; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "each", function() { return each; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eachContinue", function() { return eachContinue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eachOrdered", function() { return eachOrdered; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasKey", function() { return hasKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softCopyProperties", function() { return softCopyProperties; });
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");

function keys(object) {
    return Object.keys(object);
}
/**
 * Returns an array of object's property names ordered using specific ordering
 * function.
 *
 * @param object  Source object
 * @param order   Ordering function
 * @returns Object property names
 */
function keysOrdered(object, order) {
    return keys(object).sort(order);
}
function copy(object) {
    return Object.assign({}, object);
}
function each(object, f) {
    keys(object).forEach((key) => {
        f(key, object[key]);
    });
}
/**
 * Iterates through all properties of the object calling `fn` for each of them.
 *
 * If return value of the function evaluates to `false` further iteration is
 * cancelled.
 *
 * @param object  Source object
 * @param fn      Callback function
 */
function eachContinue(object, fn) {
    for (let key in object) {
        if (hasKey(object, key)) {
            if (!fn(key, object[key])) {
                break;
            }
        }
    }
}
/**
 * Orders object properties using custom `ord` function and iterates through
 * them calling `fn` for each of them.
 *
 * @param object  Source object
 * @param fn      Callback function
 * @param order   Ordering function
 */
function eachOrdered(object, fn, ord) {
    _Array__WEBPACK_IMPORTED_MODULE_0__["each"](keysOrdered(object, ord), (key) => {
        fn(key, object[key]);
    });
}
/**
 * Checks if `object` has a specific `key`.
 *
 * @param object  Source object
 * @param key     Property name
 * @returns Has key?
 */
function hasKey(object, key) {
    return {}.hasOwnProperty.call(object, key);
}
/**
 * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn't have a value set.
 *
 * @param fromObject  Source object
 * @param toObject    Target object
 * @return Updated target object
 * @todo Maybe consolidate with utils.copy?
 */
function softCopyProperties(source, target) {
    each(source, (key, value) => {
        // only if value is set
        //if ($type.hasValue(value) && !($type.hasValue((<any>target)[key]))) {
        if (value != null && target[key] == null) {
            target[key] = value;
        }
    });
    return target;
}
//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js ***!
  \***********************************************************************/
/*! exports provided: compare, compareArray, reverse, compareNumber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compare", function() { return compare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareArray", function() { return compareArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareNumber", function() { return compareNumber; });
/**
 * @ignore
 */
function compare(left, right) {
    if (left === right) {
        return 0;
    }
    else if (left < right) {
        return -1;
    }
    else {
        return 1;
    }
}
/**
 * @ignore
 */
function compareArray(left, right, f) {
    const leftLength = left.length;
    const rightLength = right.length;
    const length = Math.min(leftLength, rightLength);
    for (let i = 0; i < length; ++i) {
        const order = f(left[i], right[i]);
        if (order !== 0) {
            return order;
        }
    }
    return compare(leftLength, rightLength);
}
/**
 * @ignore
 */
function reverse(order) {
    if (order < 0) {
        return 1;
    }
    else if (order > 0) {
        return -1;
    }
    else {
        return 0;
    }
}
/**
 * @ignore
 */
function compareNumber(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
//# sourceMappingURL=Order.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js ***!
  \*************************************************************************/
/*! exports provided: Percent, percent, p0, p100, p50, isPercent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Percent", function() { return Percent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "percent", function() { return percent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p0", function() { return p0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p100", function() { return p100; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p50", function() { return p50; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPercent", function() { return isPercent; });
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Represents a relative value (percent).
 *
 * The Percent object, can be instantiated using two ways:
 *
 * * Via `new Percent(X)`.
 * * Via `am5.percent(X)`.
 *
 * You can also use shortcut functions for `0%`, `50%`, and `100%`:
 * * `am5.p0`
 * * `am5.p50`
 * * `am5.p1000`
 */
class Percent {
    /**
     * Constructor.
     *
     * @param percent  Percent value
     */
    constructor(percent) {
        /**
         * Value in percent.
         */
        Object.defineProperty(this, "_value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._value = percent;
    }
    /**
     * Relative value.
     *
     * E.g. 100% is 1, 50% is 0.5, etc.
     *
     * This is useful to apply transformations to other values. E.g.:
     *
     * ```TypeScript
     * let value = 256;
     * let percent = new am5.p50;
     * console.log(value * percent.value); // outputs 128
     * ```
     * ```JavaScript
     * var value = 256;
     * var percent = new am5.p50;
     * console.log(value * percent.value); // outputs 128
     * ```
     *
     * Alternatively, you can use `am5.percent()` helper function:
     *
     * ```TypeScript
     * let value = 256;
     * let percent = am5.p50;
     * console.log(value * percent.value); // outputs 128
     * ```
     * ```JavaScript
     * var value = 256;
     * var percent = am5.p50;
     * console.log(value * percent.value); // outputs 128
     * ```
     *
     * @readonly
     * @return Relative value
     */
    get value() {
        return this._value / 100;
    }
    /**
     * Value in percent.
     *
     * @return Percent
     */
    get percent() {
        return this._value;
    }
    toString() {
        return "" + this._value + "%";
    }
    interpolate(min, max) {
        return min + (this.value * (max - min));
    }
    static normalize(percent, min, max) {
        if (percent instanceof Percent) {
            return percent;
        }
        else {
            if (min === max) {
                return new Percent(0);
            }
            else {
                return new Percent(Math.min(Math.max((percent - min) * (1 / (max - min)), 0), 1) * 100);
            }
        }
    }
}
/**
 * Converts numeric percent value to a proper [[Percent]] object.
 *
 * ```TypeScript
 * pieSeries.set("radius", am5.percent(80));
 * ```
 * ```JavaScript
 * pieSeries.set("radius", am5.percent(80));
 * ```
 *
 * @param value  Percent
 * @return Percent object
 */
function percent(value) {
    return new Percent(value);
}
/**
 * A shortcut function to `am5.percent(0)`.
 */
const p0 = percent(0);
/**
 * A shortcut function to `am5.percent(100)`.
 */
const p100 = percent(100);
/**
 * A shortcut function to `am5.percent(50)`.
 */
const p50 = percent(50);
/**
 * Checks if value is a [[Percent]] object.
 *
 * @ignore Exclude from docs
 * @param value  Input value
 * @return Is percent?
 */
function isPercent(value) {
    return value instanceof Percent;
}
//# sourceMappingURL=Percent.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js ***!
  \********************************************************************************/
/*! exports provided: populateString, getTagValueFromObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "populateString", function() { return populateString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTagValueFromObject", function() { return getTagValueFromObject; });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony import */ var _render_Sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render/Sprite */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js");
/* harmony import */ var _TextFormatter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/** @ignore */ /** */




/**
 * @ignore
 */
function populateString(target, string) {
    if (string != null) {
        string = "" + string;
        string = _TextFormatter__WEBPACK_IMPORTED_MODULE_3__["TextFormatter"].escape(string);
        let tags = string.match(/\{([^}]+)\}/g);
        let i;
        if (tags) {
            for (i = 0; i < tags.length; i++) {
                let tag = tags[i].replace(/\{([^}]+)\}/, "$1");
                let value = getTagValue(target, tag, "");
                if (value == null) {
                    value = "";
                }
                string = string.split(tags[i]).join(value);
            }
        }
        string = _TextFormatter__WEBPACK_IMPORTED_MODULE_3__["TextFormatter"].unescape(string);
    }
    else {
        string = "";
    }
    // TODO: apply adapter?
    return string;
}
/**
 * @ignore
 */
function getTagValue(target, tagName, format) {
    let value;
    const dataItem = target.dataItem;
    // Parse parts
    let parts = [];
    let reg = /([^.]+)\(([^)]*)\)|([^.]+)/g;
    ;
    let matches;
    while (true) {
        matches = reg.exec(tagName);
        if (matches === null) {
            break;
        }
        if (matches[3]) {
            // Simple property
            parts.push({
                prop: matches[3]
            });
            // Check if maybe we should force a formatter on this value
            const dateFields = target.getDateFormatter().get("dateFields", []);
            const numericFields = target.getNumberFormatter().get("numericFields", []);
            const durationFields = target.getDurationFormatter().get("durationFields", []);
            if (dateFields.indexOf(matches[3]) !== -1) {
                parts.push({
                    method: "formatDate",
                    params: []
                });
            }
            else if (numericFields.indexOf(matches[3]) !== -1) {
                parts.push({
                    method: "formatNumber",
                    params: []
                });
            }
            else if (durationFields.indexOf(matches[3]) !== -1) {
                parts.push({
                    method: "formatDuration",
                    params: []
                });
            }
        }
        else {
            // Method
            // Parse parameters
            let params = [];
            if (_Utils__WEBPACK_IMPORTED_MODULE_1__["trim"](matches[2]) != "") {
                let reg2 = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g;
                let matches2;
                while (true) {
                    matches2 = reg2.exec(matches[2]);
                    if (matches2 === null) {
                        break;
                    }
                    params.push(matches2[1] || matches2[2] || matches2[3]);
                }
            }
            parts.push({
                method: matches[1],
                params: params
            });
        }
    }
    // Check if we can retrieve the value from data item
    if (dataItem) {
        // Check values
        value = getTagValueFromObject(target, parts, dataItem._settings);
        // Check properties
        if (value == null || _Type__WEBPACK_IMPORTED_MODULE_0__["isObject"](value)) { // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.
            value = getTagValueFromObject(target, parts, dataItem);
        }
        // Check data context
        let dataContext = dataItem.dataContext;
        if (value == null && dataContext) {
            value = getTagValueFromObject(target, parts, dataContext);
            // Maybe it's a literal dot-separated name of the key in dataContext?
            if (value == null) {
                value = getTagValueFromObject(target, [{
                        prop: tagName
                    }], dataContext);
            }
            // scond data context level sometimes exist (tree map)
            if (value == null && dataContext.dataContext) {
                value = getTagValueFromObject(target, parts, dataContext.dataContext);
            }
        }
        // Check component's data item
        if (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {
            value = getTagValue(dataItem.component, tagName, format);
        }
    }
    // Check sprite's properties
    if (value == null) {
        value = getTagValueFromObject(target, parts, target);
    }
    // Finally, check the parent
    if (value == null && target.parent) {
        value = getTagValue(target.parent, tagName, format);
    }
    return value;
}
/**
 * @ignore
 */
function getCustomDataValue(target, prop) {
    const customData = target.getPrivate("customData");
    if (_Type__WEBPACK_IMPORTED_MODULE_0__["isObject"](customData)) {
        return customData[prop];
    }
}
/**
 * @ignore
 */
function getTagValueFromObject(target, parts, object, format) {
    let current = object;
    let formatApplied = false;
    for (let i = 0, len = parts.length; i < len; i++) {
        let part = parts[i];
        if (part.prop) {
            // Regular property
            if (current instanceof _render_Sprite__WEBPACK_IMPORTED_MODULE_2__["Sprite"]) {
                let tmp = current.get(part.prop);
                if (tmp == null)
                    tmp = current.getPrivate(part.prop);
                if (tmp == null)
                    tmp = getCustomDataValue(current, part.prop);
                if (tmp == null)
                    tmp = current[part.prop];
                current = tmp;
            }
            else if (current.get) {
                let tmp = current.get(part.prop);
                if (tmp == null)
                    tmp = current[part.prop];
                current = tmp;
            }
            else {
                current = current[part.prop];
            }
            if (current == null) {
                // Not set, return undefined
                return;
            }
        }
        else {
            // Method
            switch (part.method) {
                case "formatNumber":
                    let numberValue = _Type__WEBPACK_IMPORTED_MODULE_0__["toNumber"](current);
                    if (numberValue != null) {
                        current = target.getNumberFormatter().format(numberValue, format || part.params[0] || undefined);
                        formatApplied = true;
                    }
                    break;
                case "formatDate":
                    let dateValue = _Type__WEBPACK_IMPORTED_MODULE_0__["toDate"](current);
                    if (!_Type__WEBPACK_IMPORTED_MODULE_0__["isDate"](dateValue) || _Type__WEBPACK_IMPORTED_MODULE_0__["isNaN"](dateValue.getTime())) {
                        // Was not able to get date out of value, quitting and letting
                        // calling method try another value
                        return;
                    }
                    if (dateValue != null) {
                        current = target.getDateFormatter().format(dateValue, format || part.params[0] || undefined);
                        formatApplied = true;
                    }
                    break;
                case "formatDuration":
                    let durationValue = _Type__WEBPACK_IMPORTED_MODULE_0__["toNumber"](current);
                    if (durationValue != null) {
                        current = target.getDurationFormatter().format(durationValue, format || part.params[0] || undefined, part.params[1] || undefined);
                        formatApplied = true;
                    }
                    break;
                case "urlEncode":
                case "encodeURIComponent":
                    current = encodeURIComponent(current);
                    break;
                default:
                    if (current[part.method]) {
                        current[part.method].apply(object, part.params);
                    }
                    break;
            }
        }
    }
    // Apply default format if it wasn't applied explicitly
    if (!formatApplied) {
        let formatParts = [{
                method: "",
                params: format
            }];
        if (format == null) {
            // Format is not set
            // Determine from the type of the value
            if (_Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"](current)) {
                formatParts[0].method = "formatNumber";
                formatParts[0].params = "";
            }
            else if (_Type__WEBPACK_IMPORTED_MODULE_0__["isDate"](current)) {
                formatParts[0].method = "formatDate";
                formatParts[0].params = "";
            }
        }
        else {
            // Format set
            // Try to determine formatter based on the format
            let formatterType = _Utils__WEBPACK_IMPORTED_MODULE_1__["getFormat"](format);
            // format
            if (formatterType === "number") {
                formatParts[0].method = "formatNumber";
            }
            else if (formatterType === "date") {
                formatParts[0].method = "formatDate";
            }
            else if (formatterType === "duration") {
                formatParts[0].method = "formatDuration";
            }
        }
        // Apply format
        if (formatParts[0].method) {
            current = getTagValueFromObject(target, formatParts, current);
        }
    }
    return current;
}
//# sourceMappingURL=PopulateString.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/ResizeSensor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/ResizeSensor.js ***!
  \******************************************************************************/
/*! exports provided: ResizeSensor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResizeSensor", function() { return ResizeSensor; });
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/** @ignore */ /** */


/**
 * @ignore
 */
class Native {
    constructor() {
        Object.defineProperty(this, "_observer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_targets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this._observer = new ResizeObserver((entries) => {
            _Array__WEBPACK_IMPORTED_MODULE_0__["each"](entries, (entry) => {
                _Array__WEBPACK_IMPORTED_MODULE_0__["each"](this._targets, (x) => {
                    if (x.target === entry.target) {
                        x.callback();
                    }
                });
            });
        });
    }
    addTarget(target, callback) {
        this._observer.observe(target, { box: "border-box" });
        this._targets.push({ target, callback });
    }
    removeTarget(target) {
        this._observer.unobserve(target);
        _Array__WEBPACK_IMPORTED_MODULE_0__["keepIf"](this._targets, (x) => {
            return x.target !== target;
        });
    }
}
/**
 * @ignore
 */
class Raf {
    constructor() {
        Object.defineProperty(this, "_timer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "_targets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    addTarget(target, callback) {
        if (this._timer === null) {
            let lastTime = null;
            const loop = () => {
                const currentTime = Date.now();
                if (lastTime === null || currentTime > (lastTime + Raf.delay)) {
                    lastTime = currentTime;
                    _Array__WEBPACK_IMPORTED_MODULE_0__["each"](this._targets, (x) => {
                        let newSize = x.target.getBoundingClientRect();
                        if (newSize.width !== x.size.width || newSize.height !== x.size.height) {
                            x.size = newSize;
                            x.callback();
                        }
                    });
                }
                if (this._targets.length === 0) {
                    this._timer = null;
                }
                else {
                    this._timer = requestAnimationFrame(loop);
                }
            };
            this._timer = requestAnimationFrame(loop);
        }
        // We start off with fake bounds so that sensor always kicks in
        let size = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };
        this._targets.push({ target, callback, size });
    }
    removeTarget(target) {
        _Array__WEBPACK_IMPORTED_MODULE_0__["keepIf"](this._targets, (x) => {
            return x.target !== target;
        });
        if (this._targets.length === 0) {
            if (this._timer !== null) {
                cancelAnimationFrame(this._timer);
                this._timer = null;
            }
        }
    }
}
Object.defineProperty(Raf, "delay", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 200
});
/**
 * @ignore
 */
let observer = null;
/**
 * @ignore
 */
function makeSensor() {
    if (observer === null) {
        if (typeof ResizeObserver !== "undefined") {
            observer = new Native();
        }
        else {
            observer = new Raf();
        }
    }
    return observer;
}
/**
 * @ignore
 */
class ResizeSensor {
    constructor(element, callback) {
        Object.defineProperty(this, "_sensor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_element", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_listener", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_disposed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        this._sensor = makeSensor();
        this._element = element;
        // This is needed because we need to know when the window is zoomed
        this._listener = _Utils__WEBPACK_IMPORTED_MODULE_1__["onZoom"](callback);
        this._sensor.addTarget(element, callback);
    }
    isDisposed() {
        return this._disposed;
    }
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            this._sensor.removeTarget(this._element);
            this._listener.dispose();
        }
    }
    get sensor() {
        return this._sensor;
    }
}
//# sourceMappingURL=ResizeSensor.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/States.js":
/*!************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/States.js ***!
  \************************************************************************/
/*! exports provided: State, States */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "State", function() { return State; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "States", function() { return States; });
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Ease__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Ease */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js");


/**
 * An object representing a collection of setting values to apply as required.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/states/} for more info
 */
class State {
    constructor(entity, settings) {
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_userSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._entity = entity;
        this._settings = settings;
        _Object__WEBPACK_IMPORTED_MODULE_0__["each"](settings, (key) => {
            this._userSettings[key] = true;
        });
    }
    get(key, fallback) {
        const value = this._settings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    /**
     * @ignore
     */
    setRaw(key, value) {
        this._settings[key] = value;
    }
    /**
     * Sets a setting `value` for the specified `key` to be set when the state
     * is applied.
     *
     * @param   key       Setting key
     * @param   value     Setting value
     * @return            Setting value
     */
    set(key, value) {
        this._userSettings[key] = true;
        this.setRaw(key, value);
    }
    /**
     * Removes a setting value for the specified `key`.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param   key       Setting key
     */
    remove(key) {
        delete this._userSettings[key];
        delete this._settings[key];
    }
    /**
     * Sets multiple settings at once.
     *
     * `settings` must be an object with key: value pairs.
     *
     * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
     * @param settings Settings
     */
    setAll(settings) {
        _Object__WEBPACK_IMPORTED_MODULE_0__["keys"](settings).forEach((key) => {
            this.set(key, settings[key]);
        });
    }
    _eachSetting(f) {
        _Object__WEBPACK_IMPORTED_MODULE_0__["each"](this._settings, f);
    }
    /**
     * Applies the state to the target element.
     *
     * All setting values are set immediately.
     */
    apply() {
        const seen = {};
        seen["stateAnimationEasing"] = true;
        seen["stateAnimationDuration"] = true;
        const defaultState = this._entity.states.lookup("default");
        this._eachSetting((key, value) => {
            if (!seen[key]) {
                seen[key] = true;
                // save values to default state
                if (this !== defaultState) {
                    if (!(key in defaultState._settings)) {
                        defaultState._settings[key] = this._entity.get(key);
                    }
                }
                this._entity.set(key, value);
            }
        });
    }
    /**
     * Applies the state to the target element.
     *
     * Returns an object representing all [[Animation]] objects created for
     * each setting key transition.
     *
     * @return           Animations
     */
    applyAnimate(duration) {
        if (duration == null) {
            duration = this._settings.stateAnimationDuration;
        }
        if (duration == null) {
            duration = this.get("stateAnimationDuration", this._entity.get("stateAnimationDuration", 0));
        }
        let easing = this._settings.stateAnimationEasing;
        if (easing == null) {
            easing = this.get("stateAnimationEasing", this._entity.get("stateAnimationEasing", _Ease__WEBPACK_IMPORTED_MODULE_1__["cubic"]));
        }
        const defaultState = this._entity.states.lookup("default");
        const seen = {};
        seen["stateAnimationEasing"] = true;
        seen["stateAnimationDuration"] = true;
        const animations = {};
        this._eachSetting((key, value) => {
            if (!seen[key]) {
                seen[key] = true;
                // save values to default state
                if (this != defaultState) {
                    if (!(key in defaultState._settings)) {
                        defaultState._settings[key] = this._entity.get(key);
                    }
                }
                const animation = this._entity.animate({
                    key: key,
                    to: value,
                    duration: duration,
                    easing: easing
                });
                if (animation) {
                    animations[key] = animation;
                }
            }
        });
        return animations;
    }
}
/**
 * Collection of [[State]] objects for an element.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/states/} for more info
 */
class States {
    constructor(entity) {
        Object.defineProperty(this, "_states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_entity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._entity = entity;
    }
    /**
     * Checks if a state by `name` exists. Returns it there is one.
     *
     * @param  name  State name
     * @return       State
     */
    lookup(name) {
        return this._states[name];
    }
    /**
     * Sets supplied `settings` on a state by the `name`.
     *
     * If such state does not yet exists, it is created.
     *
     * @param   name      State name
     * @param   settings  Settings
     * @return            New State
     */
    create(name, settings) {
        const state = this._states[name];
        if (state) {
            state.setAll(settings);
            return state;
        }
        else {
            const state = new State(this._entity, settings);
            this._states[name] = state;
            return state;
        }
    }
    /**
     * Removes the state called `name`.
     *
     * @param   name      State name
     */
    remove(name) {
        delete this._states[name];
    }
    /**
     * Applies a named state to the target element.
     *
     * @param  newState  State name
     */
    apply(newState) {
        const state = this._states[newState];
        if (state) {
            state.apply();
        }
        this._entity._applyState(newState);
    }
    /**
     * Applies a named state to the element.
     *
     * Returns an object representing all [[Animation]] objects created for
     * each setting key transition.
     *
     * @param   newState  State name
     * @return            Animations
     */
    applyAnimate(newState, duration) {
        let animations;
        const state = this._states[newState];
        if (state) {
            animations = state.applyAnimate(duration);
        }
        this._entity._applyStateAnimated(newState, duration);
        return animations;
    }
}
//# sourceMappingURL=States.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js ***!
  \**************************************************************************/
/*! exports provided: TemplateState, TemplateStates, TemplateAdapters, Template */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplateState", function() { return TemplateState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplateStates", function() { return TemplateStates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TemplateAdapters", function() { return TemplateAdapters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Template", function() { return Template; });
/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventDispatcher */ "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js");
/* harmony import */ var _Disposer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");




class TemplateState {
    constructor(name, template, settings) {
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._name = name;
        this._template = template;
        this._settings = settings;
    }
    get(key, fallback) {
        const value = this._settings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    set(key, value) {
        this._settings[key] = value;
        // TODO maybe only do this if the value changed ?
        this._template._stateChanged(this._name);
    }
    remove(key) {
        delete this._settings[key];
        // TODO maybe only do this if the value changed ?
        this._template._stateChanged(this._name);
    }
    setAll(settings) {
        _Object__WEBPACK_IMPORTED_MODULE_3__["keys"](settings).forEach((key) => {
            this._settings[key] = settings[key];
        });
        this._template._stateChanged(this._name);
    }
    _apply(other, seen) {
        _Object__WEBPACK_IMPORTED_MODULE_3__["each"](this._settings, (key, value) => {
            if (!seen[key] && !other._userSettings[key]) {
                seen[key] = true;
                other.setRaw(key, value);
            }
        });
    }
}
class TemplateStates {
    constructor(template) {
        Object.defineProperty(this, "_template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this._template = template;
    }
    lookup(name) {
        return this._states[name];
    }
    create(name, settings) {
        const state = this._states[name];
        if (state) {
            state.setAll(settings);
            return state;
        }
        else {
            const state = new TemplateState(name, this._template, settings);
            this._states[name] = state;
            this._template._stateChanged(name);
            return state;
        }
    }
    remove(name) {
        delete this._states[name];
        this._template._stateChanged(name);
    }
    _apply(entity, state) {
        _Object__WEBPACK_IMPORTED_MODULE_3__["each"](this._states, (key, value) => {
            let seen = state.states[key];
            if (seen == null) {
                seen = state.states[key] = {};
            }
            const other = entity.states.create(key, {});
            value._apply(other, seen);
        });
    }
}
class TemplateAdapters {
    constructor() {
        Object.defineProperty(this, "_callbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    add(key, callback) {
        let callbacks = this._callbacks[key];
        if (callbacks === undefined) {
            callbacks = this._callbacks[key] = [];
        }
        callbacks.push(callback);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_1__["Disposer"](() => {
            _Array__WEBPACK_IMPORTED_MODULE_2__["removeFirst"](callbacks, callback);
            if (callbacks.length === 0) {
                delete this._callbacks[key];
            }
        });
    }
    remove(key) {
        const callbacks = this._callbacks[key];
        if (callbacks !== undefined) {
            delete this._callbacks[key];
        }
    }
    _apply(entity) {
        const disposers = [];
        _Object__WEBPACK_IMPORTED_MODULE_3__["each"](this._callbacks, (key, callbacks) => {
            _Array__WEBPACK_IMPORTED_MODULE_2__["each"](callbacks, (callback) => {
                disposers.push(entity.adapters.add(key, callback));
            });
        });
        return new _Disposer__WEBPACK_IMPORTED_MODULE_1__["MultiDisposer"](disposers);
    }
}
// TODO maybe extend from Properties ?
class Template {
    constructor(settings, isReal) {
        Object.defineProperty(this, "_settings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_privateSettings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        // TODO code duplication with Properties
        Object.defineProperty(this, "_settingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_privateSettingEvents", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_entities", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "states", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new TemplateStates(this)
        });
        Object.defineProperty(this, "adapters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new TemplateAdapters()
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new _EventDispatcher__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"]()
        });
        Object.defineProperty(this, "setup", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        this._settings = settings;
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   root      Root element
     * @param   settings  Settings
     * @param   template  Template
     * @return            Instantiated object
     */
    static new(settings) {
        return new Template(settings, true);
    }
    /**
     * Array of all entities using this template.
     */
    get entities() {
        return this._entities;
    }
    get(key, fallback) {
        const value = this._settings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    setRaw(key, value) {
        this._settings[key] = value;
    }
    set(key, value) {
        if (this._settings[key] !== value) {
            this.setRaw(key, value);
            this._entities.forEach((entity) => {
                entity._setTemplateProperty(this, key, value);
            });
        }
    }
    remove(key) {
        if (key in this._settings) {
            delete this._settings[key];
            this._entities.forEach((entity) => {
                entity._removeTemplateProperty(key);
            });
        }
    }
    removeAll() {
        _Object__WEBPACK_IMPORTED_MODULE_3__["each"](this._settings, (key, _value) => {
            this.remove(key);
        });
    }
    getPrivate(key, fallback) {
        const value = this._privateSettings[key];
        if (value !== undefined) {
            return value;
        }
        else {
            return fallback;
        }
    }
    setPrivateRaw(key, value) {
        this._privateSettings[key] = value;
        return value;
    }
    setPrivate(key, value) {
        if (this._privateSettings[key] !== value) {
            this.setPrivateRaw(key, value);
            this._entities.forEach((entity) => {
                entity._setTemplatePrivateProperty(this, key, value);
            });
        }
        return value;
    }
    removePrivate(key) {
        if (key in this._privateSettings) {
            delete this._privateSettings[key];
            this._entities.forEach((entity) => {
                entity._removeTemplatePrivateProperty(key);
            });
        }
    }
    setAll(value) {
        _Object__WEBPACK_IMPORTED_MODULE_3__["each"](value, (key, value) => {
            this.set(key, value);
        });
    }
    // TODO code duplication with Properties
    on(key, callback) {
        let events = this._settingEvents[key];
        if (events === undefined) {
            events = this._settingEvents[key] = [];
        }
        events.push(callback);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_1__["Disposer"](() => {
            _Array__WEBPACK_IMPORTED_MODULE_2__["removeFirst"](events, callback);
            if (events.length === 0) {
                delete this._settingEvents[key];
            }
        });
    }
    // TODO code duplication with Properties
    onPrivate(key, callback) {
        let events = this._privateSettingEvents[key];
        if (events === undefined) {
            events = this._privateSettingEvents[key] = [];
        }
        events.push(callback);
        return new _Disposer__WEBPACK_IMPORTED_MODULE_1__["Disposer"](() => {
            _Array__WEBPACK_IMPORTED_MODULE_2__["removeFirst"](events, callback);
            if (events.length === 0) {
                delete this._privateSettingEvents[key];
            }
        });
    }
    _apply(entity, state) {
        const disposers = [];
        _Object__WEBPACK_IMPORTED_MODULE_3__["each"](this._settingEvents, (key, events) => {
            _Array__WEBPACK_IMPORTED_MODULE_2__["each"](events, (event) => {
                disposers.push(entity.on(key, event));
            });
        });
        _Object__WEBPACK_IMPORTED_MODULE_3__["each"](this._privateSettingEvents, (key, events) => {
            _Array__WEBPACK_IMPORTED_MODULE_2__["each"](events, (event) => {
                disposers.push(entity.onPrivate(key, event));
            });
        });
        this.states._apply(entity, state);
        disposers.push(this.adapters._apply(entity));
        disposers.push(entity.events.copyFrom(this.events));
        return new _Disposer__WEBPACK_IMPORTED_MODULE_1__["MultiDisposer"](disposers);
    }
    _setObjectTemplate(entity) {
        this._entities.push(entity);
    }
    _removeObjectTemplate(entity) {
        _Array__WEBPACK_IMPORTED_MODULE_2__["remove"](this._entities, entity);
    }
    _stateChanged(name) {
        this._entities.forEach((entity) => {
            entity._applyStateByKey(name);
        });
    }
}
//# sourceMappingURL=Template.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js ***!
  \*******************************************************************************/
/*! exports provided: TextFormatter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextFormatter", function() { return TextFormatter; });
/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");


class TextFormatter {
    /**
     * Replaces brackets with temporary placeholders.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Escaped text
     */
    static escape(text) {
        return text.
            replace(/\[\[/g, this.prefix + "1").
            replace(/([^\/\]]{1})\]\]/g, "$1" + this.prefix + "2").
            replace(/\]\]/g, this.prefix + "2").
            replace(/\{\{/g, this.prefix + "3").
            replace(/\}\}/g, this.prefix + "4").
            replace(/\'\'/g, this.prefix + "5");
    }
    /**
     * Replaces placeholders back to brackets.
     *
     * @ignore Exclude from docs
     * @param text  Escaped text
     * @return Unescaped text
     */
    static unescape(text) {
        return text.
            replace(new RegExp(this.prefix + "1", "g"), "[[").
            replace(new RegExp(this.prefix + "2", "g"), "]]").
            replace(new RegExp(this.prefix + "3", "g"), "{{").
            replace(new RegExp(this.prefix + "4", "g"), "}}").
            replace(new RegExp(this.prefix + "5", "g"), "''");
    }
    /**
     * Cleans up the text text for leftover double square brackets.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Cleaned up text
     */
    static cleanUp(text) {
        return text.
            replace(/\[\[/g, "[").
            replace(/\]\]/g, "]").
            replace(/\{\{/g, "{").
            replace(/\}\}/g, "}").
            replace(/\'\'/g, "'");
    }
    /**
     * Splits string into chunks. (style blocks, quoted blocks, regular blocks)
     *
     * If the second parameter `quotedBlocks` is set to `true` this method will
     * also single out text blocks enclosed within single quotes that no
     * formatting should be applied to, and they should be displayed as is.
     *
     * Default for the above is `false`, so that you can use single quote in text
     * without escaping it.
     *
     * If enabled, single quotes can be escaped by doubling it - adding two
     * single quotes, which will be replaced by a one single quote in the final
     * output.
     *
     * @ignore Exclude from docs
     * @param text          Text to chunk
     * @param quotedBlocks  Use quoted blocks
     * @param noFormatting  Formatting blocks will be treated as regular text
     * @return Array of string chunks
     */
    static chunk(text, quotedBlocks = false, noFormatting = false) {
        // Init result
        let res = [];
        // Replace double (escaped) square spaces and quotes with temporary codes
        text = this.escape(text);
        // Deal with style blocks
        let chunks = quotedBlocks ? text.split("'") : [text];
        for (let i = 0; i < chunks.length; i++) {
            let chunk = chunks[i];
            // Empty?
            if (chunk === "") {
                continue;
            }
            if ((i % 2) === 0) {
                // Text outside quotes
                // Parse for style blocks which are "text" chunks, the rest chunks are
                // "value"
                chunk = chunk.replace(/\]\[/g, "]" + _Type__WEBPACK_IMPORTED_MODULE_1__["PLACEHOLDER"] + "[");
                chunk = chunk.replace(/\[\]/g, "[ ]");
                let chunks2 = chunk.split(/[\[\]]+/);
                for (let i2 = 0; i2 < chunks2.length; i2++) {
                    let chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
                    // Placeholder?
                    if (chunk2 === _Type__WEBPACK_IMPORTED_MODULE_1__["PLACEHOLDER"]) {
                        continue;
                    }
                    // Empty?
                    if (chunk2 === "") {
                        continue;
                    }
                    // Block or value
                    if ((i2 % 2) === 0) {
                        res.push({
                            "type": "value",
                            "text": chunk2
                        });
                    }
                    else {
                        res.push({
                            "type": noFormatting ? "value" : "format",
                            "text": "[" + chunk2 + "]"
                        });
                    }
                }
            }
            else {
                // A text within doublequotes
                // All chunks are "text"
                let chunks2 = chunk.split(/[\[\]]+/);
                for (let i2 = 0; i2 < chunks2.length; i2++) {
                    let chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
                    // Empty?
                    if (chunk2 === "") {
                        continue;
                    }
                    // Block or text
                    if ((i2 % 2) === 0) {
                        res.push({
                            "type": "text",
                            "text": chunk2
                        });
                    }
                    else if (this.isImage(chunk2)) {
                        res.push({
                            "type": "image",
                            "text": "[" + chunk2 + "]"
                        });
                    }
                    else {
                        res.push({
                            "type": "format",
                            "text": "[" + chunk2 + "]"
                        });
                    }
                }
            }
        }
        return res;
    }
    /**
     * Checks if supplied format contains image information and should be
     * formatted as such.
     * I.e.: `[img: myImage.png]`
     *
     * @ignore
     * @param  text  Format
     * @return true if it is an image
     */
    static isImage(text) {
        return text.match(/img[ ]?:/) ? true : false;
    }
    static getTextStyle(style) {
        // let textStyle: string[] = [];
        // let textFill: string | undefined;
        let format = {};
        if (style == "" || style == "[ ]") {
            return {};
        }
        // Pre-process quoted text
        const q = style.match(/('[^']*')|("[^"]*")/gi);
        if (q) {
            for (let i = 0; i < q.length; i++) {
                style = style.replace(q[i], q[i].replace(/['"]*/g, "").replace(/[ ]+/g, "+"));
            }
        }
        // Get style parts
        let b = style.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w\-]+)|(\/)/gi);
        // Empty?
        if (!b) {
            return {};
        }
        // Check each part
        for (let i = 0; i < b.length; i++) {
            if (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {
                format.fontWeight = b[i];
            }
            else if (b[i].match(/^(underline|line-through)$/i)) {
                format.textDecoration = b[i];
            }
            else if (b[i] == "/") {
                // Just closing tag
                // Do nothing
            }
            else if (!b[i].match(/:/)) {
                // Color
                format.fill = _Color__WEBPACK_IMPORTED_MODULE_0__["Color"].fromString(b[i]);
            }
            else {
                const p = b[i].replace("+", " ").split(/:[ ]*/);
                format[p[0]] = p[1];
                //textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, ""));
                //b[i] = b[i].replace(/\+/g, " ");
            }
        }
        return format;
    }
}
Object.defineProperty(TextFormatter, "prefix", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "__amcharts__"
});
//# sourceMappingURL=TextFormatter.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js ***!
  \**********************************************************************/
/*! exports provided: sleep, timeUnitDurations, getNextUnit, getDuration, getIntervalDuration, getDateIntervalDuration, now, getTime, copy, checkChange, add, round, chooseInterval, getUnitValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sleep", function() { return sleep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeUnitDurations", function() { return timeUnitDurations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNextUnit", function() { return getNextUnit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDuration", function() { return getDuration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntervalDuration", function() { return getIntervalDuration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDateIntervalDuration", function() { return getDateIntervalDuration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTime", function() { return getTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkChange", function() { return checkChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chooseInterval", function() { return chooseInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUnitValue", function() { return getUnitValue; });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * Returns a `Promise` which can be used to execute code after number of
 * milliseconds.
 *
 * @param   ms  Sleep duration in ms
 * @return      Promise
 */
function sleep(ms) {
    return new Promise((resolve, _reject) => {
        setTimeout(resolve, ms);
    });
}
/**
 * Maps time period names to their numeric representations in milliseconds.
 *
 * @ignore Exclude from docs
 */
let timeUnitDurations = {
    millisecond: 1,
    second: 1000,
    minute: 60000,
    hour: 3600000,
    day: 86400000,
    week: 604800000,
    month: 365.242 / 12 * 86400000,
    year: 31536000000
};
/**
 * Returns the next time unit that goes after source `unit`.
 *
 * E.g. "hour" is the next unit after "minute", etc.
 *
 * @ignore Exclude from docs
 * @param unit  Source time unit
 * @return Next time unit
 */
function getNextUnit(unit) {
    switch (unit) {
        case "year":
            return;
        case "month":
            return "year";
        case "week":
            return "month";
        case "day":
            return "month"; // not a mistake
        case "hour":
            return "day";
        case "minute":
            return "hour";
        case "second":
            return "minute";
        case "millisecond":
            return "second";
    }
}
/**
 * Returns number of milliseconds in the `count` of time `unit`.
 *
 * Available units: "millisecond", "second", "minute", "hour", "day", "week",
 * "month", and "year".
 *
 * @param unit   Time unit
 * @param count  Number of units
 * @return Milliseconds
 */
function getDuration(unit, count) {
    if (count == null) {
        count = 1;
    }
    return timeUnitDurations[unit] * count;
}
/**
 * @ignore
 */
function getIntervalDuration(interval) {
    if (interval) {
        return timeUnitDurations[interval.timeUnit] * interval.count;
    }
    return 0;
}
function getDateIntervalDuration(interval, date, firstDateOfWeek, utc, timezone) {
    const unit = interval.timeUnit;
    const count = interval.count;
    if (unit == "hour" || unit == "minute" || unit == "second" || unit == "millisecond") {
        return timeUnitDurations[interval.timeUnit] * interval.count;
    }
    else {
        const firstTime = round(new Date(date.getTime()), unit, count, firstDateOfWeek, utc, undefined, timezone).getTime();
        let lastTime = firstTime + count * getDuration(unit) * 1.05;
        lastTime = round(new Date(lastTime), unit, 1, firstDateOfWeek, utc, undefined, timezone).getTime();
        return lastTime - firstTime;
    }
}
/**
 * Returns current `Date` object.
 *
 * @return Current date
 */
function now() {
    return new Date();
}
/**
 * Returns current timestamp.
 *
 * @return Current timestamp
 */
function getTime() {
    return now().getTime();
}
/**
 * Returns a copy of the `Date` object.
 *
 * @param date  Source date
 * @return Copy
 */
function copy(date) {
    return new Date(date.getTime()); // todo: check if this is ok. new Date(date) used to strip milliseconds on FF in v3
}
/**
 * Checks if the `unit` part of two `Date` objects do not match. Two dates
 * represent a "range" of time, rather the same time date.
 *
 * @param timeOne  timestamp
 * @param timeTwo  timestamp
 * @param unit     Time unit to check
 * @return Range?
 */
function checkChange(timeOne, timeTwo, unit, utc, timezone) {
    // quick
    if ((timeTwo - timeOne) > getDuration(unit, 1.2)) {
        return true;
    }
    let dateOne = new Date(timeOne);
    let dateTwo = new Date(timeTwo);
    if (timezone) {
        dateOne = timezone.convertLocal(dateOne);
        dateTwo = timezone.convertLocal(dateTwo);
    }
    let timeZoneOffset1 = 0;
    let timeZoneOffset2 = 0;
    if (!utc && unit != "millisecond") {
        timeZoneOffset1 = dateOne.getTimezoneOffset();
        dateOne.setUTCMinutes(dateOne.getUTCMinutes() - timeZoneOffset1);
        timeZoneOffset2 = dateTwo.getTimezoneOffset();
        dateTwo.setUTCMinutes(dateTwo.getUTCMinutes() - timeZoneOffset2);
    }
    let changed = false;
    switch (unit) {
        case "year":
            if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
                changed = true;
            }
            break;
        case "month":
            if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
                changed = true;
            }
            else if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
                changed = true;
            }
            break;
        case "day":
            if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
                changed = true;
            }
            else if (dateOne.getUTCDate() != dateTwo.getUTCDate()) {
                changed = true;
            }
            break;
        case "hour":
            if (dateOne.getUTCHours() != dateTwo.getUTCHours()) {
                changed = true;
            }
            break;
        case "minute":
            if (dateOne.getUTCMinutes() != dateTwo.getUTCMinutes()) {
                changed = true;
            }
            break;
        case "second":
            if (dateOne.getUTCSeconds() != dateTwo.getUTCSeconds()) {
                changed = true;
            }
            break;
        case "millisecond":
            if (dateOne.getTime() != dateTwo.getTime()) {
                changed = true;
            }
            break;
    }
    if (changed) {
        return changed;
    }
    let nextUnit = getNextUnit(unit);
    if (nextUnit) {
        return checkChange(timeOne, timeTwo, nextUnit, utc, timezone);
    }
    else {
        return false;
    }
}
/**
 * Adds `count` of time `unit` to the source date. Returns a modified `Date` object.
 *
 * @param date   Source date
 * @param unit   Time unit
 * @param count  Number of units to add
 * @return Modified date
 */
function add(date, unit, count, utc, timezone) {
    let timeZoneOffset = 0;
    if (!utc && unit != "millisecond") {
        timeZoneOffset = date.getTimezoneOffset();
        if (timezone) {
            timeZoneOffset -= timezone.offsetUTC(date);
        }
        date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
    }
    switch (unit) {
        case "day":
            let day = date.getUTCDate();
            date.setUTCDate(day + count);
            break;
        case "second":
            let seconds = date.getUTCSeconds();
            date.setUTCSeconds(seconds + count);
            break;
        case "millisecond":
            let milliseconds = date.getUTCMilliseconds();
            date.setUTCMilliseconds(milliseconds + count);
            break;
        case "hour":
            let hours = date.getUTCHours();
            date.setUTCHours(hours + count);
            break;
        case "minute":
            let minutes = date.getUTCMinutes();
            date.setUTCMinutes(minutes + count);
            break;
        case "year":
            let year = date.getUTCFullYear();
            date.setUTCFullYear(year + count);
            break;
        case "month":
            let month = date.getUTCMonth();
            date.setUTCMonth(month + count);
            break;
        case "week":
            let wday = date.getUTCDate();
            date.setUTCDate(wday + count * 7);
            break;
    }
    if (!utc && unit != "millisecond") {
        date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
        if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
            let newTimeZoneOffset = date.getTimezoneOffset();
            if (timezone) {
                newTimeZoneOffset += timezone.offsetUTC(date);
            }
            if (newTimeZoneOffset != timeZoneOffset) {
                let diff = newTimeZoneOffset - timeZoneOffset;
                date.setUTCMinutes(date.getUTCMinutes() + diff);
                // solves issues if new time falls back to old time zone
                if (date.getTimezoneOffset() != newTimeZoneOffset) {
                    date.setUTCMinutes(date.getUTCMinutes() - diff);
                }
            }
        }
    }
    return date;
}
/**
 * "Rounds" the date to specific time unit.
 *
 * @param date             Source date
 * @param unit             Time unit
 * @param count            Number of units to round to
 * @param firstDateOfWeek  First day of week
 * @param utc              Use UTC timezone
 * @param firstDate        First date to round to
 * @param roundMinutes     Minutes to round to (some timezones use non-whole hour)
 * @param timezone         Use specific named timezone when rounding
 * @return New date
 */
function round(date, unit, count, firstDateOfWeek, utc, firstDate, timezone) {
    if (!timezone || utc) {
        let timeZoneOffset = 0;
        if (!utc && unit != "millisecond") {
            timeZoneOffset = date.getTimezoneOffset();
            date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
        }
        switch (unit) {
            case "day":
                let day = date.getUTCDate();
                if (count > 1) {
                    //	day = Math.floor(day / count) * count;
                    if (firstDate) {
                        firstDate = round(firstDate, "day", 1);
                        let difference = date.getTime() - firstDate.getTime();
                        let unitCount = Math.floor(difference / getDuration("day") / count);
                        let duration = getDuration("day", unitCount * count);
                        date.setTime(firstDate.getTime() + duration - timeZoneOffset * getDuration("minute"));
                    }
                }
                else {
                    date.setUTCDate(day);
                }
                date.setUTCHours(0, 0, 0, 0);
                break;
            case "second":
                let seconds = date.getUTCSeconds();
                if (count > 1) {
                    seconds = Math.floor(seconds / count) * count;
                }
                date.setUTCSeconds(seconds, 0);
                break;
            case "millisecond":
                if (count == 1) {
                    return date; // much better for perf!
                }
                let milliseconds = date.getUTCMilliseconds();
                milliseconds = Math.floor(milliseconds / count) * count;
                date.setUTCMilliseconds(milliseconds);
                break;
            case "hour":
                let hours = date.getUTCHours();
                if (count > 1) {
                    hours = Math.floor(hours / count) * count;
                }
                date.setUTCHours(hours, 0, 0, 0);
                break;
            case "minute":
                let minutes = date.getUTCMinutes();
                if (count > 1) {
                    minutes = Math.floor(minutes / count) * count;
                }
                date.setUTCMinutes(minutes, 0, 0);
                break;
            case "month":
                let month = date.getUTCMonth();
                if (count > 1) {
                    month = Math.floor(month / count) * count;
                }
                date.setUTCMonth(month, 1);
                date.setUTCHours(0, 0, 0, 0);
                break;
            case "year":
                let year = date.getUTCFullYear();
                if (count > 1) {
                    year = Math.floor(year / count) * count;
                }
                date.setUTCFullYear(year, 0, 1);
                date.setUTCHours(0, 0, 0, 0);
                break;
            case "week":
                let wday = date.getUTCDate();
                let weekDay = date.getUTCDay();
                if (!_Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"](firstDateOfWeek)) {
                    firstDateOfWeek = 1;
                }
                if (weekDay >= firstDateOfWeek) {
                    wday = wday - weekDay + firstDateOfWeek;
                }
                else {
                    wday = wday - (7 + weekDay) + firstDateOfWeek;
                }
                date.setUTCDate(wday);
                date.setUTCHours(0, 0, 0, 0);
                break;
        }
        if (!utc && unit != "millisecond") {
            date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
            if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
                let newTimeZoneOffset = date.getTimezoneOffset();
                if (newTimeZoneOffset != timeZoneOffset) {
                    let diff = newTimeZoneOffset - timeZoneOffset;
                    date.setUTCMinutes(date.getUTCMinutes() + diff);
                }
            }
        }
        return date;
    }
    else {
        if (isNaN(date.getTime())) {
            return date;
        }
        let tzoffset = timezone.offsetUTC(date);
        let timeZoneOffset = date.getTimezoneOffset();
        let parsedDate = timezone.parseDate(date);
        //console.log(parsedDate)
        let year = parsedDate.year;
        let month = parsedDate.month;
        let day = parsedDate.day;
        let hour = parsedDate.hour;
        let minute = parsedDate.minute;
        let second = parsedDate.second;
        let millisecond = parsedDate.millisecond;
        let weekday = parsedDate.weekday;
        switch (unit) {
            case "day":
                if (count > 1 && firstDate) {
                    firstDate = round(firstDate, "day", 1, firstDateOfWeek, utc, undefined, timezone);
                    let difference = date.getTime() - firstDate.getTime();
                    let unitCount = Math.floor(difference / getDuration("day") / count);
                    let duration = getDuration("day", unitCount * count);
                    date.setTime(firstDate.getTime() + duration);
                    parsedDate = timezone.parseDate(date);
                    year = parsedDate.year;
                    month = parsedDate.month;
                    day = parsedDate.day;
                }
                hour = 0;
                minute = tzoffset - timeZoneOffset;
                second = 0;
                millisecond = 0;
                break;
            case "second":
                minute += tzoffset - timeZoneOffset;
                if (count > 1) {
                    second = Math.floor(second / count) * count;
                }
                millisecond = 0;
                break;
            case "millisecond":
                minute += tzoffset - timeZoneOffset;
                if (count > 1) {
                    millisecond = Math.floor(millisecond / count) * count;
                }
                break;
            case "hour":
                if (count > 1) {
                    hour = Math.floor(hour / count) * count;
                }
                minute = tzoffset - timeZoneOffset;
                second = 0;
                millisecond = 0;
                break;
            case "minute":
                if (count > 1) {
                    minute = Math.floor(minute / count) * count;
                }
                minute += tzoffset - timeZoneOffset;
                second = 0;
                millisecond = 0;
                break;
            case "month":
                if (count > 1) {
                    month = Math.floor(month / count) * count;
                }
                day = 1;
                hour = 0;
                minute = tzoffset - timeZoneOffset;
                second = 0;
                millisecond = 0;
                break;
            case "year":
                if (count > 1) {
                    year = Math.floor(year / count) * count;
                }
                month = 0;
                day = 1;
                hour = 0;
                minute = tzoffset - timeZoneOffset;
                second = 0;
                millisecond = 0;
                break;
            case "week":
                if (!_Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"](firstDateOfWeek)) {
                    firstDateOfWeek = 1;
                }
                if (weekday >= firstDateOfWeek) {
                    day = day - weekday + firstDateOfWeek;
                }
                else {
                    day = day - (7 + weekday) + firstDateOfWeek;
                }
                hour = 0;
                minute = tzoffset - timeZoneOffset;
                second = 0;
                millisecond = 0;
                break;
        }
        date = new Date(year, month, day, hour, minute, second, millisecond);
        let newOffset = date.getTimezoneOffset();
        if (newOffset != timeZoneOffset) {
            date.setTime(date.getTime() + (timeZoneOffset - newOffset) * 60000);
        }
        return date;
    }
}
/**
 * @ignore
 */
function chooseInterval(index, duration, gridCount, intervals) {
    let gridInterval = intervals[index];
    let intervalDuration = getIntervalDuration(gridInterval);
    let lastIndex = intervals.length - 1;
    if (index >= lastIndex) {
        return Object.assign({}, intervals[lastIndex]);
    }
    let count = Math.ceil(duration / intervalDuration);
    if (duration < intervalDuration && index > 0) {
        return Object.assign({}, intervals[index - 1]);
    }
    if (count <= gridCount) {
        return Object.assign({}, intervals[index]);
    }
    else {
        if (index + 1 < intervals.length) {
            return chooseInterval(index + 1, duration, gridCount, intervals);
        }
        else {
            return Object.assign({}, intervals[index]);
        }
    }
}
/**
 * @ignore
 */
function getUnitValue(date, unit) {
    switch (unit) {
        case "day":
            return date.getDate();
        case "second":
            return date.getSeconds();
        case "millisecond":
            return date.getMilliseconds();
        case "hour":
            return date.getHours();
        case "minute":
            return date.getMinutes();
        case "month":
            return date.getMonth();
        case "year":
            return date.getFullYear();
        case "week":
            return _Utils__WEBPACK_IMPORTED_MODULE_1__["getWeek"](date);
    }
}
//# sourceMappingURL=Time.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Timezone.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Timezone.js ***!
  \**************************************************************************/
/*! exports provided: Timezone */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timezone", function() { return Timezone; });
function parseDate(timezone, date) {
    let year = 0;
    let month = 0;
    let day = 1;
    let hour = 0;
    let minute = 0;
    let second = 0;
    let millisecond = 0;
    let weekday = 0;
    timezone.formatToParts(date).forEach((x) => {
        switch (x.type) {
            case "year":
                year = +x.value;
                break;
            case "month":
                month = (+x.value) - 1;
                break;
            case "day":
                day = +x.value;
                break;
            case "hour":
                hour = +x.value;
                break;
            case "minute":
                minute = +x.value;
                break;
            case "second":
                second = +x.value;
                break;
            case "fractionalSecond":
                millisecond = +x.value;
                break;
            case "weekday":
                switch (x.value) {
                    case "Sun":
                        weekday = 0;
                        break;
                    case "Mon":
                        weekday = 1;
                        break;
                    case "Tue":
                        weekday = 2;
                        break;
                    case "Wed":
                        weekday = 3;
                        break;
                    case "Thu":
                        weekday = 4;
                        break;
                    case "Fri":
                        weekday = 5;
                        break;
                    case "Sat":
                        weekday = 6;
                        break;
                }
        }
    });
    if (hour === 24) {
        hour = 0;
    }
    return { year, month, day, hour, minute, second, millisecond, weekday };
}
function toUTCDate(timezone, date) {
    const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
    return Date.UTC(year, month, day, hour, minute, second, millisecond);
}
class Timezone {
    constructor(timezone, isReal) {
        Object.defineProperty(this, "_utc", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_dtf", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (!isReal) {
            throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
        }
        this.name = timezone;
        this._utc = new Intl.DateTimeFormat("UTC", {
            hour12: false,
            timeZone: "UTC",
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            weekday: "short",
            fractionalSecondDigits: 3,
        });
        this._dtf = new Intl.DateTimeFormat("UTC", {
            hour12: false,
            timeZone: timezone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            weekday: "short",
            fractionalSecondDigits: 3,
        });
    }
    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
    static new(timezone) {
        return (new this(timezone, true));
    }
    convertLocal(date) {
        const offset = this.offsetUTC(date);
        const userOffset = date.getTimezoneOffset();
        const output = new Date(date);
        output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
        const newUserOffset = output.getTimezoneOffset();
        if (userOffset != newUserOffset) {
            output.setUTCMinutes(output.getUTCMinutes() + newUserOffset - userOffset);
        }
        return output;
    }
    offsetUTC(date) {
        const utc = toUTCDate(this._utc, date);
        const dtf = toUTCDate(this._dtf, date);
        return (utc - dtf) / 60000;
    }
    parseDate(date) {
        return parseDate(this._dtf, date);
    }
}
//# sourceMappingURL=Timezone.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js ***!
  \**********************************************************************/
/*! exports provided: isNaN, getType, assert, toNumber, toDate, numberToString, repeat, isDate, isString, isNumber, isObject, isArray, PLACEHOLDER, PLACEHOLDER2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return isNaN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getType", function() { return getType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toNumber", function() { return toNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDate", function() { return toDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberToString", function() { return numberToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return repeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDate", function() { return isDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return isNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLACEHOLDER", function() { return PLACEHOLDER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLACEHOLDER2", function() { return PLACEHOLDER2; });
/**
 * A collection of utility functions for various type checks and conversion
 * @hidden
 */
/**
 * ============================================================================
 * TYPE CHECK
 * ============================================================================
 * @hidden
 */
/**
 * Returns `true` if value is not a number (NaN).
 *
 * @param value Input value
 * @return Is NaN?
 */
function isNaN(value) {
    return Number(value) !== value;
}
/**
 * Returns a type of the value.
 *
 * @param value  Input value
 * @return Type of the value
 * @ignore
 */
function getType(value) {
    return ({}).toString.call(value);
}
/**
 * Asserts that the condition is true.
 *
 * @param condition  Condition to check
 * @param message    Message to display in the error
 * @ignore
 */
function assert(condition, message = "Assertion failed") {
    if (!condition) {
        throw new Error(message);
    }
}
/**
 * ============================================================================
 * QUICK CONVERSION
 * ============================================================================
 * @hidden
 */
/**
 * Converts any value into a `number`.
 *
 * @param value  Source value
 * @return Number representation of value
 */
function toNumber(value) {
    if (value != null && !isNumber(value)) {
        let converted = Number(value);
        if (isNaN(converted) && isString(value) && value != "") {
            return toNumber(value.replace(/[^0-9.\-]+/g, ''));
        }
        return converted;
    }
    return value;
}
/**
 * Converts anything to Date object.
 *
 * @param value  A value of any type
 * @return Date object representing a value
 */
function toDate(value) {
    if (isDate(value)) {
        // TODO maybe don't create a new Date ?
        return new Date(value);
    }
    else if (isNumber(value)) {
        return new Date(value);
    }
    else {
        // Try converting to number (assuming timestamp)
        let num = Number(value);
        if (!isNumber(num)) {
            return new Date(value);
        }
        else {
            return new Date(num);
        }
    }
}
/**
 * Converts numeric value into string. Deals with large or small numbers that
 * would otherwise use exponents.
 *
 * @param value  Numeric value
 * @return Numeric value as string
 */
function numberToString(value) {
    // TODO handle Infinity and -Infinity
    if (isNaN(value)) {
        return "NaN";
    }
    if (value === Infinity) {
        return "Infinity";
    }
    if (value === -Infinity) {
        return "-Infinity";
    }
    // Negative 0
    if ((value === 0) && (1 / value === -Infinity)) {
        return "-0";
    }
    // Preserve negative and deal with absoute values
    let negative = value < 0;
    value = Math.abs(value);
    // TODO test this
    let parsed = /^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + value);
    let digits = parsed[1];
    let decimals = parsed[2] || "";
    let res;
    // Leave the nummber as it is if it does not use exponents
    if (parsed[3] === undefined) {
        res = (decimals === "" ? digits : digits + "." + decimals);
    }
    else {
        let exponent = +parsed[3];
        // Deal with decimals
        if (value < 1) {
            let zeros = exponent - 1;
            res = "0." + repeat("0", zeros) + digits + decimals;
            // Deal with integers
        }
        else {
            let zeros = exponent - decimals.length;
            if (zeros === 0) {
                res = digits + decimals;
            }
            else if (zeros < 0) {
                res = digits + decimals.slice(0, zeros) + "." + decimals.slice(zeros);
            }
            else {
                res = digits + decimals + repeat("0", zeros);
            }
        }
    }
    return negative ? "-" + res : res;
}
/**
 * Repeats a `string` number of times as set in `amount`.
 *
 * @ignore Exclude from docs
 * @todo Make this faster
 * @param string  Source string
 * @param amount  Number of times to repeat string
 * @return New string
 */
function repeat(string, amount) {
    return new Array(amount + 1).join(string);
}
/**
 * ============================================================================
 * TYPE CHECK
 * ============================================================================
 * @hidden
 */
/**
 * Checks if parameter is `Date`.
 *
 * @param value  Input value
 * @return Is Date?
 */
function isDate(value) {
    return getType(value) === "[object Date]";
}
/**
 * Checks if parameter is `string`.
 *
 * @param value  Input value
 * @return Is string?
 */
function isString(value) {
    return typeof value === "string";
}
/**
 * Checks if parameter is `number`.
 *
 * @param value  Input value
 * @return Is number?
 */
function isNumber(value) {
    return typeof value === "number" && Number(value) == value;
}
/**
 * Checks if parameter is `object`.
 *
 * @param value  Input value
 * @return Is object?
 */
function isObject(value) {
    return typeof value === "object" && value !== null;
}
/**
 * Checks if parameter is `Array`.
 *
 * @param value  Input value
 * @return Is Array?
 */
function isArray(value) {
    return Array.isArray(value);
}
/**
 * ============================================================================
 * STATIC CONSTANTS
 * ============================================================================
 * @hidden
 */
/**
 * @ignore Exclude from docs
 */
const PLACEHOLDER = "__§§§__";
/**
 * @ignore Exclude from docs
 */
const PLACEHOLDER2 = "__§§§§__";
//# sourceMappingURL=Type.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js ***!
  \***********************************************************************/
/*! exports provided: ready, removeElement, addEventListener, onZoom, supports, getPointerId, blur, focus, getRendererEvent, isTouchEvent, setStyle, getStyle, contains, isLocalEvent, setInteractive, getShadowRoot, StyleRule, StyleSheet, addClass, removeClass, iOS, getSafeResolution, relativeToValue, decimalPlaces, padString, trimLeft, trimRight, trim, getFormat, cleanFormat, stripTags, plainText, escapeForRgex, addSpacing, getYearDay, getWeek, getWeekYear, getMonthWeek, getDayFromWeek, get12Hours, getTimeZone, getTimezoneOffset, capitalizeFirst, hslToRgb, rgbToHsl, lighten, getLightnessStep, brighten, getBrightnessStep, isLight, saturate, alternativeColor, mergeTags, sameBounds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ready", function() { return ready; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeElement", function() { return removeElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEventListener", function() { return addEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onZoom", function() { return onZoom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supports", function() { return supports; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointerId", function() { return getPointerId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blur", function() { return blur; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "focus", function() { return focus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRendererEvent", function() { return getRendererEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTouchEvent", function() { return isTouchEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setStyle", function() { return setStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStyle", function() { return getStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return contains; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLocalEvent", function() { return isLocalEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setInteractive", function() { return setInteractive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getShadowRoot", function() { return getShadowRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StyleRule", function() { return StyleRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StyleSheet", function() { return StyleSheet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addClass", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeClass", function() { return removeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iOS", function() { return iOS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSafeResolution", function() { return getSafeResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relativeToValue", function() { return relativeToValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decimalPlaces", function() { return decimalPlaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padString", function() { return padString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trimLeft", function() { return trimLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trimRight", function() { return trimRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trim", function() { return trim; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFormat", function() { return getFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanFormat", function() { return cleanFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripTags", function() { return stripTags; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plainText", function() { return plainText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escapeForRgex", function() { return escapeForRgex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addSpacing", function() { return addSpacing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getYearDay", function() { return getYearDay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWeek", function() { return getWeek; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWeekYear", function() { return getWeekYear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMonthWeek", function() { return getMonthWeek; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDayFromWeek", function() { return getDayFromWeek; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get12Hours", function() { return get12Hours; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTimeZone", function() { return getTimeZone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTimezoneOffset", function() { return getTimezoneOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalizeFirst", function() { return capitalizeFirst; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslToRgb", function() { return hslToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbToHsl", function() { return rgbToHsl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lighten", function() { return lighten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLightnessStep", function() { return getLightnessStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighten", function() { return brighten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBrightnessStep", function() { return getBrightnessStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLight", function() { return isLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saturate", function() { return saturate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alternativeColor", function() { return alternativeColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeTags", function() { return mergeTags; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sameBounds", function() { return sameBounds; });
/* harmony import */ var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony import */ var _Object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony import */ var _Disposer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");




/**
 * ============================================================================
 * DOM FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Execute a function when DOM is ready.
 *
 * @since 5.0.2
 * @param  f  Callback
 */
function ready(f) {
    if (document.readyState !== "loading") {
        f();
    }
    else {
        const listener = () => {
            if (document.readyState !== "loading") {
                document.removeEventListener("readystatechange", listener);
                f();
            }
        };
        document.addEventListener("readystatechange", listener);
    }
}
/**
 * Removes a DOM element.
 * @param  el  Target element
 */
function removeElement(el) {
    if (el.parentNode) {
        el.parentNode.removeChild(el);
    }
}
/**
 * Function that adds a disposable event listener directly to a DOM element.
 *
 * @ignore Exclude from docs
 * @param dom       A DOM element to add event to
 * @param type      Event type
 * @param listener  Event listener
 * @returns Disposable event
 */
function addEventListener(dom, type, listener, options) {
    //@todo proper type check for options: EventListenerOptions | boolean (TS for some reason gives error on passive parameter)
    //console.log(type, dom);
    dom.addEventListener(type, listener, options || false);
    return new _Disposer__WEBPACK_IMPORTED_MODULE_3__["Disposer"](() => {
        dom.removeEventListener(type, listener, options || false);
    });
}
/**
 * Function that adds an event listener which is triggered when the browser's zoom changes.
 *
 * @param listener  Event listener
 * @returns Disposable event
 */
function onZoom(listener) {
    // TODO use matchMedia instead ?
    return addEventListener(window, "resize", (_ev) => {
        listener();
    });
}
/**
 * @ignore
 */
function supports(cap) {
    switch (cap) {
        case "touchevents":
            //return "ontouchstart" in document.documentElement;
            return window.hasOwnProperty("TouchEvent");
        case "pointerevents":
            return window.hasOwnProperty("PointerEvent");
        case "mouseevents":
            return window.hasOwnProperty("MouseEvent");
        case "wheelevents":
            return window.hasOwnProperty("WheelEvent");
        case "keyboardevents":
            return window.hasOwnProperty("KeyboardEvent");
    }
    return false;
}
/**
 * @ignore
 */
function getPointerId(event) {
    let id = event.pointerId || 0;
    //console.log(event);
    return id;
}
/**
 * Removes focus from any element by shifting focus to body.
 *
 * @ignore
 */
function blur() {
    if (document.activeElement && document.activeElement != document.body) {
        if (document.activeElement.blur) {
            document.activeElement.blur();
        }
        else {
            let input = document.createElement("button");
            input.style.position = "fixed";
            input.style.top = "0px";
            input.style.left = "-10000px";
            document.body.appendChild(input);
            input.focus();
            input.blur();
            document.body.removeChild(input);
        }
    }
}
/**
 * Focuses element.
 *
 * @ignore
 */
function focus(el) {
    if (el) {
        el.focus();
    }
}
/**
 * @ignore
 */
function getRendererEvent(key) {
    if (supports("pointerevents")) {
        return key;
    }
    else if (supports("touchevents")) {
        switch (key) {
            case "pointerover": return "touchstart";
            case "pointerout": return "touchend";
            case "pointerdown": return "touchstart";
            case "pointermove": return "touchmove";
            case "pointerup": return "touchend";
            case "click": return "click";
            case "dblclick": return "dblclick";
        }
    }
    else if (supports("mouseevents")) {
        switch (key) {
            case "pointerover": return "mouseover";
            case "pointerout": return "mouseout";
            case "pointerdown": return "mousedown";
            case "pointermove": return "mousemove";
            case "pointerup": return "mouseup";
            case "click": return "click";
            case "dblclick": return "dblclick";
        }
    }
    return key;
}
/**
 * Determines if pointer event originated from a touch pointer or mouse.
 *
 * @param ev  Original event
 * @return Touch pointer?
 */
function isTouchEvent(ev) {
    if (typeof Touch !== "undefined" && ev instanceof Touch) {
        return true;
    }
    else if (typeof PointerEvent !== "undefined" && ev instanceof PointerEvent && ev.pointerType != null) {
        switch (ev.pointerType) {
            case "touch":
            case "pen":
            case 2:
                return true;
            case "mouse":
            case 4:
                return false;
            default:
                return !(ev instanceof MouseEvent);
        }
    }
    else if (ev.type != null) {
        if (ev.type.match(/^mouse/)) {
            return false;
        }
    }
    return true;
}
/**
 * Sets style property on DOM element.
 *
 * @ignore Exclude from docs
 */
function setStyle(dom, property, value) {
    dom.style[property] = value;
}
function getStyle(dom, property) {
    return dom.style[property];
}
/**
 * Checks of element `a` contains element `b`.
 *
 * @param a  Aleged ascendant
 * @param b  Aleged descendant
 * @return Contains?
 */
function contains(a, b) {
    let cursor = b;
    while (true) {
        if (a === cursor) {
            return true;
        }
        else if (cursor.parentNode === null) {
            // TODO better ShadowRoot detection
            if (cursor.host == null) {
                return false;
            }
            else {
                cursor = cursor.host;
            }
        }
        else {
            cursor = cursor.parentNode;
        }
    }
}
/**
 * Returns `true` if pointer event originated on an element within Root.
 *
 * @since 5.2.8
 * @param  event   Event
 * @param  target  Target element
 */
function isLocalEvent(event, target) {
    return event.target && contains(target.root.dom, event.target);
}
/**
 * Disables or enables interactivity of a DOM element.
 *
 * @param  target       Target element
 * @param  interactive  Interactive?
 */
function setInteractive(target, interactive) {
    if (interactive) {
        target.style.pointerEvents = "auto";
    }
    else {
        target.style.pointerEvents = "none";
    }
}
/**
 * Returns the shadow root of the element or null
 *
 * @param a  Node
 * @return Root
 */
function getShadowRoot(a) {
    let cursor = a;
    while (true) {
        if (cursor.parentNode === null) {
            // TODO better ShadowRoot detection
            if (cursor.host != null) {
                return cursor;
            }
            else {
                return null;
            }
        }
        else {
            cursor = cursor.parentNode;
        }
    }
}
/**
 * [rootStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
let rootStylesheet;
/**
 * @ignore Exclude from docs
 */
function createStylesheet(element, text, nonce = "") {
    // TODO use createElementNS ?
    const e = document.createElement("style");
    e.type = "text/css";
    if (nonce != "") {
        e.setAttribute("nonce", nonce);
    }
    e.textContent = text;
    if (element === null) {
        document.head.appendChild(e);
    }
    else {
        element.appendChild(e);
    }
    return e;
}
/**
 * [getStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @return [description]
 */
function getStylesheet(element, nonce = "") {
    if (element === null) {
        if (rootStylesheet == null) {
            // TODO use createElementNS ?
            const e = document.createElement("style");
            e.type = "text/css";
            if (nonce != "") {
                e.setAttribute("nonce", nonce);
            }
            document.head.appendChild(e);
            rootStylesheet = e.sheet;
        }
        return rootStylesheet;
    }
    else {
        // TODO use createElementNS ?
        const e = document.createElement("style");
        e.type = "text/css";
        if (nonce != "") {
            e.setAttribute("nonce", nonce);
        }
        element.appendChild(e);
        return e.sheet;
    }
}
/**
 * [makeStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param selector  [description]
 * @return [description]
 */
function appendStylesheet(root, selector) {
    const index = root.cssRules.length;
    root.insertRule(selector + "{}", index);
    return root.cssRules[index];
}
/**
 * Defines a class for a CSS rule.
 *
 * Can be used to dynamically add CSS to the document.
 */
class StyleRule extends _Disposer__WEBPACK_IMPORTED_MODULE_3__["DisposerClass"] {
    /**
     * Constructor.
     *
     * @param selector  CSS selector
     * @param styles    An object of style attribute - value pairs
     */
    constructor(element, selector, styles, nonce = "") {
        super();
        Object.defineProperty(this, "_root", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * CSS rule.
         */
        Object.defineProperty(this, "_rule", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._root = getStylesheet(element, nonce);
        try {
            this._rule = appendStylesheet(this._root, selector);
            _Object__WEBPACK_IMPORTED_MODULE_2__["each"](styles, (key, value) => {
                this.setStyle(key, value);
            });
        }
        catch (err) {
            // Create an empty rule on failed selectors
            this._rule = new CSSStyleRule();
        }
    }
    /**
     * A CSS selector text.
     *
     * E.g.: `.myClass p`
     *
     * @param selector  CSS selector
     */
    set selector(selector) {
        this._rule.selectorText = selector;
    }
    /**
     * @return CSS selector
     */
    get selector() {
        return this._rule.selectorText;
    }
    // TODO test this
    _dispose() {
        // TODO a bit hacky
        const index = _Array__WEBPACK_IMPORTED_MODULE_1__["indexOf"](this._root.cssRules, this._rule);
        if (index === -1) {
            throw new Error("Could not dispose StyleRule");
        }
        else {
            // TODO if it's empty remove it from the DOM ?
            this._root.deleteRule(index);
        }
    }
    /**
     * Sets the same style properties with browser-specific prefixes.
     *
     * @param name   Attribute name
     * @param value  Attribute value
     */
    _setVendorPrefixName(name, value) {
        const style = this._rule.style;
        style.setProperty("-webkit-" + name, value, "");
        style.setProperty("-moz-" + name, value, "");
        style.setProperty("-ms-" + name, value, "");
        style.setProperty("-o-" + name, value, "");
        style.setProperty(name, value, "");
    }
    /**
     * Sets a value for specific style attribute.
     *
     * @param name   Attribute
     * @param value  Value
     */
    setStyle(name, value) {
        if (name === "transition") {
            this._setVendorPrefixName(name, value);
        }
        else {
            this._rule.style.setProperty(name, value, "");
        }
    }
}
/**
 * Defines a class for an entire CSS style sheet.
 *
 * Can be used to dynamically add CSS to the document.
 */
class StyleSheet extends _Disposer__WEBPACK_IMPORTED_MODULE_3__["DisposerClass"] {
    /**
     * Constructor.
     *
     * @param text  CSS stylesheet
     */
    constructor(element, text, nonce = "") {
        super();
        Object.defineProperty(this, "_element", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._element = createStylesheet(element, text, nonce);
    }
    _dispose() {
        if (this._element.parentNode) {
            this._element.parentNode.removeChild(this._element);
        }
    }
}
/**
 * Adds a class name to an HTML or SVG element.
 *
 * @ignore Exclude from docs
 * @param element    Element
 * @param className  Class name to add
 */
function addClass(element, className) {
    if (!element) {
        return;
    }
    if (element.classList) {
        const classes = className.split(" ");
        _Array__WEBPACK_IMPORTED_MODULE_1__["each"](classes, (name) => {
            element.classList.add(name);
        });
    }
    else {
        let currentClassName = element.getAttribute("class");
        if (currentClassName) {
            element.setAttribute("class", currentClassName.split(" ").filter((item) => {
                return item !== className;
            }).join(" ") + " " + className);
        }
        else {
            element.setAttribute("class", className);
        }
    }
}
/**
 * Removes a class name from an HTML or SVG element.
 *
 * @ignore Exclude from docs
 * @param element    Element
 * @param className  Class name to add
 */
function removeClass(element, className) {
    if (!element) {
        return;
    }
    if (element.classList) {
        element.classList.remove(className);
    }
    else {
        let currentClassName = element.getAttribute("class");
        if (currentClassName) {
            element.setAttribute("class", currentClassName.split(" ").filter((item) => {
                return item !== className;
            }).join(" "));
        }
    }
}
// /**
//  * Applies a set of styles to an element. Stores the original styles so they
//  * can be restored later.
//  *
//  * @ignore
//  * @param io      Element
//   */
// export function prepElementForDrag(dom: HTMLElement): void {
// 	// @todo: save current values
// 	// Define possible props
// 	let props = [
// 		"touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",
// 		"userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",
// 		"touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",
// 		"touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",
// 		"contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",
// 		"userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"
// 	];
// 	for (let i = 0; i < props.length; i++) {
// 		if (props[i] in dom.style) {
// 			setStyle(dom, props[i], "none");
// 		}
// 	}
// 	// Remove iOS-specific selection;
// 	setStyle(dom, "tapHighlightColor", "rgba(0, 0, 0, 0)");
// }
// /**
//  * Restores replaced styles
//  *
//  * @ignore
//  * @param  io  Element
//  */
// export function unprepElementForDrag(dom: HTMLElement): void {
// 	// Define possible props
// 	let props = [
// 		"touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",
// 		"userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",
// 		"touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",
// 		"touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",
// 		"contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",
// 		"userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"
// 	];
// 	for (let i = 0; i < props.length; i++) {
// 		if (props[i] in dom.style) {
// 			setStyle(dom, props[i], "");
// 		}
// 	}
// 	// Remove iOS-specific selection;
// 	setStyle(dom, "tapHighlightColor", "");
// }
function iOS() {
    return /apple/i.test(navigator.vendor) && "ontouchend" in document;
}
function getSafeResolution() {
    return iOS() ? 1 : undefined;
}
function relativeToValue(percent, full) {
    if (_Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"](percent)) {
        return percent;
    }
    else if (percent != null && _Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"](percent.value) && _Type__WEBPACK_IMPORTED_MODULE_0__["isNumber"](full)) {
        return full * percent.value;
    }
    else {
        return 0;
    }
}
/**
 * Returns number of decimals
 *
 * @ignore Exclude from docs
 * @param number  Input number
 * @return Number of decimals
 */
function decimalPlaces(number) {
    let match = ('' + number).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match) {
        return 0;
    }
    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
}
/**
 * ============================================================================
 * STRING FORMATTING FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Pads a string with additional characters to certain length.
 *
 * @param value  A numeric value
 * @param len    Result string length in characters
 * @param char   A character to use for padding
 * @return Padded value as string
 */
function padString(value, len = 0, char = "0") {
    if (typeof value !== "string") {
        value = value.toString();
    }
    return len > value.length ? Array(len - value.length + 1).join(char) + value : value;
}
function trimLeft(text) {
    return text.replace(/^[\s]*/, "");
}
function trimRight(text) {
    return text.replace(/[\s]*$/, "");
}
function trim(text) {
    return trimLeft(trimRight(text));
}
/**
 * Tries to determine format type.
 *
 * @ignore Exclude from docs
 * @param format  Format string
 * @return Format type ("string" | "number" | "date" | "duration")
 */
function getFormat(format) {
    // Undefined?
    if (typeof format === "undefined") {
        return "string";
    }
    // Cleanup and lowercase format
    format = format.toLowerCase().replace(/^\[[^\]]*\]/, "");
    // Remove style tags
    format = format.replace(/\[[^\]]+\]/, "");
    // Trim
    format = format.trim();
    // Check for any explicit format hints (i.e. /Date)
    let hints = format.match(/\/(date|number|duration)$/);
    if (hints) {
        return hints[1];
    }
    // Check for explicit hints
    if (format === "number") {
        return "number";
    }
    if (format === "date") {
        return "date";
    }
    if (format === "duration") {
        return "duration";
    }
    // Detect number formatting symbols
    if (format.match(/[#0]/)) {
        return "number";
    }
    // Detect date formatting symbols
    if (format.match(/[ymwdhnsqaxkzgtei]/)) {
        return "date";
    }
    // Nothing? Let's display as string
    return "string";
}
/**
 * Cleans up format:
 * * Strips out formatter hints
 *
 * @ignore Exclude from docs
 * @param format  Format
 * @return Cleaned format
 */
function cleanFormat(format) {
    return format.replace(/\/(date|number|duration)$/i, "");
}
/**
 * Strips all tags from the string.
 *
 * @param text  Source string
 * @return String without tags
 */
function stripTags(text) {
    return text ? text.replace(/<[^>]*>/g, "") : text;
}
/**
 * Removes new lines and tags from a string.
 *
 * @param text  String to conver
 * @return Converted string
 */
function plainText(text) {
    return text ? stripTags(("" + text).replace(/[\n\r]+/g, ". ")) : text;
}
/**
 * Escapes string so it can safely be used in a Regex.
 *
 * @param value  Unsescaped string
 * @return Escaped string
 */
function escapeForRgex(value) {
    return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
/**
 * Adds space before each uppercase letter.
 *
 * @param   str Input string
 * @return      Output string
 */
function addSpacing(str) {
    let result = "";
    for (let i = 0; i < str.length; i++) {
        const char = str.charAt(i);
        if (char.toUpperCase() == char && i != 0) {
            result += " ";
        }
        result += char;
    }
    return result;
}
/**
 * ============================================================================
 * DATE-RELATED FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Returns a year day.
 *
 * @param date  Date
 * @param utc   Assume UTC dates?
 * @return Year day
 * @todo Account for UTC
 */
function getYearDay(date, utc = false) {
    // TODO: utc needed?
    utc;
    const start = new Date(date.getFullYear(), 0, 0);
    const diff = (date.getTime() - start.getTime()) + ((start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000);
    const oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
}
/**
 * Returns week number for a given date.
 *
 * @param date  Date
 * @param utc   Assume UTC dates?
 * @return Week number
 * @todo Account for UTC
 */
function getWeek(date, _utc = false) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const day = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - day);
    const firstDay = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return Math.ceil((((d.getTime() - firstDay.getTime()) / 86400000) + 1) / 7);
}
/**
 * Returns a "week year" of the given date.
 *
 * @param date  Date
 * @param utc   Assume UTC dates?
 * @return Year of week
 * @since 5.3.0
 * @todo Account for UTC
 */
function getWeekYear(date, _utc = false) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const day = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - day);
    const firstDay = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return firstDay.getFullYear();
}
/**
 * Returns a week number in the month.
 *
 * @param date  Source Date
 * @param utc   Assume UTC dates?
 * @return Week number in month
 */
function getMonthWeek(date, utc = false) {
    const firstWeek = getWeek(new Date(date.getFullYear(), date.getMonth(), 1), utc);
    let currentWeek = getWeek(date, utc);
    if (currentWeek == 1) {
        currentWeek = 53;
    }
    return currentWeek - firstWeek + 1;
}
/**
 * Returns a year day out of the given week number.
 *
 * @param week     Week
 * @param year     Year
 * @param weekday  Weekday
 * @param utc      Assume UTC dates
 * @return Day in a year
 */
function getDayFromWeek(week, year, weekday = 1, utc = false) {
    let date = new Date(year, 0, 4, 0, 0, 0, 0);
    if (utc) {
        date.setUTCFullYear(year);
    }
    let day = week * 7 + weekday - ((date.getDay() || 7) + 3);
    return day;
}
/**
 * Returns 12-hour representation out of the 24-hour hours.
 *
 * @param hours  24-hour number
 * @return 12-hour number
 */
function get12Hours(hours, base) {
    if (hours > 12) {
        hours -= 12;
    }
    else if (hours === 0) {
        hours = 12;
    }
    return base != null ? hours + (base - 1) : hours;
}
/**
 * Returns a string name of the time zone.
 *
 * @param date     Date object
 * @param long     Should return long ("Pacific Standard Time") or short abbreviation ("PST")
 * @param savings  Include information if it's in daylight savings mode
 * @param utc      Assume UTC dates
 * @return Time zone name
 */
function getTimeZone(date, long = false, savings = false, utc = false) {
    if (utc) {
        return long ? "Coordinated Universal Time" : "UTC";
    }
    let wotz = date.toLocaleString("UTC");
    let wtz = date.toLocaleString("UTC", { timeZoneName: long ? "long" : "short" }).substr(wotz.length);
    //wtz = wtz.replace(/[+-]+[0-9]+$/, "");
    if (savings === false) {
        wtz = wtz.replace(/ (standard|daylight|summer|winter) /i, " ");
    }
    return wtz;
}
function getTimezoneOffset(timezone) {
    const date = new Date(Date.UTC(2012, 0, 1, 0, 0, 0, 0));
    const utcDate = new Date(date.toLocaleString('en-US', { timeZone: 'UTC' }));
    const tzDate = new Date(date.toLocaleString('en-US', { timeZone: timezone }));
    return (tzDate.getTime() - utcDate.getTime()) / 6e4 * -1;
}
function capitalizeFirst(text) {
    return text.charAt(0).toUpperCase() + text.slice(1);
}
/**
 * The functions below are taken and adapted from Garry Tan's blog post:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * The further attributions go mjijackson.com, which now seems to be defunct.
 */
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * Function adapted from:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * @ignore Exclude from docs
 * @param h       The hue
 * @param s       The saturation
 * @param l       The lightness
 * @return The RGB representation
 */
function hslToRgb(color) {
    let r, g, b;
    let h = color.h;
    let s = color.s;
    let l = color.l;
    if (s == 0) {
        r = g = b = l; // achromatic
    }
    else {
        let hue2rgb = function hue2rgb(p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        };
        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}
/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * Function adapted from:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * @ignore Exclude from docs
 * @param r       The red color value
 * @param g       The green color value
 * @param b       The blue color value
 * @return The HSL representation
 */
function rgbToHsl(color) {
    let r = color.r / 255;
    let g = color.g / 255;
    let b = color.b / 255;
    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    let l = (max + min) / 2;
    if (max === min) {
        h = s = 0; // achromatic
    }
    else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return {
        h: h,
        s: s,
        l: l
    };
}
/**
 * Returns a color that is `percent` brighter than the reference color.
 *
 * @ignore Exclude from docs
 * @param color    Reference color
 * @param percent  Brightness percent
 * @return Hex code of the new color
 */
function lighten(rgb, percent) {
    if (rgb) {
        return {
            r: Math.max(0, Math.min(255, rgb.r + getLightnessStep(rgb.r, percent))),
            g: Math.max(0, Math.min(255, rgb.g + getLightnessStep(rgb.g, percent))),
            b: Math.max(0, Math.min(255, rgb.b + getLightnessStep(rgb.b, percent))),
            a: rgb.a
        };
    }
    else {
        // TODO is this correct ?
        return rgb;
    }
}
;
/**
 * Gets lightness step.
 *
 * @ignore Exclude from docs
 * @param value    Value
 * @param percent  Percent
 * @return Step
 */
function getLightnessStep(value, percent) {
    let base = percent > 0 ? 255 - value : value;
    return Math.round(base * percent);
}
/**
 * Returns a color that is `percent` brighter than the source `color`.
 *
 * @ignore Exclude from docs
 * @param color    Source color
 * @param percent  Brightness percent
 * @return New color
 */
function brighten(rgb, percent) {
    if (rgb) {
        let base = Math.min(Math.max(rgb.r, rgb.g, rgb.b), 230);
        //let base = Math.max(rgb.r, rgb.g, rgb.b);
        let step = getLightnessStep(base, percent);
        return {
            r: Math.max(0, Math.min(255, Math.round(rgb.r + step))),
            g: Math.max(0, Math.min(255, Math.round(rgb.g + step))),
            b: Math.max(0, Math.min(255, Math.round(rgb.b + step))),
            a: rgb.a
        };
    }
    else {
        // TODO is this correct ?
        return rgb;
    }
}
;
/**
 * Returns brightness step.
 *
 * @ignore Exclude from docs
 * @param value    Value
 * @param percent  Percent
 * @return Step
 */
function getBrightnessStep(_value, percent) {
    let base = 255; //percent > 0 ? 255 - value : value;
    return Math.round(base * percent);
}
/**
 * Returns `true` if color is "light". Useful indetermining which contrasting
 * color to use for elements over this color. E.g.: you would want to use
 * black text over light background, and vice versa.
 *
 * @ignore Exclude from docs
 * @param color  Source color
 * @return Light?
 */
function isLight(color) {
    return ((color.r * 299) + (color.g * 587) + (color.b * 114)) / 1000 >= 128;
}
/**
 * Returns a new [[iRGB]] object based on `rgb` parameter with specific
 * saturation applied.
 *
 * `saturation` can be in the range of 0 (fully desaturated) to 1 (fully
 * saturated).
 *
 * @ignore Exclude from docs
 * @param color       Base color
 * @param saturation  Saturation (0-1)
 * @return New color
 */
function saturate(rgb, saturation) {
    if (rgb === undefined || saturation == 1) {
        return rgb;
    }
    let hsl = rgbToHsl(rgb);
    hsl.s = saturation;
    return hslToRgb(hsl);
}
function alternativeColor(color, lightAlternative = { r: 255, g: 255, b: 255 }, darkAlternative = { r: 255, g: 255, b: 255 }) {
    let light = lightAlternative;
    let dark = darkAlternative;
    if (isLight(darkAlternative)) {
        light = darkAlternative;
        dark = lightAlternative;
    }
    return isLight(color) ? dark : light;
}
/**
 * @ignore
 * @deprecated
 */
// export function unshiftThemeClass(settings: any, themeClass: string) {
// 	let themeClasses = settings.themeClasses;
// 	if (!themeClasses) {
// 		themeClasses = [];
// 	}
// 	themeClasses.unshift(themeClass);
// 	settings.themeClasses = themeClasses;
// }
/**
 * @ignore
 * @deprecated
 */
// export function pushThemeClass(settings: any, themeClass: string) {
// 	let themeClasses = settings.themeClasses;
// 	if (!themeClasses) {
// 		themeClasses = [];
// 	}
// 	themeClasses.push(themeClass);
// 	settings.themeClasses = themeClasses;
// }
/**
 * @ignore
 */
function mergeTags(tags1, tags2) {
    if (!tags1) {
        tags1 = [];
    }
    return [...tags1, ...tags2].filter((value, index, self) => {
        return self.indexOf(value) === index;
    });
}
/**
 * @ignore
 */
function sameBounds(a, b) {
    if (!b) {
        return false;
    }
    if (a.left != b.left) {
        return false;
    }
    if (a.right != b.right) {
        return false;
    }
    if (a.top != b.top) {
        return false;
    }
    if (a.bottom != b.bottom) {
        return false;
    }
    return true;
}
//# sourceMappingURL=Utils.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/themes/AnimatedTheme.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/themes/AnimatedTheme.js ***!
  \****************************************************************************/
/*! exports provided: AnimatedTheme */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimatedTheme", function() { return AnimatedTheme; });
/* harmony import */ var _core_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Theme */ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js");

/**
 * @ignore
 */
class AnimatedTheme extends _core_Theme__WEBPACK_IMPORTED_MODULE_0__["Theme"] {
    setupDefaultRules() {
        super.setupDefaultRules();
        this.rule("Component").setAll({
            interpolationDuration: 600
        });
        this.rule("Hierarchy").set("animationDuration", 600);
        this.rule("Scrollbar").set("animationDuration", 600);
        this.rule("Tooltip").set("animationDuration", 300);
        this.rule("MapChart").set("animationDuration", 1000);
        this.rule("MapChart").set("wheelDuration", 300);
        this.rule("Entity").setAll({
            stateAnimationDuration: 600
        });
        this.rule("Sprite").states.create("default", { stateAnimationDuration: 600 });
        this.rule("Tooltip", ["axis"]).setAll({
            animationDuration: 200
        });
        this.rule("WordCloud").set("animationDuration", 500);
    }
}
//# sourceMappingURL=AnimatedTheme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js ***!
  \***************************************************************************/
/*! exports provided: setColor, DefaultTheme */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setColor", function() { return setColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultTheme", function() { return DefaultTheme; });
/* harmony import */ var _core_Theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Theme */ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js");
/* harmony import */ var _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony import */ var _core_util_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony import */ var _core_render_GridLayout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/render/GridLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js");
/* harmony import */ var _core_util_Ease__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/util/Ease */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js");





/**
 * @ignore
 */
function setColor(rule, key, ic, name) {
    // TODO this shouldn't use get, figure out a better way
    rule.set(key, ic.get(name));
    ic.on(name, (value) => {
        rule.set(key, value);
    });
}
/**
 * @ignore
 */
class DefaultTheme extends _core_Theme__WEBPACK_IMPORTED_MODULE_0__["Theme"] {
    setupDefaultRules() {
        super.setupDefaultRules();
        const language = this._root.language;
        const ic = this._root.interfaceColors;
        const horizontalLayout = this._root.horizontalLayout;
        const verticalLayout = this._root.verticalLayout;
        const r = this.rule.bind(this);
        /**
         * ========================================================================
         * core
         * ========================================================================
         */
        r("InterfaceColors").setAll({
            stroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xe5e5e5),
            fill: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xf3f3f3),
            primaryButton: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x6794dc),
            primaryButtonHover: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x6771dc),
            primaryButtonDown: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x68dc76),
            primaryButtonActive: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x68dc76),
            primaryButtonText: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xffffff),
            primaryButtonStroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xffffff),
            secondaryButton: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xd9d9d9),
            secondaryButtonHover: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xa3a3a3),
            secondaryButtonDown: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x8d8d8d),
            secondaryButtonActive: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xe6e6e6),
            secondaryButtonText: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x000000),
            secondaryButtonStroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xffffff),
            grid: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x000000),
            background: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xffffff),
            alternativeBackground: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x000000),
            text: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x000000),
            alternativeText: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xffffff),
            disabled: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xadadad),
            positive: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x50b300),
            negative: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xb30000)
        });
        {
            const rule = r("ColorSet");
            rule.setAll({
                passOptions: {
                    hue: 0.05,
                    saturation: 0,
                    lightness: 0
                },
                colors: [
                    _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0x67b7dc)
                ],
                step: 1,
                //baseColor: Color.fromRGB(103, 183, 220),
                //count: 20,
                reuse: false,
                startIndex: 0
            });
            rule.setPrivate("currentStep", 0);
            rule.setPrivate("currentPass", 0);
        }
        r("Entity").setAll({
            stateAnimationDuration: 0,
            stateAnimationEasing: _core_util_Ease__WEBPACK_IMPORTED_MODULE_4__["out"](_core_util_Ease__WEBPACK_IMPORTED_MODULE_4__["cubic"])
        });
        r("Component").setAll({
            interpolationDuration: 0,
            interpolationEasing: _core_util_Ease__WEBPACK_IMPORTED_MODULE_4__["out"](_core_util_Ease__WEBPACK_IMPORTED_MODULE_4__["cubic"])
        });
        r("Sprite").setAll({
            visible: true,
            scale: 1,
            opacity: 1,
            rotation: 0,
            position: "relative",
            tooltipX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            tooltipY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            tooltipPosition: "fixed",
            isMeasured: true
        });
        r("Sprite").states.create("default", { "visible": true, opacity: 1 });
        r("Container").setAll({
            interactiveChildren: true,
            setStateOnChildren: false
        });
        r("Graphics").setAll({
            strokeWidth: 1
        });
        r("Chart").setAll({
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            interactiveChildren: false
        });
        /**
         * ------------------------------------------------------------------------
         * core: alignment
         * ------------------------------------------------------------------------
         */
        r("Sprite", ["horizontal", "center"]).setAll({
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            x: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"]
        });
        r("Sprite", ["vertical", "center"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            y: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"]
        });
        r("Container", ["horizontal", "layout"]).setAll({
            layout: horizontalLayout
        });
        r("Container", ["vertical", "layout"]).setAll({
            layout: verticalLayout
        });
        /**
         * ------------------------------------------------------------------------
         * core: patterns
         * ------------------------------------------------------------------------
         */
        r("Pattern").setAll({
            repetition: "repeat",
            width: 50,
            height: 50,
            rotation: 0,
            fillOpacity: 1
        });
        r("LinePattern").setAll({
            gap: 6,
            colorOpacity: 1,
            width: 49,
            height: 49
        });
        r("RectanglePattern").setAll({
            gap: 6,
            checkered: false,
            centered: true,
            maxWidth: 5,
            maxHeight: 5,
            width: 48,
            height: 48,
            strokeWidth: 0
        });
        r("CirclePattern").setAll({
            gap: 5,
            checkered: false,
            centered: false,
            radius: 3,
            strokeWidth: 0,
            width: 45,
            height: 45
        });
        /**
         * ------------------------------------------------------------------------
         * core: gradients
         * ------------------------------------------------------------------------
         */
        r("LinearGradient").setAll({
            rotation: 90
        });
        /**
         * ------------------------------------------------------------------------
         * core: Legend
         * ------------------------------------------------------------------------
         */
        r("Legend").setAll({
            fillField: "fill",
            strokeField: "stroke",
            nameField: "name",
            layout: _core_render_GridLayout__WEBPACK_IMPORTED_MODULE_3__["GridLayout"].new(this._root, {}),
            layer: 30,
            clickTarget: "itemContainer"
        });
        // Class: Container
        r("Container", ["legend", "item", "itemcontainer"]).setAll({
            paddingLeft: 5,
            paddingRight: 5,
            paddingBottom: 5,
            paddingTop: 5,
            layout: horizontalLayout,
            setStateOnChildren: true,
            interactiveChildren: false,
            ariaChecked: true,
            focusable: true,
            ariaLabel: language.translate("Press ENTER to toggle"),
            role: "checkbox"
        });
        {
            const rule = r("Rectangle", ["legend", "item", "background"]);
            rule.setAll({
                fillOpacity: 0,
            });
            setColor(rule, "fill", ic, "background");
        }
        r("Container", ["legend", "marker"]).setAll({
            setStateOnChildren: true,
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            paddingLeft: 0,
            paddingRight: 0,
            paddingBottom: 0,
            paddingTop: 0,
            width: 18,
            height: 18
        });
        r("RoundedRectangle", ["legend", "marker", "rectangle"]).setAll({
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            cornerRadiusBL: 3,
            cornerRadiusTL: 3,
            cornerRadiusBR: 3,
            cornerRadiusTR: 3
        });
        {
            const rule = r("RoundedRectangle", ["legend", "marker", "rectangle"]).states.create("disabled", {});
            setColor(rule, "fill", ic, "disabled");
            setColor(rule, "stroke", ic, "disabled");
        }
        r("Label", ["legend", "label"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            marginLeft: 5,
            paddingRight: 0,
            paddingLeft: 0,
            paddingTop: 0,
            paddingBottom: 0,
            populateText: true
        });
        {
            const rule = r("Label", ["legend", "label"]).states.create("disabled", {});
            setColor(rule, "fill", ic, "disabled");
        }
        r("Label", ["legend", "value", "label"]).setAll({
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            marginLeft: 5,
            paddingRight: 0,
            paddingLeft: 0,
            paddingTop: 0,
            paddingBottom: 0,
            width: 50,
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            populateText: true
        });
        {
            const rule = r("Label", ["legend", "value", "label"]).states.create("disabled", {});
            setColor(rule, "fill", ic, "disabled");
        }
        /**
         * ------------------------------------------------------------------------
         * core: HeatLegend
         * ------------------------------------------------------------------------
         */
        r("HeatLegend").setAll({
            stepCount: 1
        });
        r("RoundedRectangle", ["heatlegend", "marker"]).setAll({
            cornerRadiusTR: 0,
            cornerRadiusBR: 0,
            cornerRadiusTL: 0,
            cornerRadiusBL: 0
        });
        r("RoundedRectangle", ["vertical", "heatlegend", "marker"]).setAll({
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            width: 15
        });
        r("RoundedRectangle", ["horizontal", "heatlegend", "marker"]).setAll({
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            height: 15
        });
        r("HeatLegend", ["vertical"]).setAll({
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]
        });
        r("HeatLegend", ["horizontal"]).setAll({
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]
        });
        r("Label", ["heatlegend", "start"]).setAll({
            paddingLeft: 5,
            paddingRight: 5,
            paddingTop: 5,
            paddingBottom: 5
        });
        r("Label", ["heatlegend", "end"]).setAll({
            paddingLeft: 5,
            paddingRight: 5,
            paddingTop: 5,
            paddingBottom: 5
        });
        /**
         * ------------------------------------------------------------------------
         * core: Labels
         * ------------------------------------------------------------------------
         */
        {
            const rule = r("Label");
            rule.setAll({
                paddingTop: 8,
                paddingBottom: 8,
                paddingLeft: 10,
                paddingRight: 10,
                fontFamily: "-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"",
                fontSize: "1em",
                populateText: false
            });
            setColor(rule, "fill", ic, "text");
        }
        r("RadialLabel").setAll({
            textType: "regular",
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            inside: false,
            radius: 0,
            baseRadius: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            orientation: "auto",
            textAlign: "center"
        });
        /**
         * ------------------------------------------------------------------------
         * core: Elements and shapes
         * ------------------------------------------------------------------------
         */
        r("RoundedRectangle").setAll({
            cornerRadiusTL: 8,
            cornerRadiusBL: 8,
            cornerRadiusTR: 8,
            cornerRadiusBR: 8
        });
        r("PointedRectangle").setAll({
            pointerBaseWidth: 15,
            pointerLength: 10,
            cornerRadius: 8
        });
        r("Slice").setAll({
            shiftRadius: 0,
            dRadius: 0,
            dInnerRadius: 0
        });
        {
            const rule = r("Tick");
            rule.setAll({
                strokeOpacity: .15,
                isMeasured: false,
                length: 4.5,
                position: "absolute",
                crisp: true
            });
            setColor(rule, "stroke", ic, "grid");
        }
        r("Bullet").setAll({
            locationX: 0.5,
            locationY: 0.5
        });
        /**
         * ------------------------------------------------------------------------
         * core: Tooltip
         * ------------------------------------------------------------------------
         */
        r("Tooltip").setAll({
            position: "absolute",
            getFillFromSprite: true,
            getStrokeFromSprite: false,
            autoTextColor: true,
            paddingTop: 9,
            paddingBottom: 8,
            paddingLeft: 10,
            paddingRight: 10,
            marginBottom: 5,
            pointerOrientation: "vertical",
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            animationEasing: _core_util_Ease__WEBPACK_IMPORTED_MODULE_4__["out"](_core_util_Ease__WEBPACK_IMPORTED_MODULE_4__["cubic"]),
            exportable: false
            //layer: 100
        });
        {
            const rule = r("PointedRectangle", ["tooltip", "background"]);
            rule.setAll({
                strokeOpacity: 0.9,
                cornerRadius: 4,
                pointerLength: 4,
                pointerBaseWidth: 8,
                fillOpacity: 0.9,
                stroke: _core_util_Color__WEBPACK_IMPORTED_MODULE_2__["Color"].fromHex(0xffffff)
            });
        }
        {
            const rule = r("Label", ["tooltip"]);
            rule.setAll({
                role: "tooltip",
                populateText: true,
                paddingRight: 0,
                paddingTop: 0,
                paddingLeft: 0,
                paddingBottom: 0
            });
            setColor(rule, "fill", ic, "alternativeText");
        }
        /**
         * ------------------------------------------------------------------------
         * core: Button
         * ------------------------------------------------------------------------
         */
        r("Button").setAll({
            paddingTop: 8,
            paddingBottom: 8,
            paddingLeft: 10,
            paddingRight: 10,
            interactive: true,
            layout: horizontalLayout,
            interactiveChildren: false,
            setStateOnChildren: true,
            focusable: true
        });
        r("Button").states.create("hover", {});
        r("Button").states.create("down", { stateAnimationDuration: 0 });
        r("Button").states.create("active", {});
        {
            const rule = r("RoundedRectangle", ["button", "background"]);
            setColor(rule, "fill", ic, "primaryButton");
            setColor(rule, "stroke", ic, "primaryButtonStroke");
        }
        {
            const rule = r("RoundedRectangle", ["button", "background"]).states.create("hover", {});
            setColor(rule, "fill", ic, "primaryButtonHover");
        }
        {
            const rule = r("RoundedRectangle", ["button", "background"]).states.create("down", { stateAnimationDuration: 0 });
            setColor(rule, "fill", ic, "primaryButtonDown");
        }
        {
            const rule = r("RoundedRectangle", ["button", "background"]).states.create("active", {});
            setColor(rule, "fill", ic, "primaryButtonActive");
        }
        {
            const rule = r("Graphics", ["button", "icon"]);
            setColor(rule, "stroke", ic, "primaryButtonText");
        }
        {
            const rule = r("Label", ["button"]);
            setColor(rule, "fill", ic, "primaryButtonText");
        }
        /**
         * ------------------------------------------------------------------------
         * charts/xy: ZoomOutButton
         * ------------------------------------------------------------------------
         */
        r("Button", ["zoom"]).setAll({
            paddingTop: 18,
            paddingBottom: 18,
            paddingLeft: 12,
            paddingRight: 12,
            centerX: 46,
            centerY: -10,
            y: 0,
            x: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            role: "button",
            ariaLabel: language.translate("Zoom Out"),
            layer: 30
        });
        {
            const rule = r("RoundedRectangle", ["background", "button", "zoom"]);
            rule.setAll({
                cornerRadiusBL: 40,
                cornerRadiusBR: 40,
                cornerRadiusTL: 40,
                cornerRadiusTR: 40
            });
            setColor(rule, "fill", ic, "primaryButton");
        }
        {
            const rule = r("RoundedRectangle", ["background", "button", "zoom"]).states.create("hover", {});
            setColor(rule, "fill", ic, "primaryButtonHover");
        }
        {
            const rule = r("RoundedRectangle", ["background", "button", "zoom"]).states.create("down", { stateAnimationDuration: 0 });
            setColor(rule, "fill", ic, "primaryButtonDown");
        }
        {
            const rule = r("Graphics", ["icon", "button", "zoom"]);
            rule.setAll({
                crisp: true,
                strokeOpacity: 0.7,
                draw: (display) => {
                    display.moveTo(0, 0);
                    display.lineTo(12, 0);
                }
            });
            setColor(rule, "stroke", ic, "primaryButtonText");
        }
        /**
         * ------------------------------------------------------------------------
         * core: ResizeButton
         * ------------------------------------------------------------------------
         */
        r("Button", ["resize"]).setAll({
            paddingTop: 9,
            paddingBottom: 9,
            paddingLeft: 13,
            paddingRight: 13,
            draggable: true,
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            position: "absolute",
            role: "slider",
            ariaValueMin: "0",
            ariaValueMax: "100",
            ariaLabel: language.translate("Use up and down arrows to move selection")
        });
        {
            const rule = r("RoundedRectangle", ["background", "resize", "button"]);
            rule.setAll({
                cornerRadiusBL: 40,
                cornerRadiusBR: 40,
                cornerRadiusTL: 40,
                cornerRadiusTR: 40
            });
            setColor(rule, "fill", ic, "secondaryButton");
            setColor(rule, "stroke", ic, "secondaryButtonStroke");
        }
        {
            const rule = r("RoundedRectangle", ["background", "resize", "button"]).states.create("hover", {});
            setColor(rule, "fill", ic, "secondaryButtonHover");
        }
        {
            const rule = r("RoundedRectangle", ["background", "resize", "button"]).states.create("down", { stateAnimationDuration: 0 });
            setColor(rule, "fill", ic, "secondaryButtonDown");
        }
        {
            const rule = r("Graphics", ["resize", "button", "icon"]);
            rule.setAll({
                interactive: false,
                crisp: true,
                strokeOpacity: 0.5,
                draw: (display) => {
                    display.moveTo(0, 0.5);
                    display.lineTo(0, 12.5);
                    display.moveTo(4, 0.5);
                    display.lineTo(4, 12.5);
                }
            });
            setColor(rule, "stroke", ic, "secondaryButtonText");
        }
        r("Button", ["resize", "vertical"]).setAll({
            rotation: 90,
            cursorOverStyle: "ns-resize"
        });
        r("Button", ["resize", "horizontal"]).setAll({
            cursorOverStyle: "ew-resize"
        });
        /**
         * ------------------------------------------------------------------------
         * core: PlayButton
         * ------------------------------------------------------------------------
         */
        r("Button", ["play"]).setAll({
            paddingTop: 13,
            paddingBottom: 13,
            paddingLeft: 14,
            paddingRight: 14,
            ariaLabel: language.translate("Play"),
            toggleKey: "active"
        });
        {
            const rule = r("RoundedRectangle", ["play", "background"]);
            rule.setAll({
                strokeOpacity: 0.5,
                cornerRadiusBL: 100,
                cornerRadiusBR: 100,
                cornerRadiusTL: 100,
                cornerRadiusTR: 100
            });
            setColor(rule, "fill", ic, "primaryButton");
        }
        {
            const rule = r("Graphics", ["play", "icon"]);
            rule.setAll({
                stateAnimationDuration: 0,
                dx: 1,
                draw: (display) => {
                    display.moveTo(0, -5);
                    display.lineTo(8, 0);
                    display.lineTo(0, 5);
                    display.lineTo(0, -5);
                }
            });
            setColor(rule, "fill", ic, "primaryButtonText");
        }
        r("Graphics", ["play", "icon"]).states.create("default", {
            stateAnimationDuration: 0
        });
        r("Graphics", ["play", "icon"]).states.create("active", {
            stateAnimationDuration: 0,
            draw: (display) => {
                display.moveTo(-4, -5);
                display.lineTo(-1, -5);
                display.lineTo(-1, 5);
                display.lineTo(-4, 5);
                display.lineTo(-4, -5);
                display.moveTo(4, -5);
                display.lineTo(1, -5);
                display.lineTo(1, 5);
                display.lineTo(4, 5);
                display.lineTo(4, -5);
            }
        });
        /**
         * ------------------------------------------------------------------------
         * core: SwitchButton
         * ------------------------------------------------------------------------
         */
        r("Button", ["switch"]).setAll({
            paddingTop: 4,
            paddingBottom: 4,
            paddingLeft: 4,
            paddingRight: 4,
            ariaLabel: language.translate("Press ENTER to toggle"),
            toggleKey: "active",
            width: 40,
            height: 24,
            layout: null
        });
        {
            const rule = r("RoundedRectangle", ["switch", "background"]);
            rule.setAll({
                strokeOpacity: 0.5,
                cornerRadiusBL: 100,
                cornerRadiusBR: 100,
                cornerRadiusTL: 100,
                cornerRadiusTR: 100
            });
            setColor(rule, "fill", ic, "primaryButton");
        }
        {
            const rule = r("Circle", ["switch", "icon"]);
            rule.setAll({
                radius: 8,
                centerY: 0,
                centerX: 0,
                dx: 0
            });
            setColor(rule, "fill", ic, "primaryButtonText");
        }
        r("Graphics", ["switch", "icon"]).states.create("active", {
            dx: 16
        });
        /**
         * ------------------------------------------------------------------------
         * core: Scrollbar
         * ------------------------------------------------------------------------
         */
        r("Scrollbar").setAll({
            start: 0,
            end: 1,
            layer: 30,
            animationEasing: _core_util_Ease__WEBPACK_IMPORTED_MODULE_4__["out"](_core_util_Ease__WEBPACK_IMPORTED_MODULE_4__["cubic"])
        });
        r("Scrollbar", ["vertical"]).setAll({
            marginRight: 13,
            marginLeft: 13,
            minWidth: 12,
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]
        });
        r("Scrollbar", ["horizontal"]).setAll({
            marginTop: 13,
            marginBottom: 13,
            minHeight: 12,
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"]
        });
        this.rule("Button", ["scrollbar"]).setAll({
            exportable: false
        });
        {
            const rule = r("RoundedRectangle", ["scrollbar", "main", "background"]);
            rule.setAll({
                cornerRadiusTL: 8,
                cornerRadiusBL: 8,
                cornerRadiusTR: 8,
                cornerRadiusBR: 8,
                fillOpacity: 0.8,
            });
            setColor(rule, "fill", ic, "fill");
        }
        {
            const rule = r("RoundedRectangle", ["scrollbar", "thumb"]);
            rule.setAll({
                role: "slider",
                ariaLive: "polite",
                position: "absolute",
                draggable: true
            });
            setColor(rule, "fill", ic, "secondaryButton");
        }
        {
            const rule = r("RoundedRectangle", ["scrollbar", "thumb"]).states.create("hover", {});
            setColor(rule, "fill", ic, "secondaryButtonHover");
        }
        {
            const rule = r("RoundedRectangle", ["scrollbar", "thumb"]).states.create("down", { stateAnimationDuration: 0 });
            setColor(rule, "fill", ic, "secondaryButtonDown");
        }
        r("RoundedRectangle", ["scrollbar", "thumb", "vertical"]).setAll({
            x: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            width: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            centerX: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            ariaLabel: language.translate("Use up and down arrows to move selection")
        });
        r("RoundedRectangle", ["scrollbar", "thumb", "horizontal"]).setAll({
            y: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            centerY: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p50"],
            height: _core_util_Percent__WEBPACK_IMPORTED_MODULE_1__["p100"],
            ariaLabel: language.translate("Use left and right arrows to move selection")
        });
        // @todo: is this needed? used to be "ContentScrollbar"
        // r("Scrollbar", ["content?"]).setAll({
        // 	marginRight: 0,
        // 	marginLeft: 5,
        // 	layer: 5
        // });
        /**
         * ========================================================================
         * charts/xy
         * ========================================================================
         *
         * This needs to be in DefaultTheme because it's the only theme that is
         * automatically applied to Root, and tooltips different ancestors
         * than actual charts using them.
         */
        {
            const rule = r("PointedRectangle", ["axis", "tooltip", "background"]);
            rule.setAll({
                cornerRadius: 0
            });
            setColor(rule, "fill", ic, "alternativeBackground");
        }
        r("Label", ["axis", "tooltip"]).setAll({
            role: undefined
        });
        r("Label", ["axis", "tooltip", "y"]).setAll({
            textAlign: "right"
        });
        r("Label", ["axis", "tooltip", "y", "opposite"]).setAll({
            textAlign: "left"
        });
        r("Label", ["axis", "tooltip", "x"]).setAll({
            textAlign: "center"
        });
        r("Tooltip", ["categoryaxis"]).setAll({
            labelText: "{category}"
        });
        /**
         * ------------------------------------------------------------------------
         * Shapes
         * ------------------------------------------------------------------------
         */
        // Class: Graphics
        r("Star").setAll({
            spikes: 5,
            innerRadius: 5,
            radius: 10
        });
        // STOCK
        r("Tooltip", ["stock"]).setAll({
            paddingTop: 6,
            paddingBottom: 5,
            paddingLeft: 7,
            paddingRight: 7
        });
        r("PointedRectangle", ["tooltip", "stock", "axis"]).setAll({
            pointerLength: 0,
            pointerBaseWidth: 0,
            cornerRadius: 3
        });
        r("Label", ["tooltip", "stock"]).setAll({
            fontSize: "0.8em"
        });
        // resizer
        r("SpriteResizer").setAll({
            rotationStep: 10
        });
        {
            const rule = r("Container", ["resizer", "grip"]);
            rule.states.create("hover", {});
        }
        {
            const rule = r("RoundedRectangle", ["resizer", "grip"]);
            rule.setAll({
                strokeOpacity: 0.7,
                strokeWidth: 1,
                fillOpacity: 1,
                width: 12,
                height: 12
            });
            setColor(rule, "fill", ic, "background");
            setColor(rule, "stroke", ic, "alternativeBackground");
        }
        {
            const rule = r("RoundedRectangle", ["resizer", "grip", "outline"]);
            rule.setAll({
                strokeOpacity: 0,
                fillOpacity: 0,
                width: 20,
                height: 20
            });
            rule.states.create("hover", {
                fillOpacity: 0.3
            });
            setColor(rule, "fill", ic, "alternativeBackground");
        }
        r("RoundedRectangle", ["resizer", "grip", "left"]).setAll({
            cornerRadiusBL: 0,
            cornerRadiusBR: 0,
            cornerRadiusTL: 0,
            cornerRadiusTR: 0
        });
        r("RoundedRectangle", ["resizer", "grip", "right"]).setAll({
            cornerRadiusBL: 0,
            cornerRadiusBR: 0,
            cornerRadiusTL: 0,
            cornerRadiusTR: 0
        });
        {
            const rule = r("Rectangle", ["resizer", "rectangle"]);
            rule.setAll({
                strokeDasharray: [2, 2],
                strokeOpacity: 0.5,
                strokeWidth: 1
            });
            setColor(rule, "stroke", ic, "alternativeBackground");
        }
    }
}
//# sourceMappingURL=DefaultTheme.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/index.js ***!
  \***************************************************/
/*! exports provided: Root, Theme, addLicense, registry, disposeAllRootElements, ready, Modal, Entity, Disposer, ArrayDisposer, MultiDisposer, MutableValueDisposer, CounterDisposer, Bullet, Button, Circle, Ellipse, Star, Component, DataItem, Container, Graphics, GridLayout, HeatLegend, HorizontalLayout, Label, Layout, Legend, Line, Picture, PointedRectangle, RadialLabel, RadialText, Rectangle, Triangle, RoundedRectangle, Scrollbar, Slider, Slice, Sprite, Series, Chart, SerialChart, Text, Tick, Tooltip, VerticalLayout, Timezone, Gradient, LinearGradient, RadialGradient, CirclePattern, LinePattern, Pattern, PicturePattern, RectanglePattern, PathPattern, Color, color, ColorSet, ListData, JsonData, JSONParser, CSVParser, DataProcessor, DateFormatter, DurationFormatter, InterfaceColors, NumberFormatter, Percent, percent, p100, p50, p0, Template, TextFormatter, SpriteResizer, array, ease, math, net, object, time, type, utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_core_Root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.internal/core/Root */ "./node_modules/@amcharts/amcharts5/.internal/core/Root.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Root", function() { return _internal_core_Root__WEBPACK_IMPORTED_MODULE_0__["Root"]; });

/* harmony import */ var _internal_core_Theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.internal/core/Theme */ "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Theme", function() { return _internal_core_Theme__WEBPACK_IMPORTED_MODULE_1__["Theme"]; });

/* harmony import */ var _internal_core_Registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./.internal/core/Registry */ "./node_modules/@amcharts/amcharts5/.internal/core/Registry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addLicense", function() { return _internal_core_Registry__WEBPACK_IMPORTED_MODULE_2__["addLicense"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registry", function() { return _internal_core_Registry__WEBPACK_IMPORTED_MODULE_2__["registry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disposeAllRootElements", function() { return _internal_core_Registry__WEBPACK_IMPORTED_MODULE_2__["disposeAllRootElements"]; });

/* harmony import */ var _internal_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./.internal/core/util/Utils */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ready", function() { return _internal_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__["ready"]; });

/* harmony import */ var _internal_core_util_Modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./.internal/core/util/Modal */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Modal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Modal", function() { return _internal_core_util_Modal__WEBPACK_IMPORTED_MODULE_4__["Modal"]; });

/* harmony import */ var _internal_core_util_Entity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./.internal/core/util/Entity */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Entity", function() { return _internal_core_util_Entity__WEBPACK_IMPORTED_MODULE_5__["Entity"]; });

/* harmony import */ var _internal_core_util_Disposer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./.internal/core/util/Disposer */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Disposer", function() { return _internal_core_util_Disposer__WEBPACK_IMPORTED_MODULE_6__["Disposer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArrayDisposer", function() { return _internal_core_util_Disposer__WEBPACK_IMPORTED_MODULE_6__["ArrayDisposer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MultiDisposer", function() { return _internal_core_util_Disposer__WEBPACK_IMPORTED_MODULE_6__["MultiDisposer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MutableValueDisposer", function() { return _internal_core_util_Disposer__WEBPACK_IMPORTED_MODULE_6__["MutableValueDisposer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CounterDisposer", function() { return _internal_core_util_Disposer__WEBPACK_IMPORTED_MODULE_6__["CounterDisposer"]; });

/* harmony import */ var _internal_core_render_Bullet__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./.internal/core/render/Bullet */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Bullet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bullet", function() { return _internal_core_render_Bullet__WEBPACK_IMPORTED_MODULE_7__["Bullet"]; });

/* harmony import */ var _internal_core_render_Button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./.internal/core/render/Button */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Button", function() { return _internal_core_render_Button__WEBPACK_IMPORTED_MODULE_8__["Button"]; });

/* harmony import */ var _internal_core_render_Circle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./.internal/core/render/Circle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return _internal_core_render_Circle__WEBPACK_IMPORTED_MODULE_9__["Circle"]; });

/* harmony import */ var _internal_core_render_Ellipse__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./.internal/core/render/Ellipse */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Ellipse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Ellipse", function() { return _internal_core_render_Ellipse__WEBPACK_IMPORTED_MODULE_10__["Ellipse"]; });

/* harmony import */ var _internal_core_render_Star__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./.internal/core/render/Star */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Star.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Star", function() { return _internal_core_render_Star__WEBPACK_IMPORTED_MODULE_11__["Star"]; });

/* harmony import */ var _internal_core_render_Component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./.internal/core/render/Component */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return _internal_core_render_Component__WEBPACK_IMPORTED_MODULE_12__["Component"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataItem", function() { return _internal_core_render_Component__WEBPACK_IMPORTED_MODULE_12__["DataItem"]; });

/* harmony import */ var _internal_core_render_Container__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./.internal/core/render/Container */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Container", function() { return _internal_core_render_Container__WEBPACK_IMPORTED_MODULE_13__["Container"]; });

/* harmony import */ var _internal_core_render_Graphics__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./.internal/core/render/Graphics */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Graphics", function() { return _internal_core_render_Graphics__WEBPACK_IMPORTED_MODULE_14__["Graphics"]; });

/* harmony import */ var _internal_core_render_GridLayout__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./.internal/core/render/GridLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GridLayout", function() { return _internal_core_render_GridLayout__WEBPACK_IMPORTED_MODULE_15__["GridLayout"]; });

/* harmony import */ var _internal_core_render_HeatLegend__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./.internal/core/render/HeatLegend */ "./node_modules/@amcharts/amcharts5/.internal/core/render/HeatLegend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HeatLegend", function() { return _internal_core_render_HeatLegend__WEBPACK_IMPORTED_MODULE_16__["HeatLegend"]; });

/* harmony import */ var _internal_core_render_HorizontalLayout__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./.internal/core/render/HorizontalLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HorizontalLayout", function() { return _internal_core_render_HorizontalLayout__WEBPACK_IMPORTED_MODULE_17__["HorizontalLayout"]; });

/* harmony import */ var _internal_core_render_Label__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./.internal/core/render/Label */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Label", function() { return _internal_core_render_Label__WEBPACK_IMPORTED_MODULE_18__["Label"]; });

/* harmony import */ var _internal_core_render_Layout__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./.internal/core/render/Layout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Layout", function() { return _internal_core_render_Layout__WEBPACK_IMPORTED_MODULE_19__["Layout"]; });

/* harmony import */ var _internal_core_render_Legend__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./.internal/core/render/Legend */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Legend.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Legend", function() { return _internal_core_render_Legend__WEBPACK_IMPORTED_MODULE_20__["Legend"]; });

/* harmony import */ var _internal_core_render_Line__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./.internal/core/render/Line */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return _internal_core_render_Line__WEBPACK_IMPORTED_MODULE_21__["Line"]; });

/* harmony import */ var _internal_core_render_Picture__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./.internal/core/render/Picture */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Picture.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Picture", function() { return _internal_core_render_Picture__WEBPACK_IMPORTED_MODULE_22__["Picture"]; });

/* harmony import */ var _internal_core_render_PointedRectangle__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./.internal/core/render/PointedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointedRectangle", function() { return _internal_core_render_PointedRectangle__WEBPACK_IMPORTED_MODULE_23__["PointedRectangle"]; });

/* harmony import */ var _internal_core_render_RadialLabel__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./.internal/core/render/RadialLabel */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RadialLabel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RadialLabel", function() { return _internal_core_render_RadialLabel__WEBPACK_IMPORTED_MODULE_24__["RadialLabel"]; });

/* harmony import */ var _internal_core_render_RadialText__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./.internal/core/render/RadialText */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RadialText.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RadialText", function() { return _internal_core_render_RadialText__WEBPACK_IMPORTED_MODULE_25__["RadialText"]; });

/* harmony import */ var _internal_core_render_Rectangle__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./.internal/core/render/Rectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Rectangle", function() { return _internal_core_render_Rectangle__WEBPACK_IMPORTED_MODULE_26__["Rectangle"]; });

/* harmony import */ var _internal_core_render_Triangle__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./.internal/core/render/Triangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Triangle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return _internal_core_render_Triangle__WEBPACK_IMPORTED_MODULE_27__["Triangle"]; });

/* harmony import */ var _internal_core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./.internal/core/render/RoundedRectangle */ "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RoundedRectangle", function() { return _internal_core_render_RoundedRectangle__WEBPACK_IMPORTED_MODULE_28__["RoundedRectangle"]; });

/* harmony import */ var _internal_core_render_Scrollbar__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./.internal/core/render/Scrollbar */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Scrollbar.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Scrollbar", function() { return _internal_core_render_Scrollbar__WEBPACK_IMPORTED_MODULE_29__["Scrollbar"]; });

/* harmony import */ var _internal_core_render_Slider__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./.internal/core/render/Slider */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Slider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Slider", function() { return _internal_core_render_Slider__WEBPACK_IMPORTED_MODULE_30__["Slider"]; });

/* harmony import */ var _internal_core_render_Slice__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./.internal/core/render/Slice */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Slice.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Slice", function() { return _internal_core_render_Slice__WEBPACK_IMPORTED_MODULE_31__["Slice"]; });

/* harmony import */ var _internal_core_render_Sprite__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./.internal/core/render/Sprite */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return _internal_core_render_Sprite__WEBPACK_IMPORTED_MODULE_32__["Sprite"]; });

/* harmony import */ var _internal_core_render_Series__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./.internal/core/render/Series */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Series", function() { return _internal_core_render_Series__WEBPACK_IMPORTED_MODULE_33__["Series"]; });

/* harmony import */ var _internal_core_render_Chart__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./.internal/core/render/Chart */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Chart", function() { return _internal_core_render_Chart__WEBPACK_IMPORTED_MODULE_34__["Chart"]; });

/* harmony import */ var _internal_core_render_SerialChart__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./.internal/core/render/SerialChart */ "./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SerialChart", function() { return _internal_core_render_SerialChart__WEBPACK_IMPORTED_MODULE_35__["SerialChart"]; });

/* harmony import */ var _internal_core_render_Text__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./.internal/core/render/Text */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Text", function() { return _internal_core_render_Text__WEBPACK_IMPORTED_MODULE_36__["Text"]; });

/* harmony import */ var _internal_core_render_Tick__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./.internal/core/render/Tick */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tick", function() { return _internal_core_render_Tick__WEBPACK_IMPORTED_MODULE_37__["Tick"]; });

/* harmony import */ var _internal_core_render_Tooltip__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./.internal/core/render/Tooltip */ "./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tooltip", function() { return _internal_core_render_Tooltip__WEBPACK_IMPORTED_MODULE_38__["Tooltip"]; });

/* harmony import */ var _internal_core_render_VerticalLayout__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./.internal/core/render/VerticalLayout */ "./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VerticalLayout", function() { return _internal_core_render_VerticalLayout__WEBPACK_IMPORTED_MODULE_39__["VerticalLayout"]; });

/* harmony import */ var _internal_core_util_Timezone__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./.internal/core/util/Timezone */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Timezone.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Timezone", function() { return _internal_core_util_Timezone__WEBPACK_IMPORTED_MODULE_40__["Timezone"]; });

/* harmony import */ var _internal_core_render_gradients_Gradient__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./.internal/core/render/gradients/Gradient */ "./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/Gradient.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Gradient", function() { return _internal_core_render_gradients_Gradient__WEBPACK_IMPORTED_MODULE_41__["Gradient"]; });

/* harmony import */ var _internal_core_render_gradients_LinearGradient__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./.internal/core/render/gradients/LinearGradient */ "./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/LinearGradient.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinearGradient", function() { return _internal_core_render_gradients_LinearGradient__WEBPACK_IMPORTED_MODULE_42__["LinearGradient"]; });

/* harmony import */ var _internal_core_render_gradients_RadialGradient__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./.internal/core/render/gradients/RadialGradient */ "./node_modules/@amcharts/amcharts5/.internal/core/render/gradients/RadialGradient.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RadialGradient", function() { return _internal_core_render_gradients_RadialGradient__WEBPACK_IMPORTED_MODULE_43__["RadialGradient"]; });

/* harmony import */ var _internal_core_render_patterns_CirclePattern__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./.internal/core/render/patterns/CirclePattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/CirclePattern.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CirclePattern", function() { return _internal_core_render_patterns_CirclePattern__WEBPACK_IMPORTED_MODULE_44__["CirclePattern"]; });

/* harmony import */ var _internal_core_render_patterns_LinePattern__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./.internal/core/render/patterns/LinePattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/LinePattern.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LinePattern", function() { return _internal_core_render_patterns_LinePattern__WEBPACK_IMPORTED_MODULE_45__["LinePattern"]; });

/* harmony import */ var _internal_core_render_patterns_Pattern__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./.internal/core/render/patterns/Pattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pattern", function() { return _internal_core_render_patterns_Pattern__WEBPACK_IMPORTED_MODULE_46__["Pattern"]; });

/* harmony import */ var _internal_core_render_patterns_PicturePattern__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./.internal/core/render/patterns/PicturePattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PicturePattern.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PicturePattern", function() { return _internal_core_render_patterns_PicturePattern__WEBPACK_IMPORTED_MODULE_47__["PicturePattern"]; });

/* harmony import */ var _internal_core_render_patterns_RectanglePattern__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./.internal/core/render/patterns/RectanglePattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/RectanglePattern.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RectanglePattern", function() { return _internal_core_render_patterns_RectanglePattern__WEBPACK_IMPORTED_MODULE_48__["RectanglePattern"]; });

/* harmony import */ var _internal_core_render_patterns_PathPattern__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./.internal/core/render/patterns/PathPattern */ "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PathPattern.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PathPattern", function() { return _internal_core_render_patterns_PathPattern__WEBPACK_IMPORTED_MODULE_49__["PathPattern"]; });

/* harmony import */ var _internal_core_util_Color__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./.internal/core/util/Color */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return _internal_core_util_Color__WEBPACK_IMPORTED_MODULE_50__["Color"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _internal_core_util_Color__WEBPACK_IMPORTED_MODULE_50__["color"]; });

/* harmony import */ var _internal_core_util_ColorSet__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./.internal/core/util/ColorSet */ "./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorSet", function() { return _internal_core_util_ColorSet__WEBPACK_IMPORTED_MODULE_51__["ColorSet"]; });

/* harmony import */ var _internal_core_util_Data__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./.internal/core/util/Data */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ListData", function() { return _internal_core_util_Data__WEBPACK_IMPORTED_MODULE_52__["ListData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JsonData", function() { return _internal_core_util_Data__WEBPACK_IMPORTED_MODULE_52__["JsonData"]; });

/* harmony import */ var _internal_core_util_DataParser__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./.internal/core/util/DataParser */ "./node_modules/@amcharts/amcharts5/.internal/core/util/DataParser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSONParser", function() { return _internal_core_util_DataParser__WEBPACK_IMPORTED_MODULE_53__["JSONParser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CSVParser", function() { return _internal_core_util_DataParser__WEBPACK_IMPORTED_MODULE_53__["CSVParser"]; });

/* harmony import */ var _internal_core_util_DataProcessor__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./.internal/core/util/DataProcessor */ "./node_modules/@amcharts/amcharts5/.internal/core/util/DataProcessor.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataProcessor", function() { return _internal_core_util_DataProcessor__WEBPACK_IMPORTED_MODULE_54__["DataProcessor"]; });

/* harmony import */ var _internal_core_util_DateFormatter__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./.internal/core/util/DateFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateFormatter", function() { return _internal_core_util_DateFormatter__WEBPACK_IMPORTED_MODULE_55__["DateFormatter"]; });

/* harmony import */ var _internal_core_util_DurationFormatter__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./.internal/core/util/DurationFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DurationFormatter", function() { return _internal_core_util_DurationFormatter__WEBPACK_IMPORTED_MODULE_56__["DurationFormatter"]; });

/* harmony import */ var _internal_core_util_InterfaceColors__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./.internal/core/util/InterfaceColors */ "./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InterfaceColors", function() { return _internal_core_util_InterfaceColors__WEBPACK_IMPORTED_MODULE_57__["InterfaceColors"]; });

/* harmony import */ var _internal_core_util_NumberFormatter__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./.internal/core/util/NumberFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NumberFormatter", function() { return _internal_core_util_NumberFormatter__WEBPACK_IMPORTED_MODULE_58__["NumberFormatter"]; });

/* harmony import */ var _internal_core_util_Percent__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./.internal/core/util/Percent */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Percent", function() { return _internal_core_util_Percent__WEBPACK_IMPORTED_MODULE_59__["Percent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "percent", function() { return _internal_core_util_Percent__WEBPACK_IMPORTED_MODULE_59__["percent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "p100", function() { return _internal_core_util_Percent__WEBPACK_IMPORTED_MODULE_59__["p100"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "p50", function() { return _internal_core_util_Percent__WEBPACK_IMPORTED_MODULE_59__["p50"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "p0", function() { return _internal_core_util_Percent__WEBPACK_IMPORTED_MODULE_59__["p0"]; });

/* harmony import */ var _internal_core_util_Template__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./.internal/core/util/Template */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Template", function() { return _internal_core_util_Template__WEBPACK_IMPORTED_MODULE_60__["Template"]; });

/* harmony import */ var _internal_core_util_TextFormatter__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./.internal/core/util/TextFormatter */ "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextFormatter", function() { return _internal_core_util_TextFormatter__WEBPACK_IMPORTED_MODULE_61__["TextFormatter"]; });

/* harmony import */ var _internal_core_render_SpriteResizer__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./.internal/core/render/SpriteResizer */ "./node_modules/@amcharts/amcharts5/.internal/core/render/SpriteResizer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SpriteResizer", function() { return _internal_core_render_SpriteResizer__WEBPACK_IMPORTED_MODULE_62__["SpriteResizer"]; });

/* harmony import */ var _internal_core_util_Array__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./.internal/core/util/Array */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "array", function() { return _internal_core_util_Array__WEBPACK_IMPORTED_MODULE_63__; });
/* harmony import */ var _internal_core_util_Ease__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./.internal/core/util/Ease */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "ease", function() { return _internal_core_util_Ease__WEBPACK_IMPORTED_MODULE_64__; });
/* harmony import */ var _internal_core_util_Math__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./.internal/core/util/Math */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "math", function() { return _internal_core_util_Math__WEBPACK_IMPORTED_MODULE_65__; });
/* harmony import */ var _internal_core_util_Net__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./.internal/core/util/Net */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Net.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "net", function() { return _internal_core_util_Net__WEBPACK_IMPORTED_MODULE_66__; });
/* harmony import */ var _internal_core_util_Object__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./.internal/core/util/Object */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "object", function() { return _internal_core_util_Object__WEBPACK_IMPORTED_MODULE_67__; });
/* harmony import */ var _internal_core_util_Time__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./.internal/core/util/Time */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "time", function() { return _internal_core_util_Time__WEBPACK_IMPORTED_MODULE_68__; });
/* harmony import */ var _internal_core_util_Type__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./.internal/core/util/Type */ "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "type", function() { return _internal_core_util_Type__WEBPACK_IMPORTED_MODULE_69__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return _internal_core_util_Utils__WEBPACK_IMPORTED_MODULE_3__; });


























































//export { Language, ILanguageSettings } from "./.internal/core/util/Language";
//export { List, IListSettings } from "./.internal/core/util/List";





















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/locales/en.js":
/*!********************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/locales/en.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * amCharts 5 locale
 *
 * Locale: en
 * Language: International English
 * Author: Martynas Majeris
 *
 * Follow instructions in [on this page](https://www.amcharts.com/docs/v5/tutorials/creating-translations/) to make corrections or add new translations.
 *
 * ---
 * Edit but leave the header section above this line. You can remove any
 * subsequent comment sections.
 * ---
 *
 * Use this file as a template to create translations. Leave the key part in
 * English intact. Fill the value with a translation.
 *
 * Empty string means no translation, so default "International English"
 * will be used.
 *
 * If you need the translation to literally be an empty string, use `null`
 * instead.
 *
 * IMPORTANT:
 * When translating make good effort to keep the translation length
 * at least the same chartcount as the English, especially for short prompts.
 *
 * Having significantly longer prompts may distort the actual charts.
 *
 * NOTE:
 * Some prompts - like months or weekdays - come in two versions: full and
 * shortened.
 *
 * If there's no official shortened version of these in your language, and it
 * would not be possible to invent such short versions that don't seem weird
 * to native speakers of that language, fill those with the same as full
 * version.
 *
 * PLACEHOLDERS:
 * Some prompts have placeholders like "%1". Those will be replaced by actual
 * values during translation and should be retained in the translated prompts.
 *
 * Placeholder positions may be changed to better suit structure of the
 * sentence.
 *
 * For example "From %1 to %2", when actually used will replace "%1" with an
 * actual value representing range start, and "%2" will be replaced by end
 * value.
 *
 * E.g. in a Scrollbar for Value axis "From %1 to %2" will become
 * "From 100 to 200". You may translate "From" and "to", as well as re-arrange
 * the order of the prompt itself, but make sure the "%1" and "%2" remain, in
 * places where they will make sense.
 *
 * Save the file as language_LOCALE, i.e. `en_GB.ts`, `fr_FR.ts`, etc.
 */
/* harmony default export */ __webpack_exports__["default"] = ({
    "firstDayOfWeek": 1,
    // Number formatting options.
    // 
    // Please check with the local standards which separator is accepted to be
    // used for separating decimals, and which for thousands.
    "_decimalSeparator": ".",
    "_thousandSeparator": ",",
    // Position of the percent sign in numbers
    "_percentPrefix": null,
    "_percentSuffix": "%",
    // Suffixes for numbers
    // When formatting numbers, big or small numers might be reformatted to
    // shorter version, by applying a suffix.
    // 
    // For example, 1000000 might become "1m".
    // Or 1024 might become "1KB" if we're formatting byte numbers.
    // 
    // This section defines such suffixes for all such cases.
    "_big_number_suffix_3": "k",
    "_big_number_suffix_6": "M",
    "_big_number_suffix_9": "G",
    "_big_number_suffix_12": "T",
    "_big_number_suffix_15": "P",
    "_big_number_suffix_18": "E",
    "_big_number_suffix_21": "Z",
    "_big_number_suffix_24": "Y",
    "_small_number_suffix_3": "m",
    "_small_number_suffix_6": "μ",
    "_small_number_suffix_9": "n",
    "_small_number_suffix_12": "p",
    "_small_number_suffix_15": "f",
    "_small_number_suffix_18": "a",
    "_small_number_suffix_21": "z",
    "_small_number_suffix_24": "y",
    "_byte_suffix_B": "B",
    "_byte_suffix_KB": "KB",
    "_byte_suffix_MB": "MB",
    "_byte_suffix_GB": "GB",
    "_byte_suffix_TB": "TB",
    "_byte_suffix_PB": "PB",
    // Default date formats for various periods.
    // 
    // This should reflect official or de facto formatting universally accepted
    // in the country translation is being made for
    // Available format codes here:
    // https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#Format_codes
    // 
    // This will be used when formatting date/time for particular granularity,
    // e.g. "_date_hour" will be shown whenever we need to show time as hours.
    // 
    // "date" is used as in default date format when showing standalone dates.
    "_date": "yyyy-MM-dd",
    "_date_millisecond": "mm:ss SSS",
    "_date_millisecond_full": "HH:mm:ss SSS",
    "_date_second": "HH:mm:ss",
    "_date_second_full": "HH:mm:ss",
    "_date_minute": "HH:mm",
    "_date_minute_full": "HH:mm - MMM dd, yyyy",
    "_date_hour": "HH:mm",
    "_date_hour_full": "HH:mm - MMM dd, yyyy",
    "_date_day": "MMM dd",
    "_date_day_full": "MMM dd, yyyy",
    "_date_week": "ww",
    "_date_week_full": "MMM dd, yyyy",
    "_date_month": "MMM",
    "_date_month_full": "MMM, yyyy",
    "_date_year": "yyyy",
    // Default duration formats for various base units.
    // 
    // This will be used by DurationFormatter to format numeric values into
    // duration.
    // 
    // Notice how each duration unit comes in several versions. This is to ensure
    // that each base unit is shown correctly.
    // 
    // For example, if we have baseUnit set to "second", meaning our duration is
    // in seconds.
    // 
    // If we pass in `50` to formatter, it will know that we have just 50 seconds
    // (less than a minute) so it will use format in `"_duration_second"` ("ss"),
    // and the formatted result will be in like `"50"`.
    // 
    // If we pass in `70`, which is more than a minute, the formatter will switch
    // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted
    // text.
    // 
    // Available codes here:
    // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes
    "_duration_millisecond": "SSS",
    "_duration_millisecond_second": "ss.SSS",
    "_duration_millisecond_minute": "mm:ss SSS",
    "_duration_millisecond_hour": "hh:mm:ss SSS",
    "_duration_millisecond_day": "d'd' mm:ss SSS",
    "_duration_millisecond_week": "d'd' mm:ss SSS",
    "_duration_millisecond_month": "M'm' dd'd' mm:ss SSS",
    "_duration_millisecond_year": "y'y' MM'm' dd'd' mm:ss SSS",
    "_duration_second": "ss",
    "_duration_second_minute": "mm:ss",
    "_duration_second_hour": "hh:mm:ss",
    "_duration_second_day": "d'd' hh:mm:ss",
    "_duration_second_week": "d'd' hh:mm:ss",
    "_duration_second_month": "M'm' dd'd' hh:mm:ss",
    "_duration_second_year": "y'y' MM'm' dd'd' hh:mm:ss",
    "_duration_minute": "mm",
    "_duration_minute_hour": "hh:mm",
    "_duration_minute_day": "d'd' hh:mm",
    "_duration_minute_week": "d'd' hh:mm",
    "_duration_minute_month": "M'm' dd'd' hh:mm",
    "_duration_minute_year": "y'y' MM'm' dd'd' hh:mm",
    "_duration_hour": "hh'h'",
    "_duration_hour_day": "d'd' hh'h'",
    "_duration_hour_week": "d'd' hh'h'",
    "_duration_hour_month": "M'm' dd'd' hh'h'",
    "_duration_hour_year": "y'y' MM'm' dd'd' hh'h'",
    "_duration_day": "d'd'",
    "_duration_day_week": "d'd'",
    "_duration_day_month": "M'm' dd'd'",
    "_duration_day_year": "y'y' MM'm' dd'd'",
    "_duration_week": "w'w'",
    "_duration_week_month": "w'w'",
    "_duration_week_year": "w'w'",
    "_duration_month": "M'm'",
    "_duration_month_year": "y'y' MM'm'",
    "_duration_year": "y'y'",
    // Era translations
    "_era_ad": "AD",
    "_era_bc": "BC",
    // Day part, used in 12-hour formats, e.g. 5 P.M.
    // Please note that these come in 3 variants:
    // * one letter (e.g. "A")
    // * two letters (e.g. "AM")
    // * two letters with dots (e.g. "A.M.")
    // 
    // All three need to to be translated even if they are all the same. Some
    // users might use one, some the other.
    "A": "",
    "P": "",
    "AM": "",
    "PM": "",
    "A.M.": "",
    "P.M.": "",
    // Date-related stuff.
    // 
    // When translating months, if there's a difference, use the form which is
    // best for a full date, e.g. as you would use it in "2018 January 1".
    // 
    // Note that May is listed twice. This is because in English May is the same
    // in both long and short forms, while in other languages it may not be the
    // case. Translate "May" to full word, while "May(short)" to shortened
    // version.
    // 
    // Should month names and weekdays be capitalized or not?
    // 
    // Rule of thumb is this: if the names should always be capitalized,
    // regardless of name position within date ("January", "21st January 2018",
    // etc.) use capitalized names. Otherwise enter all lowercase.
    // 
    // The date formatter will automatically capitalize names if they are the
    // first (or only) word in resulting date.
    "January": "",
    "February": "",
    "March": "",
    "April": "",
    "May": "",
    "June": "",
    "July": "",
    "August": "",
    "September": "",
    "October": "",
    "November": "",
    "December": "",
    "Jan": "",
    "Feb": "",
    "Mar": "",
    "Apr": "",
    "May(short)": "May",
    "Jun": "",
    "Jul": "",
    "Aug": "",
    "Sep": "",
    "Oct": "",
    "Nov": "",
    "Dec": "",
    // Weekdays.
    "Sunday": "",
    "Monday": "",
    "Tuesday": "",
    "Wednesday": "",
    "Thursday": "",
    "Friday": "",
    "Saturday": "",
    "Sun": "",
    "Mon": "",
    "Tue": "",
    "Wed": "",
    "Thu": "",
    "Fri": "",
    "Sat": "",
    // Date ordinal function.
    // 
    // This is used when adding number ordinal when formatting days in dates.
    // 
    // E.g. "January 1st", "February 2nd".
    // 
    // The function accepts day number, and returns a string to be added to the
    // day, like in default English translation, if we pass in 2, we will receive
    // "nd" back.
    "_dateOrd": function (day) {
        let res = "th";
        if ((day < 11) || (day > 13)) {
            switch (day % 10) {
                case 1:
                    res = "st";
                    break;
                case 2:
                    res = "nd";
                    break;
                case 3:
                    res = "rd";
                    break;
            }
        }
        return res;
    },
    // Various chart controls.
    // Shown as a tooltip on zoom out button.
    "Zoom Out": "",
    // Timeline buttons
    "Play": "",
    "Stop": "",
    // Chart's Legend screen reader title.
    "Legend": "",
    // Legend's item screen reader indicator.
    "Press ENTER to toggle": "",
    // Shown when the chart is busy loading something.
    "Loading": "",
    // Shown as the first button in the breadcrumb navigation, e.g.:
    // Home > First level > ...
    "Home": "",
    // Chart types.
    // Those are used as default screen reader titles for the main chart element
    // unless developer has set some more descriptive title.
    "Chart": "",
    "Serial chart": "",
    "X/Y chart": "",
    "Pie chart": "",
    "Gauge chart": "",
    "Radar chart": "",
    "Sankey diagram": "",
    "Flow diagram": "",
    "Chord diagram": "",
    "TreeMap chart": "",
    "Force directed tree": "",
    "Sliced chart": "",
    // Series types.
    // Used to name series by type for screen readers if they do not have their
    // name set.
    "Series": "",
    "Candlestick Series": "",
    "OHLC Series": "",
    "Column Series": "",
    "Line Series": "",
    "Pie Slice Series": "",
    "Funnel Series": "",
    "Pyramid Series": "",
    "X/Y Series": "",
    // Map-related stuff.
    "Map": "",
    "Press ENTER to zoom in": "",
    "Press ENTER to zoom out": "",
    "Use arrow keys to zoom in and out": "",
    "Use plus and minus keys on your keyboard to zoom in and out": "",
    // Export-related stuff.
    // These prompts are used in Export menu labels.
    // 
    // "Export" is the top-level menu item.
    // 
    // "Image", "Data", "Print" as second-level indicating type of export
    // operation.
    // 
    // Leave actual format untranslated, unless you absolutely know that they
    // would convey more meaning in some other way.
    "Export": "",
    "Image": "",
    "Data": "",
    "Print": "",
    "Press ENTER or use arrow keys to navigate": "",
    "Press ENTER to open": "",
    "Press ENTER to print.": "",
    "Press ENTER to export as %1.": "",
    "(Press ESC to close this message)": "",
    "Image Export Complete": "",
    "Export operation took longer than expected. Something might have gone wrong.": "",
    "Saved from": "",
    "PNG": "",
    "JPG": "",
    "GIF": "",
    "SVG": "",
    "PDF": "",
    "JSON": "",
    "CSV": "",
    "XLSX": "",
    "HTML": "",
    // Scrollbar-related stuff.
    // 
    // Scrollbar is a control which can zoom and pan the axes on the chart.
    // 
    // Each scrollbar has two grips: left or right (for horizontal scrollbar) or
    // upper and lower (for vertical one).
    // 
    // Prompts change in relation to whether Scrollbar is vertical or horizontal.
    // 
    // The final section is used to indicate the current range of selection.
    "Use TAB to select grip buttons or left and right arrows to change selection": "",
    "Use left and right arrows to move selection": "",
    "Use left and right arrows to move left selection": "",
    "Use left and right arrows to move right selection": "",
    "Use TAB select grip buttons or up and down arrows to change selection": "",
    "Use up and down arrows to move selection": "",
    "Use up and down arrows to move lower selection": "",
    "Use up and down arrows to move upper selection": "",
    "From %1 to %2": "",
    "From %1": "",
    "To %1": "",
    // Data loader-related.
    "No parser available for file: %1": "",
    "Error parsing file: %1": "",
    "Unable to load file: %1": "",
    "Invalid date": "",
    // Common actions
    "Close": "",
    "Minimize": ""
});
//# sourceMappingURL=en.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/node_modules/tslib/tslib.es6.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/node_modules/tslib/tslib.es6.js ***!
  \**************************************************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __esDecorate, __runInitializers, __propKey, __setFunctionName, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet, __classPrivateFieldIn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__esDecorate", function() { return __esDecorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__runInitializers", function() { return __runInitializers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__propKey", function() { return __propKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__setFunctionName", function() { return __setFunctionName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArray", function() { return __spreadArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldIn", function() { return __classPrivateFieldIn; });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.push(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.push(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};

function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};

function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}


/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/themes/Animated.js":
/*!*************************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/themes/Animated.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_themes_AnimatedTheme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../.internal/themes/AnimatedTheme */ "./node_modules/@amcharts/amcharts5/.internal/themes/AnimatedTheme.js");

/* harmony default export */ __webpack_exports__["default"] = (_internal_themes_AnimatedTheme__WEBPACK_IMPORTED_MODULE_0__["AnimatedTheme"]);
//# sourceMappingURL=Animated.js.map

/***/ }),

/***/ "./node_modules/@amcharts/amcharts5/xy.js":
/*!************************************************!*\
  !*** ./node_modules/@amcharts/amcharts5/xy.js ***!
  \************************************************/
/*! exports provided: XYChart, XYChartScrollbar, XYCursor, BaseColumnSeries, Axis, CategoryAxis, CategoryDateAxis, DateAxis, GaplessDateAxis, DurationAxis, ValueAxis, AxisBullet, AxisLabel, AxisLabelRadial, AxisTick, Grid, AxisRenderer, AxisRendererX, AxisRendererY, XYSeries, Candlestick, CandlestickSeries, OHLC, OHLCSeries, ColumnSeries, LineSeries, SmoothedYLineSeries, SmoothedXLineSeries, SmoothedXYLineSeries, StepLineSeries, DefaultTheme */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal_charts_xy_XYChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.internal/charts/xy/XYChart */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XYChart", function() { return _internal_charts_xy_XYChart__WEBPACK_IMPORTED_MODULE_0__["XYChart"]; });

/* harmony import */ var _internal_charts_xy_XYChartScrollbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.internal/charts/xy/XYChartScrollbar */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartScrollbar.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XYChartScrollbar", function() { return _internal_charts_xy_XYChartScrollbar__WEBPACK_IMPORTED_MODULE_1__["XYChartScrollbar"]; });

/* harmony import */ var _internal_charts_xy_XYCursor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./.internal/charts/xy/XYCursor */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYCursor.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XYCursor", function() { return _internal_charts_xy_XYCursor__WEBPACK_IMPORTED_MODULE_2__["XYCursor"]; });

/* harmony import */ var _internal_charts_xy_series_BaseColumnSeries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./.internal/charts/xy/series/BaseColumnSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseColumnSeries", function() { return _internal_charts_xy_series_BaseColumnSeries__WEBPACK_IMPORTED_MODULE_3__["BaseColumnSeries"]; });

/* harmony import */ var _internal_charts_xy_axes_Axis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./.internal/charts/xy/axes/Axis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Axis", function() { return _internal_charts_xy_axes_Axis__WEBPACK_IMPORTED_MODULE_4__["Axis"]; });

/* harmony import */ var _internal_charts_xy_axes_CategoryAxis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./.internal/charts/xy/axes/CategoryAxis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CategoryAxis", function() { return _internal_charts_xy_axes_CategoryAxis__WEBPACK_IMPORTED_MODULE_5__["CategoryAxis"]; });

/* harmony import */ var _internal_charts_xy_axes_CategoryDateAxis__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./.internal/charts/xy/axes/CategoryDateAxis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryDateAxis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CategoryDateAxis", function() { return _internal_charts_xy_axes_CategoryDateAxis__WEBPACK_IMPORTED_MODULE_6__["CategoryDateAxis"]; });

/* harmony import */ var _internal_charts_xy_axes_DateAxis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./.internal/charts/xy/axes/DateAxis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/DateAxis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateAxis", function() { return _internal_charts_xy_axes_DateAxis__WEBPACK_IMPORTED_MODULE_7__["DateAxis"]; });

/* harmony import */ var _internal_charts_xy_axes_GaplessDateAxis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./.internal/charts/xy/axes/GaplessDateAxis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/GaplessDateAxis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GaplessDateAxis", function() { return _internal_charts_xy_axes_GaplessDateAxis__WEBPACK_IMPORTED_MODULE_8__["GaplessDateAxis"]; });

/* harmony import */ var _internal_charts_xy_axes_DurationAxis__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./.internal/charts/xy/axes/DurationAxis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/DurationAxis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DurationAxis", function() { return _internal_charts_xy_axes_DurationAxis__WEBPACK_IMPORTED_MODULE_9__["DurationAxis"]; });

/* harmony import */ var _internal_charts_xy_axes_ValueAxis__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./.internal/charts/xy/axes/ValueAxis */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ValueAxis", function() { return _internal_charts_xy_axes_ValueAxis__WEBPACK_IMPORTED_MODULE_10__["ValueAxis"]; });

/* harmony import */ var _internal_charts_xy_axes_AxisBullet__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./.internal/charts/xy/axes/AxisBullet */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisBullet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxisBullet", function() { return _internal_charts_xy_axes_AxisBullet__WEBPACK_IMPORTED_MODULE_11__["AxisBullet"]; });

/* harmony import */ var _internal_charts_xy_axes_AxisLabel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./.internal/charts/xy/axes/AxisLabel */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxisLabel", function() { return _internal_charts_xy_axes_AxisLabel__WEBPACK_IMPORTED_MODULE_12__["AxisLabel"]; });

/* harmony import */ var _internal_charts_xy_axes_AxisLabelRadial__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./.internal/charts/xy/axes/AxisLabelRadial */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabelRadial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxisLabelRadial", function() { return _internal_charts_xy_axes_AxisLabelRadial__WEBPACK_IMPORTED_MODULE_13__["AxisLabelRadial"]; });

/* harmony import */ var _internal_charts_xy_axes_AxisTick__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./.internal/charts/xy/axes/AxisTick */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxisTick", function() { return _internal_charts_xy_axes_AxisTick__WEBPACK_IMPORTED_MODULE_14__["AxisTick"]; });

/* harmony import */ var _internal_charts_xy_axes_Grid__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./.internal/charts/xy/axes/Grid */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Grid", function() { return _internal_charts_xy_axes_Grid__WEBPACK_IMPORTED_MODULE_15__["Grid"]; });

/* harmony import */ var _internal_charts_xy_axes_AxisRenderer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./.internal/charts/xy/axes/AxisRenderer */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxisRenderer", function() { return _internal_charts_xy_axes_AxisRenderer__WEBPACK_IMPORTED_MODULE_16__["AxisRenderer"]; });

/* harmony import */ var _internal_charts_xy_axes_AxisRendererX__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./.internal/charts/xy/axes/AxisRendererX */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxisRendererX", function() { return _internal_charts_xy_axes_AxisRendererX__WEBPACK_IMPORTED_MODULE_17__["AxisRendererX"]; });

/* harmony import */ var _internal_charts_xy_axes_AxisRendererY__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./.internal/charts/xy/axes/AxisRendererY */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxisRendererY", function() { return _internal_charts_xy_axes_AxisRendererY__WEBPACK_IMPORTED_MODULE_18__["AxisRendererY"]; });

/* harmony import */ var _internal_charts_xy_series_XYSeries__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./.internal/charts/xy/series/XYSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XYSeries", function() { return _internal_charts_xy_series_XYSeries__WEBPACK_IMPORTED_MODULE_19__["XYSeries"]; });

/* harmony import */ var _internal_charts_xy_series_Candlestick__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./.internal/charts/xy/series/Candlestick */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/Candlestick.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Candlestick", function() { return _internal_charts_xy_series_Candlestick__WEBPACK_IMPORTED_MODULE_20__["Candlestick"]; });

/* harmony import */ var _internal_charts_xy_series_CandlestickSeries__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./.internal/charts/xy/series/CandlestickSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/CandlestickSeries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CandlestickSeries", function() { return _internal_charts_xy_series_CandlestickSeries__WEBPACK_IMPORTED_MODULE_21__["CandlestickSeries"]; });

/* harmony import */ var _internal_charts_xy_series_OHLC__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./.internal/charts/xy/series/OHLC */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/OHLC.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OHLC", function() { return _internal_charts_xy_series_OHLC__WEBPACK_IMPORTED_MODULE_22__["OHLC"]; });

/* harmony import */ var _internal_charts_xy_series_OHLCSeries__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./.internal/charts/xy/series/OHLCSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/OHLCSeries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OHLCSeries", function() { return _internal_charts_xy_series_OHLCSeries__WEBPACK_IMPORTED_MODULE_23__["OHLCSeries"]; });

/* harmony import */ var _internal_charts_xy_series_ColumnSeries__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./.internal/charts/xy/series/ColumnSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColumnSeries", function() { return _internal_charts_xy_series_ColumnSeries__WEBPACK_IMPORTED_MODULE_24__["ColumnSeries"]; });

/* harmony import */ var _internal_charts_xy_series_LineSeries__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./.internal/charts/xy/series/LineSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/LineSeries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineSeries", function() { return _internal_charts_xy_series_LineSeries__WEBPACK_IMPORTED_MODULE_25__["LineSeries"]; });

/* harmony import */ var _internal_charts_xy_series_SmoothedYLineSeries__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./.internal/charts/xy/series/SmoothedYLineSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/SmoothedYLineSeries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SmoothedYLineSeries", function() { return _internal_charts_xy_series_SmoothedYLineSeries__WEBPACK_IMPORTED_MODULE_26__["SmoothedYLineSeries"]; });

/* harmony import */ var _internal_charts_xy_series_SmoothedXLineSeries__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./.internal/charts/xy/series/SmoothedXLineSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/SmoothedXLineSeries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SmoothedXLineSeries", function() { return _internal_charts_xy_series_SmoothedXLineSeries__WEBPACK_IMPORTED_MODULE_27__["SmoothedXLineSeries"]; });

/* harmony import */ var _internal_charts_xy_series_SmoothedXYLineSeries__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./.internal/charts/xy/series/SmoothedXYLineSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/SmoothedXYLineSeries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SmoothedXYLineSeries", function() { return _internal_charts_xy_series_SmoothedXYLineSeries__WEBPACK_IMPORTED_MODULE_28__["SmoothedXYLineSeries"]; });

/* harmony import */ var _internal_charts_xy_series_StepLineSeries__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./.internal/charts/xy/series/StepLineSeries */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/StepLineSeries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StepLineSeries", function() { return _internal_charts_xy_series_StepLineSeries__WEBPACK_IMPORTED_MODULE_29__["StepLineSeries"]; });

/* harmony import */ var _internal_charts_xy_XYChartDefaultTheme__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./.internal/charts/xy/XYChartDefaultTheme */ "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultTheme", function() { return _internal_charts_xy_XYChartDefaultTheme__WEBPACK_IMPORTED_MODULE_30__["XYChartDefaultTheme"]; });

































//# sourceMappingURL=xy.js.map

/***/ }),

/***/ "./node_modules/d3-path/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-path/src/index.js ***!
  \*******************************************/
/*! exports provided: Path, path, pathRound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-path/src/path.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return _path_js__WEBPACK_IMPORTED_MODULE_0__["Path"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "path", function() { return _path_js__WEBPACK_IMPORTED_MODULE_0__["path"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pathRound", function() { return _path_js__WEBPACK_IMPORTED_MODULE_0__["pathRound"]; });




/***/ }),

/***/ "./node_modules/d3-path/src/path.js":
/*!******************************************!*\
  !*** ./node_modules/d3-path/src/path.js ***!
  \******************************************/
/*! exports provided: Path, path, pathRound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "path", function() { return path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pathRound", function() { return pathRound; });
const pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}

function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}

class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x, y) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x, y) {
    this._append`L${this._x1 = +x},${this._y1 = +y}`;
  }
  quadraticCurveTo(x1, y1, x, y) {
    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    }

    // Otherwise, draw an arc!
    else {
      let x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }

      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
    }
  }
  rect(x, y, w, h) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}

function path() {
  return new Path;
}

// Allow instanceof d3.path
path.prototype = Path.prototype;

function pathRound(digits = 3) {
  return new Path(+digits);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/arc.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/arc.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["max"])(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null,
      path = Object(_path_js__WEBPACK_IMPORTED_MODULE_2__["withPath"])(arc);

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
        a1 = endAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
        da = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"])) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math_js__WEBPACK_IMPORTED_MODULE_1__["tau"] - _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
      context.moveTo(r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(a0), r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
        context.moveTo(r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(a1), r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) && (padRadius ? +padRadius.apply(this, arguments) : Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(r0 * r0 + r1 * r1)),
          rc = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["min"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["abs"])(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
        var p0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["asin"])(rp / r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(ap)),
            p1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["asin"])(rp / r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(ap));
        if ((da0 -= p0 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(a01),
          y01 = r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(a01),
          x10 = r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(a10),
          y10 = r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(a10);

      // Apply rounded corners?
      if (rc > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
        var x11 = r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(a11),
            y11 = r1 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(a11),
            x00 = r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(a00),
            y00 = r0 * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(a00),
            oc;

        // Restrict the corner radius according to the sector angle. If this
        // intersection fails, it’s probably because the arc is too small, so
        // disable the corner radius entirely.
        if (da < _math_js__WEBPACK_IMPORTED_MODULE_1__["pi"]) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0],
                ay = y01 - oc[1],
                bx = x11 - oc[0],
                by = y11 - oc[1],
                kc = 1 / Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["acos"])((ax * bx + ay * by) / (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(ax * ax + ay * ay) * Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(bx * bx + by * by))) / 2),
                lc = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["min"])(rc, (r0 - lc) / (kc - 1));
            rc1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["min"])(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"])) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t0.y01, t0.x01), Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t0.y01, t0.x01), Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t0.cy + t0.y11, t0.cx + t0.x11), Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t1.y11, t1.x11), Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) || !(da0 > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"])) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > _math_js__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t0.y01, t0.x01), Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t0.y01, t0.x01), Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t0.cy + t0.y11, t0.cx + t0.x11), Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t1.y11, t1.x11), Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["atan2"])(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math_js__WEBPACK_IMPORTED_MODULE_1__["pi"] / 2;
    return [Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["cos"])(a) * r, Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["sin"])(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/area.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/area.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");







/* harmony default export */ __webpack_exports__["default"] = (function(x0, y0, y1) {
  var x1 = null,
      defined = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_2__["default"],
      output = null,
      path = Object(_path_js__WEBPACK_IMPORTED_MODULE_4__["withPath"])(area);

  x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_5__["x"] : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+x0);
  y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(0) : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+y0);
  y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_5__["y"] : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return Object(_line_js__WEBPACK_IMPORTED_MODULE_3__["default"])().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/areaRadial.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/areaRadial.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _curve_radial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial.js */ "./node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/d3-shape/src/area.js");
/* harmony import */ var _lineRadial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lineRadial.js */ "./node_modules/d3-shape/src/lineRadial.js");




/* harmony default export */ __webpack_exports__["default"] = (function() {
  var a = Object(_area_js__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial_js__WEBPACK_IMPORTED_MODULE_0__["curveRadialLinear"]),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return Object(_lineRadial_js__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return Object(_lineRadial_js__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return Object(_lineRadial_js__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return Object(_lineRadial_js__WEBPACK_IMPORTED_MODULE_2__["lineRadial"])(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(Object(_curve_radial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return a;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/array.js ***!
  \********************************************/
/*! exports provided: slice, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
var slice = Array.prototype.slice;

/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
});


/***/ }),

/***/ "./node_modules/d3-shape/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/constant.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x) {
  return function constant() {
    return x;
  };
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/basis.js ***!
  \**************************************************/
/*! exports provided: point, Basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Basis", function() { return Basis; });
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // falls through
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Basis(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/basisClosed.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-shape/src/curve/basis.js");



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: Object(_basis_js__WEBPACK_IMPORTED_MODULE_1__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new BasisClosed(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/basisOpen.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/basisOpen.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-shape/src/curve/basis.js");


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // falls through
      default: Object(_basis_js__WEBPACK_IMPORTED_MODULE_0__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new BasisOpen(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/bump.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/bump.js ***!
  \*************************************************/
/*! exports provided: bumpX, bumpY, bumpRadial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bumpX", function() { return bumpX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bumpY", function() { return bumpY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bumpRadial", function() { return bumpRadial; });
/* harmony import */ var _pointRadial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointRadial.js */ "./node_modules/d3-shape/src/pointRadial.js");


class Bump {
  constructor(context, x) {
    this._context = context;
    this._x = x;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x, y);
        else this._context.moveTo(x, y);
        break;
      }
      case 1: this._point = 2; // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
        break;
      }
    }
    this._x0 = x, this._y0 = y;
  }
}

class BumpRadial {
  constructor(context) {
    this._context = context;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {}
  point(x, y) {
    x = +x, y = +y;
    if (this._point === 0) {
      this._point = 1;
    } else {
      const p0 = Object(_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this._x0, this._y0);
      const p1 = Object(_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this._x0, this._y0 = (this._y0 + y) / 2);
      const p2 = Object(_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, this._y0);
      const p3 = Object(_pointRadial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x, y);
      this._context.moveTo(...p0);
      this._context.bezierCurveTo(...p1, ...p2, ...p3);
    }
    this._x0 = x, this._y0 = y;
  }
}

function bumpX(context) {
  return new Bump(context, true);
}

function bumpY(context) {
  return new Bump(context, false);
}

function bumpRadial(context) {
  return new BumpRadial(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/bundle.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/bundle.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-shape/src/curve/basis.js");


function Bundle(context, beta) {
  this._basis = new _basis_js__WEBPACK_IMPORTED_MODULE_0__["Basis"](context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new _basis_js__WEBPACK_IMPORTED_MODULE_0__["Basis"](context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/cardinal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/cardinal.js ***!
  \*****************************************************/
/*! exports provided: point, Cardinal, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cardinal", function() { return Cardinal; });
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // falls through
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/cardinalClosed.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/cardinalClosed.js ***!
  \***********************************************************/
/*! exports provided: CardinalClosed, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardinalClosed", function() { return CardinalClosed; });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: Object(_cardinal_js__WEBPACK_IMPORTED_MODULE_1__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/cardinalOpen.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/cardinalOpen.js ***!
  \*********************************************************/
/*! exports provided: CardinalOpen, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CardinalOpen", function() { return CardinalOpen; });
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // falls through
      default: Object(_cardinal_js__WEBPACK_IMPORTED_MODULE_0__["point"])(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/catmullRom.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/catmullRom.js ***!
  \*******************************************************/
/*! exports provided: point, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math_js__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // falls through
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal_js__WEBPACK_IMPORTED_MODULE_1__["Cardinal"](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/catmullRomClosed.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/catmullRomClosed.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cardinalClosed_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalClosed.js */ "./node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");
/* harmony import */ var _catmullRom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./catmullRom.js */ "./node_modules/d3-shape/src/curve/catmullRom.js");




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: Object(_catmullRom_js__WEBPACK_IMPORTED_MODULE_2__["point"])(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed_js__WEBPACK_IMPORTED_MODULE_0__["CardinalClosed"](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/catmullRomOpen.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/catmullRomOpen.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cardinalOpen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinalOpen.js */ "./node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _catmullRom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./catmullRom.js */ "./node_modules/d3-shape/src/curve/catmullRom.js");



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // falls through
      default: Object(_catmullRom_js__WEBPACK_IMPORTED_MODULE_1__["point"])(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen_js__WEBPACK_IMPORTED_MODULE_0__["CardinalOpen"](context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linear.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linear.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // falls through
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Linear(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linearClosed.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linearClosed.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new LinearClosed(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/monotone.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/monotone.js ***!
  \*****************************************************/
/*! exports provided: monotoneX, monotoneY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monotoneX", function() { return monotoneX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "monotoneY", function() { return monotoneY; });
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/natural.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/natural.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Natural(context);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/radial.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/radial.js ***!
  \***************************************************/
/*! exports provided: curveRadialLinear, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveRadialLinear", function() { return curveRadialLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return curveRadial; });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-shape/src/curve/linear.js");


var curveRadialLinear = curveRadial(_linear_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/step.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/step.js ***!
  \*************************************************/
/*! exports provided: default, stepBefore, stepAfter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stepBefore", function() { return stepBefore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stepAfter", function() { return stepAfter; });
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // falls through
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ __webpack_exports__["default"] = (function(context) {
  return new Step(context, 0.5);
});

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/descending.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/identity.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(d) {
  return d;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/index.js ***!
  \********************************************/
/*! exports provided: arc, area, line, pie, areaRadial, radialArea, lineRadial, radialLine, pointRadial, link, linkHorizontal, linkVertical, linkRadial, symbol, symbolsStroke, symbolsFill, symbols, symbolAsterisk, symbolCircle, symbolCross, symbolDiamond, symbolDiamond2, symbolPlus, symbolSquare, symbolSquare2, symbolStar, symbolTriangle, symbolTriangle2, symbolWye, symbolTimes, symbolX, curveBasisClosed, curveBasisOpen, curveBasis, curveBumpX, curveBumpY, curveBundle, curveCardinalClosed, curveCardinalOpen, curveCardinal, curveCatmullRomClosed, curveCatmullRomOpen, curveCatmullRom, curveLinearClosed, curveLinear, curveMonotoneX, curveMonotoneY, curveNatural, curveStep, curveStepAfter, curveStepBefore, stack, stackOffsetExpand, stackOffsetDiverging, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderAppearance, stackOrderAscending, stackOrderDescending, stackOrderInsideOut, stackOrderNone, stackOrderReverse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _arc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arc.js */ "./node_modules/d3-shape/src/arc.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arc", function() { return _arc_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/d3-shape/src/area.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "area", function() { return _area_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "line", function() { return _line_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _pie_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pie.js */ "./node_modules/d3-shape/src/pie.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pie", function() { return _pie_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _areaRadial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./areaRadial.js */ "./node_modules/d3-shape/src/areaRadial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "areaRadial", function() { return _areaRadial_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radialArea", function() { return _areaRadial_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _lineRadial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lineRadial.js */ "./node_modules/d3-shape/src/lineRadial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lineRadial", function() { return _lineRadial_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radialLine", function() { return _lineRadial_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _pointRadial_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointRadial.js */ "./node_modules/d3-shape/src/pointRadial.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pointRadial", function() { return _pointRadial_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./link.js */ "./node_modules/d3-shape/src/link.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "link", function() { return _link_js__WEBPACK_IMPORTED_MODULE_7__["link"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkHorizontal", function() { return _link_js__WEBPACK_IMPORTED_MODULE_7__["linkHorizontal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkVertical", function() { return _link_js__WEBPACK_IMPORTED_MODULE_7__["linkVertical"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linkRadial", function() { return _link_js__WEBPACK_IMPORTED_MODULE_7__["linkRadial"]; });

/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symbol.js */ "./node_modules/d3-shape/src/symbol.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbol", function() { return _symbol_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolsStroke", function() { return _symbol_js__WEBPACK_IMPORTED_MODULE_8__["symbolsStroke"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolsFill", function() { return _symbol_js__WEBPACK_IMPORTED_MODULE_8__["symbolsFill"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbols", function() { return _symbol_js__WEBPACK_IMPORTED_MODULE_8__["symbolsFill"]; });

/* harmony import */ var _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./symbol/asterisk.js */ "./node_modules/d3-shape/src/symbol/asterisk.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolAsterisk", function() { return _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./symbol/circle.js */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolCircle", function() { return _symbol_circle_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./symbol/cross.js */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolCross", function() { return _symbol_cross_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./symbol/diamond.js */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolDiamond", function() { return _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./symbol/diamond2.js */ "./node_modules/d3-shape/src/symbol/diamond2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolDiamond2", function() { return _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _symbol_plus_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./symbol/plus.js */ "./node_modules/d3-shape/src/symbol/plus.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolPlus", function() { return _symbol_plus_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./symbol/square.js */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolSquare", function() { return _symbol_square_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _symbol_square2_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./symbol/square2.js */ "./node_modules/d3-shape/src/symbol/square2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolSquare2", function() { return _symbol_square2_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./symbol/star.js */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolStar", function() { return _symbol_star_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./symbol/triangle.js */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolTriangle", function() { return _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./symbol/triangle2.js */ "./node_modules/d3-shape/src/symbol/triangle2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolTriangle2", function() { return _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./symbol/wye.js */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolWye", function() { return _symbol_wye_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _symbol_times_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./symbol/times.js */ "./node_modules/d3-shape/src/symbol/times.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolTimes", function() { return _symbol_times_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "symbolX", function() { return _symbol_times_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _curve_basisClosed_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./curve/basisClosed.js */ "./node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasisClosed", function() { return _curve_basisClosed_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _curve_basisOpen_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./curve/basisOpen.js */ "./node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasisOpen", function() { return _curve_basisOpen_js__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _curve_basis_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./curve/basis.js */ "./node_modules/d3-shape/src/curve/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBasis", function() { return _curve_basis_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _curve_bump_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./curve/bump.js */ "./node_modules/d3-shape/src/curve/bump.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBumpX", function() { return _curve_bump_js__WEBPACK_IMPORTED_MODULE_25__["bumpX"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBumpY", function() { return _curve_bump_js__WEBPACK_IMPORTED_MODULE_25__["bumpY"]; });

/* harmony import */ var _curve_bundle_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./curve/bundle.js */ "./node_modules/d3-shape/src/curve/bundle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveBundle", function() { return _curve_bundle_js__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _curve_cardinalClosed_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./curve/cardinalClosed.js */ "./node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinalClosed", function() { return _curve_cardinalClosed_js__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _curve_cardinalOpen_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./curve/cardinalOpen.js */ "./node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinalOpen", function() { return _curve_cardinalOpen_js__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _curve_cardinal_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./curve/cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCardinal", function() { return _curve_cardinal_js__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _curve_catmullRomClosed_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./curve/catmullRomClosed.js */ "./node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRomClosed", function() { return _curve_catmullRomClosed_js__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _curve_catmullRomOpen_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./curve/catmullRomOpen.js */ "./node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRomOpen", function() { return _curve_catmullRomOpen_js__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _curve_catmullRom_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./curve/catmullRom.js */ "./node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveCatmullRom", function() { return _curve_catmullRom_js__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _curve_linearClosed_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./curve/linearClosed.js */ "./node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveLinearClosed", function() { return _curve_linearClosed_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveLinear", function() { return _curve_linear_js__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _curve_monotone_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./curve/monotone.js */ "./node_modules/d3-shape/src/curve/monotone.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneX", function() { return _curve_monotone_js__WEBPACK_IMPORTED_MODULE_35__["monotoneX"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveMonotoneY", function() { return _curve_monotone_js__WEBPACK_IMPORTED_MODULE_35__["monotoneY"]; });

/* harmony import */ var _curve_natural_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./curve/natural.js */ "./node_modules/d3-shape/src/curve/natural.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveNatural", function() { return _curve_natural_js__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _curve_step_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./curve/step.js */ "./node_modules/d3-shape/src/curve/step.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStep", function() { return _curve_step_js__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStepAfter", function() { return _curve_step_js__WEBPACK_IMPORTED_MODULE_37__["stepAfter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "curveStepBefore", function() { return _curve_step_js__WEBPACK_IMPORTED_MODULE_37__["stepBefore"]; });

/* harmony import */ var _stack_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./stack.js */ "./node_modules/d3-shape/src/stack.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return _stack_js__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _offset_expand_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./offset/expand.js */ "./node_modules/d3-shape/src/offset/expand.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetExpand", function() { return _offset_expand_js__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _offset_diverging_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./offset/diverging.js */ "./node_modules/d3-shape/src/offset/diverging.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetDiverging", function() { return _offset_diverging_js__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _offset_none_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./offset/none.js */ "./node_modules/d3-shape/src/offset/none.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetNone", function() { return _offset_none_js__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _offset_silhouette_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./offset/silhouette.js */ "./node_modules/d3-shape/src/offset/silhouette.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetSilhouette", function() { return _offset_silhouette_js__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _offset_wiggle_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./offset/wiggle.js */ "./node_modules/d3-shape/src/offset/wiggle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOffsetWiggle", function() { return _offset_wiggle_js__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _order_appearance_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./order/appearance.js */ "./node_modules/d3-shape/src/order/appearance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderAppearance", function() { return _order_appearance_js__WEBPACK_IMPORTED_MODULE_44__["default"]; });

/* harmony import */ var _order_ascending_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./order/ascending.js */ "./node_modules/d3-shape/src/order/ascending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderAscending", function() { return _order_ascending_js__WEBPACK_IMPORTED_MODULE_45__["default"]; });

/* harmony import */ var _order_descending_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./order/descending.js */ "./node_modules/d3-shape/src/order/descending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderDescending", function() { return _order_descending_js__WEBPACK_IMPORTED_MODULE_46__["default"]; });

/* harmony import */ var _order_insideOut_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./order/insideOut.js */ "./node_modules/d3-shape/src/order/insideOut.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderInsideOut", function() { return _order_insideOut_js__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony import */ var _order_none_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./order/none.js */ "./node_modules/d3-shape/src/order/none.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderNone", function() { return _order_none_js__WEBPACK_IMPORTED_MODULE_48__["default"]; });

/* harmony import */ var _order_reverse_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./order/reverse.js */ "./node_modules/d3-shape/src/order/reverse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stackOrderReverse", function() { return _order_reverse_js__WEBPACK_IMPORTED_MODULE_49__["default"]; });





 // Note: radialArea is deprecated!
 // Note: radialLine is deprecated!

















































/***/ }),

/***/ "./node_modules/d3-shape/src/line.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/line.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






/* harmony default export */ __webpack_exports__["default"] = (function(x, y) {
  var defined = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_2__["default"],
      output = null,
      path = Object(_path_js__WEBPACK_IMPORTED_MODULE_3__["withPath"])(line);

  x = typeof x === "function" ? x : (x === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_4__["x"] : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(x);
  y = typeof y === "function" ? y : (y === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_4__["y"] : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(y);

  function line(data) {
    var i,
        n = (data = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data)).length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/lineRadial.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/lineRadial.js ***!
  \*************************************************/
/*! exports provided: lineRadial, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineRadial", function() { return lineRadial; });
/* harmony import */ var _curve_radial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve/radial.js */ "./node_modules/d3-shape/src/curve/radial.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");



function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(Object(_curve_radial_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_)) : c()._curve;
  };

  return l;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  return lineRadial(Object(_line_js__WEBPACK_IMPORTED_MODULE_1__["default"])().curve(_curve_radial_js__WEBPACK_IMPORTED_MODULE_0__["curveRadialLinear"]));
});


/***/ }),

/***/ "./node_modules/d3-shape/src/link.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/link.js ***!
  \*******************************************/
/*! exports provided: link, linkHorizontal, linkVertical, linkRadial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "link", function() { return link; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linkHorizontal", function() { return linkHorizontal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linkVertical", function() { return linkVertical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linkRadial", function() { return linkRadial; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_bump_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve/bump.js */ "./node_modules/d3-shape/src/curve/bump.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  let source = linkSource,
      target = linkTarget,
      x = _point_js__WEBPACK_IMPORTED_MODULE_4__["x"],
      y = _point_js__WEBPACK_IMPORTED_MODULE_4__["y"],
      context = null,
      output = null,
      path = Object(_path_js__WEBPACK_IMPORTED_MODULE_3__["withPath"])(link);

  function link() {
    let buffer;
    const argv = _array_js__WEBPACK_IMPORTED_MODULE_0__["slice"].call(arguments);
    const s = source.apply(this, argv);
    const t = target.apply(this, argv);
    if (context == null) output = curve(buffer = path());
    output.lineStart();
    argv[0] = s, output.point(+x.apply(this, argv), +y.apply(this, argv));
    argv[0] = t, output.point(+x.apply(this, argv), +y.apply(this, argv));
    output.lineEnd();
    if (buffer) return output = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), link) : x;
  };

  link.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), link) : y;
  };

  link.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link) : context;
  };

  return link;
}

function linkHorizontal() {
  return link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_2__["bumpX"]);
}

function linkVertical() {
  return link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_2__["bumpY"]);
}

function linkRadial() {
  const l = link(_curve_bump_js__WEBPACK_IMPORTED_MODULE_2__["bumpRadial"]);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/math.js ***!
  \*******************************************/
/*! exports provided: abs, atan2, cos, max, min, sin, sqrt, epsilon, pi, halfPi, tau, acos, asin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pi", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPi", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tau", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;

const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/noop.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/noop.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function() {});


/***/ }),

/***/ "./node_modules/d3-shape/src/offset/diverging.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/offset/diverging.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/offset/expand.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/offset/expand.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/offset/none.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/offset/none.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/offset/silhouette.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-shape/src/offset/silhouette.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/offset/wiggle.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/offset/wiggle.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/offset/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series, order);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/order/appearance.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/order/appearance.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/order/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var peaks = series.map(peak);
  return Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
});

function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/order/ascending.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/order/ascending.js ***!
  \******************************************************/
/*! exports provided: default, sum */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return sum; });
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/order/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var sums = series.map(sum);
  return Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series).sort(function(a, b) { return sums[a] - sums[b]; });
});

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/order/descending.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/order/descending.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-shape/src/order/ascending.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  return Object(_ascending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
});


/***/ }),

/***/ "./node_modules/d3-shape/src/order/insideOut.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/order/insideOut.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _appearance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./appearance.js */ "./node_modules/d3-shape/src/order/appearance.js");
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-shape/src/order/ascending.js");



/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(_ascending_js__WEBPACK_IMPORTED_MODULE_1__["sum"]),
      order = Object(_appearance_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
});


/***/ }),

/***/ "./node_modules/d3-shape/src/order/none.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/order/none.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/order/reverse.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/order/reverse.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _none_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./none.js */ "./node_modules/d3-shape/src/order/none.js");


/* harmony default export */ __webpack_exports__["default"] = (function(series) {
  return Object(_none_js__WEBPACK_IMPORTED_MODULE_0__["default"])(series).reverse();
});


/***/ }),

/***/ "./node_modules/d3-shape/src/path.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/path.js ***!
  \*******************************************/
/*! exports provided: withPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withPath", function() { return withPath; });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/index.js");


function withPath(shape) {
  let digits = 3;

  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };

  return () => new d3_path__WEBPACK_IMPORTED_MODULE_0__["Path"](digits);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pie.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/pie.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _descending_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./descending.js */ "./node_modules/d3-shape/src/descending.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-shape/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");






/* harmony default export */ __webpack_exports__["default"] = (function() {
  var value = _identity_js__WEBPACK_IMPORTED_MODULE_3__["default"],
      sortValues = _descending_js__WEBPACK_IMPORTED_MODULE_2__["default"],
      sort = null,
      startAngle = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(0),
      endAngle = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_math_js__WEBPACK_IMPORTED_MODULE_4__["tau"]),
      padAngle = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(0);

  function pie(data) {
    var i,
        n = (data = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data)).length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math_js__WEBPACK_IMPORTED_MODULE_4__["tau"], Math.max(-_math_js__WEBPACK_IMPORTED_MODULE_4__["tau"], endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), pie) : padAngle;
  };

  return pie;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/point.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/point.js ***!
  \********************************************/
/*! exports provided: x, y */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return x; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return y; });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/pointRadial.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/pointRadial.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
});


/***/ }),

/***/ "./node_modules/d3-shape/src/stack.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/stack.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _offset_none_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./offset/none.js */ "./node_modules/d3-shape/src/offset/none.js");
/* harmony import */ var _order_none_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./order/none.js */ "./node_modules/d3-shape/src/order/none.js");





function stackValue(d, key) {
  return d[key];
}

function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}

/* harmony default export */ __webpack_exports__["default"] = (function() {
  var keys = Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([]),
      order = _order_none_js__WEBPACK_IMPORTED_MODULE_3__["default"],
      offset = _offset_none_js__WEBPACK_IMPORTED_MODULE_2__["default"],
      value = stackValue;

  function stack(data) {
    var sz = Array.from(keys.apply(this, arguments), stackSeries),
        i, n = sz.length, j = -1,
        oz;

    for (const d of data) {
      for (i = 0, ++j; i < n; ++i) {
        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
      }
    }

    for (i = 0, oz = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(order(sz)); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Array.from(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? _order_none_js__WEBPACK_IMPORTED_MODULE_3__["default"] : typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Array.from(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? _offset_none_js__WEBPACK_IMPORTED_MODULE_2__["default"] : _, stack) : offset;
  };

  return stack;
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-shape/src/symbol.js ***!
  \*********************************************/
/*! exports provided: symbolsFill, symbolsStroke, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "symbolsFill", function() { return symbolsFill; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "symbolsStroke", function() { return symbolsStroke; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Symbol; });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-shape/src/path.js");
/* harmony import */ var _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/asterisk.js */ "./node_modules/d3-shape/src/symbol/asterisk.js");
/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/circle.js */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/cross.js */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/diamond.js */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/diamond2.js */ "./node_modules/d3-shape/src/symbol/diamond2.js");
/* harmony import */ var _symbol_plus_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./symbol/plus.js */ "./node_modules/d3-shape/src/symbol/plus.js");
/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symbol/square.js */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_square2_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./symbol/square2.js */ "./node_modules/d3-shape/src/symbol/square2.js");
/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./symbol/star.js */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./symbol/triangle.js */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./symbol/triangle2.js */ "./node_modules/d3-shape/src/symbol/triangle2.js");
/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./symbol/wye.js */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _symbol_times_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./symbol/times.js */ "./node_modules/d3-shape/src/symbol/times.js");
















// These symbols are designed to be filled.
const symbolsFill = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  _symbol_square_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  _symbol_star_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_13__["default"]
];

// These symbols are designed to be stroked (with a width of 1.5px and round caps).
const symbolsStroke = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  _symbol_plus_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  _symbol_times_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  _symbol_triangle2_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  _symbol_asterisk_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  _symbol_square2_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  _symbol_diamond2_js__WEBPACK_IMPORTED_MODULE_6__["default"]
];

function Symbol(type, size) {
  let context = null,
      path = Object(_path_js__WEBPACK_IMPORTED_MODULE_1__["withPath"])(symbol);

  type = typeof type === "function" ? type : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(type || _symbol_circle_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
  size = typeof size === "function" ? size : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(size === undefined ? 64 : +size);

  function symbol() {
    let buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/asterisk.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/asterisk.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(3);

/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size + Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["min"])(size / 28, 0.75)) * 0.59436;
    const t = r / 2;
    const u = t * sqrt3;
    context.moveTo(0, r);
    context.lineTo(0, -r);
    context.moveTo(-u, -t);
    context.lineTo(u, t);
    context.moveTo(-u, t);
    context.lineTo(u, -t);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/circle.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/circle.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size / _math_js__WEBPACK_IMPORTED_MODULE_0__["pi"]);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__["tau"]);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/cross.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/cross.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const tan30 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(1 / 3);
const tan30_2 = tan30 * 2;

/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const y = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size / tan30_2);
    const x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond2.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond2.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size) * 0.62625;
    context.moveTo(0, -r);
    context.lineTo(r, 0);
    context.lineTo(0, r);
    context.lineTo(-r, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/plus.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/plus.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["min"])(size / 7, 2)) * 0.87559;
    context.moveTo(-r, 0);
    context.lineTo(r, 0);
    context.moveTo(0, r);
    context.lineTo(0, -r);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const w = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size);
    const x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square2.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square2.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size) * 0.4431;
    context.moveTo(r, r);
    context.lineTo(r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/star.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/star.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const ka = 0.89081309152928522810;
const kr = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(_math_js__WEBPACK_IMPORTED_MODULE_0__["pi"] / 10) / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__["pi"] / 10);
const kx = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(_math_js__WEBPACK_IMPORTED_MODULE_0__["tau"] / 10) * kr;
const ky = -Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(_math_js__WEBPACK_IMPORTED_MODULE_0__["tau"] / 10) * kr;

/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size * ka);
    const x = kx * r;
    const y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (let i = 1; i < 5; ++i) {
      const a = _math_js__WEBPACK_IMPORTED_MODULE_0__["tau"] * i / 5;
      const c = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cos"])(a);
      const s = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sin"])(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/times.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/times.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size - Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["min"])(size / 6, 1.7)) * 0.6189;
    context.moveTo(-r, -r);
    context.lineTo(r, r);
    context.moveTo(-r, r);
    context.lineTo(r, -r);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(3);

/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const y = -Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle2.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle2.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const sqrt3 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(3);

/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const s = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size) * 0.6824;
    const t = s  / 2;
    const u = (s * sqrt3) / 2; // cos(Math.PI / 6)
    context.moveTo(0, -s);
    context.lineTo(u, t);
    context.lineTo(-u, t);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/wye.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/wye.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


const c = -0.5;
const s = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(3) / 2;
const k = 1 / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(12);
const a = (k / 2 + 1) * 3;

/* harmony default export */ __webpack_exports__["default"] = ({
  draw(context, size) {
    const r = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(size / a);
    const x0 = r / 2, y0 = r * k;
    const x1 = x0, y1 = r * k + r;
    const x2 = -x1, y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/svg-arc-to-cubic-bezier/modules/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/svg-arc-to-cubic-bezier/modules/index.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var TAU = Math.PI * 2;

var mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x,
      y = _ref.y;

  x *= rx;
  y *= ry;

  var xp = cosphi * x - sinphi * y;
  var yp = sinphi * x + cosphi * y;

  return {
    x: xp + centerx,
    y: yp + centery
  };
};

var approxUnitArc = function approxUnitArc(ang1, ang2) {
  // If 90 degree circular arc, use a constant
  // as derived from http://spencermortensen.com/articles/bezier-circle
  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);

  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);

  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};

var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;

  var dot = ux * vx + uy * vy;

  if (dot > 1) {
    dot = 1;
  }

  if (dot < -1) {
    dot = -1;
  }

  return sign * Math.acos(dot);
};

var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);

  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

  if (radicant < 0) {
    radicant = 0;
  }

  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);

  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;

  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;

  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;

  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }

  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }

  return [centerx, centery, ang1, ang2];
};

var arcToBezier = function arcToBezier(_ref2) {
  var px = _ref2.px,
      py = _ref2.py,
      cx = _ref2.cx,
      cy = _ref2.cy,
      rx = _ref2.rx,
      ry = _ref2.ry,
      _ref2$xAxisRotation = _ref2.xAxisRotation,
      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,
      _ref2$largeArcFlag = _ref2.largeArcFlag,
      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,
      _ref2$sweepFlag = _ref2.sweepFlag,
      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;

  var curves = [];

  if (rx === 0 || ry === 0) {
    return [];
  }

  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);

  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

  if (pxp === 0 && pyp === 0) {
    return [];
  }

  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }

  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),
      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),
      centerx = _getArcCenter2[0],
      centery = _getArcCenter2[1],
      ang1 = _getArcCenter2[2],
      ang2 = _getArcCenter2[3];

  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to
  // 1.0000000001. This causes `segments` to be greater than one, which is an
  // unecessary split, and adds extra points to the bezier curve. To alleviate
  // this issue, we round to 1.0 when the ratio is close to 1.0.


  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1.0 - ratio) < 0.0000001) {
    ratio = 1.0;
  }

  var segments = Math.max(Math.ceil(ratio), 1);

  ang2 /= segments;

  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }

  return curves.map(function (curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),
        x1 = _mapToEllipse.x,
        y1 = _mapToEllipse.y;

    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),
        x2 = _mapToEllipse2.x,
        y2 = _mapToEllipse2.y;

    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),
        x = _mapToEllipse3.x,
        y = _mapToEllipse3.y;

    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
  });
};

/* harmony default export */ __webpack_exports__["default"] = (arcToBezier);

/***/ })

}]);